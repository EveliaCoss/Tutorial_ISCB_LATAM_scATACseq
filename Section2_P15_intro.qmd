# **Practical 15:** Multimodal analysis and Integration {#install .setup style="blue"}

In this step, we will demonstrate the following:

-   Analyzing the differences between merging vs integration of data.
-   Loading and pre-processing scATAC-seq, multiome, and scRNA-seq reference datasets
-   Mapping the scATAC-seq dataset using bridge integration.
-   Performing joint RNA and ATAC analysis to explore the relationship between gene expression and chromatin accessibility in single-cell datasets.
-   Exploring and evaluating the resulting annotations.

# **Batch Effect Correction** {.setup style="blue"}

Variation in different [Chromium Single Cell ATAC](https://www.10xgenomics.com/products/single-cell-atac) (Assay for Transposase Accessible Chromatin) samples can be affected by technical factors, such as laboratory conditions or reagent choices. These batch effects may confound true biological variation between samples. Therefore, correcting the batch effects can be useful for data analysis.

If you are combining libraries generated by Chromium Single Cell ATAC v1.1 and v2 reagents, you might observe systematic differences in chromatin structure profiles between libraries. Here, we will demonstrate how to use community-developed tools to merge and correct batch effects between Single Cell ATAC v1.1 and v2 data. The same procedure could also be used to correct other types of batch effects.

## Option 1: Merging objects

When merging multiple single-cell chromatin datasets, it's important to be aware that if peak calling was performed on each dataset independently, the peaks are unlikely to be exactly the same. **We therefore need to create a common set of peaks across all the datasets to be merged.**

The two datasets used in this example can be found here: [dataset 1: 10k Human PBMCs, ATAC v1.1 cells](https://www.10xgenomics.com/datasets/10k-human-pbmcs-atac-v1-1-chromium-x-1-1-standard) and [dataset 2: 10k Human PBMCs, ATAC v2 cells](https://www.10xgenomics.com/datasets/10k-human-pbmcs-atac-v2-chromium-controller-2-standard).

::: {.callout-note collapse="true"}
#### Download the datasets

From: [Batch Effect Correction in Chromium Single Cell ATAC Data](https://www.10xgenomics.com/analysis-guides/batch-effect-correction-in-chromium-single-cell-atac-data)

```{r, eval=FALSE}
# Set working directory before downloading files
setwd("data")

# Download dataset 1 filtered_peak_bc_matrix.h5 file

download.file("https://cf.10xgenomics.com/samples/cell-atac/2.1.0/10k_pbmc_ATACv1p1_nextgem_Chromium_X/10k_pbmc_ATACv1p1_nextgem_Chromium_X_filtered_peak_bc_matrix.h5","10k_pbmc_ATACv1p1_nextgem_Chromium_X_filtered_peak_bc_matrix.h5")

# Download dataset 2 filtered_peak_bc_matrix.h5 file

download.file("https://cf.10xgenomics.com/samples/cell-atac/2.1.0/10k_pbmc_ATACv2_nextgem_Chromium_X/10k_pbmc_ATACv2_nextgem_Chromium_X_filtered_peak_bc_matrix.h5","10k_pbmc_ATACv2_nextgem_Chromium_X_filtered_peak_bc_matrix.h5")
```
:::

[![](img/batcheffect.png)](https://rpubs.com/eraz0001/Harmony)

## Option 2: **Harmony batch effect**

We can use the [Harmony batch effect correction algorithm](https://www.nature.com/articles/s41592-019-0619-0) (Korsunsky et al. 2019) implemented in the [Signac R package](https://satijalab.org/signac). The [Harmony algorithm](https://github.com/immunogenomics/harmony) is available on GitHub, and Signac has [tutorials for integration](https://stuartlab.org/signac/articles/integrate_atac).

```{r, eval=FALSE}
hm.integrated <- RunHarmony(object = unintegrated, group.by.vars = 'dataset', reduction = 'lsi', assay.use = 'peaks', project.dim = FALSE)
hm.integrated <- RunUMAP(hm.integrated, dims = 2:30, reduction = 'harmony')
DimPlot(hm.integrated, group.by = 'dataset', pt.size = 0.1)

```

[![](https://cdn.10xgenomics.com/image/upload/c_scale,w_600/v1650308284/analysis-guides/atac-batch-correction/atac-batch-correction-Step4_figure.png)](https://www.10xgenomics.com/analysis-guides/batch-effect-correction-in-chromium-single-cell-atac-data)

## Option 3: scATAC-seq data integration

An important first step in any integrative analysis of single-cell chromatin data is to ensure that the same features are measured in each dataset. Here, we quantify the **multiome peaks in the ATAC dataset to ensure that there are common features across the two datasets**. See the [merge vignette](https://stuartlab.org/signac/articles/merging) for more information about merging chromatin assays.

[![](https://stuartlab.org/signac/articles/integrate_atac_files/figure-html/unnamed-chunk-6-1.png)](https://stuartlab.org/signac/articles/integrate_atac)

## Common peak set

If the peaks were identified independently in each experiment then they will likely not overlap perfectly. We can merge peaks from all the datasets to create a **common peak set**, and quantify this peak set in each experiment prior to merging the objects.

First we'll load the peak coordinates for each experiment and convert them to genomic ranges, the use the [`GenomicRanges::reduce`](https://rdrr.io/pkg/IRanges/man/inter-range-methods.html) function to create a common set of peaks to quantify in each dataset.

```{mermaid}
%%| fig-width: 15 
flowchart LR    
  A(Create a common peak set) --> B(Create fragment objects)     
  A --> C(Quantify peaks in each dataset)
  C --> D(Create the objects)
  D --> E(Merge objects)
  E --> F(Merging without a \ncommon feature set)
```

# scATAC-seq Downstream {.setup style="blue"}

```{mermaid}
%%| fig-width: 15 
flowchart LR    
  A{Integrating with scRNA-seq data} --> B(Gene activity matrix approach - \nRNA imputation)     
  A --> C(Dictionary Learning for cross-modality \nintegration - Bridge integration)
  B --> D[Check Biomarkers]
  C --> D
```

## Option B: Dictionary Learning for cross-modality integration / Bridge integration

[![Broad schematic of the bridge integration workflow. From: Seurat v5, Hao et al, 2023. Nature biotechnology](https://media.springernature.com/full/springer-static/image/art%3A10.1038%2Fs41587-023-01767-y/MediaObjects/41587_2023_1767_Fig1_HTML.png?as=webp){alt="Broad schematic of the bridge integration workflow. From: Seurat v5, Hao et al, 2023. Nature biotechnology"}](https://www.nature.com/articles/s41587-023-01767-y)

### Step 1: Load the bridge, query, and reference datasets (each modality individually)

Input files:

-   **10x multiome dataset:** Consisting of \~12,000 PBMC from a helthy donor. The dataset measures scRNA-seq and scATAC-seq in the **same cell**, and is available for download from 10x Genomics [here](https://www.10xgenomics.com/datasets/pbmc-from-a-healthy-donor-granulocytes-removed-through-cell-sorting-10-k-1-standard-2-0-0).

-   **scATAC-seq Query:** Represents \~10,000 PBMC from a healthy donor, and is available for download [here](https://www.10xgenomics.com/datasets/10k-human-pbmcs-atac-v2-chromium-controller-2-standard).

-   **Reference from [Azimuth](https://satijalab.github.io/azimuth/articles/run_azimuth_tutorial.html):** We load the reference (download [here](https://atlas.fredhutch.org/data/nygc/multimodal/pbmc_multimodal.h5seurat)) from this recent [paper](https://doi.org/10.1016/j.cell.2021.04.048). This reference is stored as an h5Seurat file, a format that enables on-disk storage of multimodal Seurat objects (more details on h5Seurat and `SeuratDisk` can be found [here](https://satijalab.github.io/seurat-disk/index.html)).

::: {.callout-note collapse="true"}
### View data download code

Total 2.7 Gb

``` {.bash code-copy="true" eval="false"}
# 10x multiome dataset 
# Raw data 
wget https://cf.10xgenomics.com/samples/cell-arc/2.0.0/pbmc_granulocyte_sorted_10k/pbmc_granulocyte_sorted_10k_filtered_feature_bc_matrix.h5 
# fragments file 
wget https://cf.10xgenomics.com/samples/cell-arc/2.0.0/pbmc_granulocyte_sorted_10k/pbmc_granulocyte_sorted_10k_atac_fragments.tsv.gz 
# fragments index 
wget https://cf.10xgenomics.com/samples/cell-arc/2.0.0/pbmc_granulocyte_sorted_10k/pbmc_granulocyte_sorted_10k_atac_fragments.tsv.gz.tbi  

# scATAC-seq Query (Total 2.7 Gb) 
# Raw data  
wget https://cf.10xgenomics.com/samples/cell-atac/2.1.0/10k_pbmc_ATACv2_nextgem_Chromium_Controller/10k_pbmc_ATACv2_nextgem_Chromium_Controller_filtered_peak_bc_matrix.h5 
# metadata 
wget https://cf.10xgenomics.com/samples/cell-atac/2.1.0/10k_pbmc_ATACv2_nextgem_Chromium_Controller/10k_pbmc_ATACv2_nextgem_Chromium_Controller_singlecell.csv 
# fragments file 
wget https://cf.10xgenomics.com/samples/cell-atac/2.1.0/10k_pbmc_ATACv2_nextgem_Chromium_Controller/10k_pbmc_ATACv2_nextgem_Chromium_Controller_fragments.tsv.gz 
# fragments index 
wget https://cf.10xgenomics.com/samples/cell-atac/2.1.0/10k_pbmc_ATACv2_nextgem_Chromium_Controller/10k_pbmc_ATACv2_nextgem_Chromium_Controller_fragments.tsv.gz.tbi  

# Azimuth Reference (Total 9 Gb)
wget https://atlas.fredhutch.org/data/nygc/multimodal/pbmc_multimodal.h5seurat
```
:::

Load and setup the 10x multiome object.

```{r load multiome, eval=FALSE}
library(Seurat)
library(Signac)
library(EnsDb.Hsapiens.v86)
library(dplyr)
library(ggplot2)

# the 10x hdf5 file contains both data types.
inputdata.10x <- Read10X_h5("/brahms/hartmana/vignette_data/pbmc_cellranger_arc_2/pbmc_granulocyte_sorted_10k_filtered_feature_bc_matrix.h5")
# extract RNA and ATAC data
rna_counts <- inputdata.10x$`Gene Expression`
atac_counts <- inputdata.10x$Peaks
# Create Seurat object
obj.multi <- CreateSeuratObject(counts = rna_counts)
# Get % of mitochondrial genes
obj.multi[["percent.mt"]] <- PercentageFeatureSet(obj.multi, pattern = "^MT-")

# add the ATAC-seq assay
grange.counts <- StringToGRanges(rownames(atac_counts), sep = c(":", "-"))
grange.use <- seqnames(grange.counts) %in% standardChromosomes(grange.counts)
atac_counts <- atac_counts[as.vector(grange.use), ]
# Get gene annotations
annotations <- GetGRangesFromEnsDb(ensdb = EnsDb.Hsapiens.v86)
# Change style to UCSC
seqlevelsStyle(annotations) <- 'UCSC'
genome(annotations) <- "hg38"
# File with ATAC per fragment information file
frag.file <- "/brahms/hartmana/vignette_data/pbmc_cellranger_arc_2/pbmc_granulocyte_sorted_10k_atac_fragments.tsv.gz"
# Add in ATAC-seq data as ChromatinAssay object
chrom_assay <- CreateChromatinAssay(
  counts = atac_counts,
  sep = c(":", "-"),
  genome = 'hg38',
  fragments = frag.file,
  min.cells = 10,
  annotation = annotations
)

# Add the ATAC assay to the multiome object
obj.multi[["ATAC"]] <- chrom_assay
# Filter ATAC data based on QC metrics
obj.multi <- subset(
  x = obj.multi,
  subset = nCount_ATAC < 7e4 &
    nCount_ATAC > 5e3 &
    nCount_RNA < 25000 &
    nCount_RNA > 1000 &
    percent.mt < 20
)
```

We note that it is important to quantify the same set of genomic features in the query dataset as are quantified in the multi-omic bridge. We therefore requantify the set of scATAC-seq peaks using the `FeatureMatrix` command. This is also described in the [Signac vignettes](https://stuartlab.org/signac/articles/integrate_atac.html) and shown below.

Load and setup the 10x scATAC-seq query.

```{r load query, eval=FALSE}
# Load ATAC dataset
atac_pbmc_data <- Read10X_h5(filename = "data/10k_PBMC_ATAC_nextgem_Chromium_X_filtered_peak_bc_matrix.h5") 
fragpath <- "data/10k_PBMC_ATAC_nextgem_Chromium_X_fragments.tsv.gz"
# Get gene annotations
annotation <- GetGRangesFromEnsDb(ensdb = EnsDb.Hsapiens.v86)
# Change to UCSC style 
seqlevelsStyle(annotation) <- 'UCSC'
# Create ChromatinAssay for ATAC data
atac_pbmc_assay <- CreateChromatinAssay(
  counts = atac_pbmc_data,
  sep = c(":", "-"),
  fragments = fragpath,
  annotation = annotation
)
# Requantify query ATAC to have same features as multiome ATAC dataset
requant_multiome_ATAC <- FeatureMatrix(
  fragments = Fragments(atac_pbmc_assay),
  features = granges(obj.multi[['ATAC']]),
  cells = Cells(atac_pbmc_assay)
)
# Create assay with requantified ATAC data
ATAC_assay <- CreateChromatinAssay(
  counts = requant_multiome_ATAC,
  fragments = fragpath,
  annotation = annotation
)
# Create Seurat sbject
obj.atac  <- CreateSeuratObject(counts = ATAC_assay,assay = 'ATAC')
obj.atac[['peak.orig']] <- atac_pbmc_assay
obj.atac <- subset(obj.atac, subset = nCount_ATAC < 7e4 & nCount_ATAC > 2000)
```

Download Azimuth reference and load it.

```{r load azimuth, eval=FALSE}
obj.rna <- readRDS("data/pbmc_multimodal_2023.rds")
```

### Step 2: Preprocessing/normalization for all datasets

Prior to performing bridge integration, we normalize and pre-process each of the datasets (note that the reference has already been normalized). We normalize gene expression data using [sctransform](https://genomebiology.biomedcentral.com/articles/10.1186/s13059-019-1874-1), and ATAC data using TF-IDF.

```{r, eval=FALSE}
# normalize multiome RNA
DefaultAssay(obj.multi) <- "RNA"
obj.multi <- SCTransform(obj.multi, verbose = FALSE)
# normalize multiome ATAC
DefaultAssay(obj.multi) <- "ATAC"
obj.multi <- RunTFIDF(obj.multi)
obj.multi <- FindTopFeatures(obj.multi, min.cutoff = "q0")
# normalize query
obj.atac <- RunTFIDF(obj.atac)
```

### Step 3: Map scATAC-seq dataset using bridge integration

Now that we have the **reference, query, and bridge datasets set up**, we can begin integration. The bridge dataset enables translation between the scRNA-seq reference and the scATAC-seq query, effectively augmenting the reference so that it can map a new data type. We call this an extended reference, and first set it up. Note that you can save the results of this function and map multiple scATAC-seq datasets without having to rerun.

First, we drop the first dimension of the ATAC reduction.

```{r, eval=FALSE}
dims.atac <- 2:50
dims.rna <- 1:50
DefaultAssay(obj.multi) <-  "RNA"
DefaultAssay(obj.rna) <- "SCT"
obj.rna.ext <- PrepareBridgeReference(
  reference = obj.rna, bridge = obj.multi,
  reference.reduction = "spca", reference.dims = dims.rna,
  normalization.method = "SCT")
```

Now, we can directly find anchors between the extended reference and query objects. We use the `FindBridgeTransferAnchors` function, which translates the query dataset using the same dictionary as was used to translate the reference, and then identifies anchors in this space. The function is meant to mimic our `FindTransferAnchors` function, but to identify correspondences across modalities.

```{r, eval=FALSE}
bridge.anchor <- FindBridgeTransferAnchors(
  extended.reference = obj.rna.ext, query = obj.atac,
  reduction = "lsiproject", dims = dims.atac)
```

Once we have identified anchors, we can map the query dataset onto the reference. The `MapQuery` function is the same as we have [previously introduced for reference mapping](https://satijalab.org/seurat/articles/multimodal_reference_mapping) . It transfers cell annotations from the reference dataset, and also visualizes the query dataset on a previously computed UMAP embedding. Since our reference dataset contains cell type annotations at three levels of resolution (l1 - l3), we can transfer each level to the query dataset.

```{r, eval=FALSE}
obj.atac <- MapQuery(
  anchorset = bridge.anchor, reference = obj.rna.ext,
  query = obj.atac,
  refdata = list(
    l1 = "celltype.l1",
    l2 = "celltype.l2",
    l3 = "celltype.l3"),
  reduction.model = "wnn.umap")
```

Now we can visualize the results, plotting the scATAC-seq cells based on their predicted annotations, on the reference UMAP embedding. You can see that each scATAC-seq cell has been assigned a cell name based on the scRNA-seq defined cell ontology.

```{r load output and plot, eval=F}
# plot
DimPlot(
  obj.atac, group.by = "predicted.l2",
  reduction = "ref.umap", label = TRUE
) + ggtitle("ATAC") + NoLegend()
```

### Step 4: Assessing the mapping

To assess the mapping and cell type predictions, we will first see if the predicted cell type labels are concordant with an unsupervised analysis of the scATAC-seq dataset. We follow the standard unsupervised processing workflow for scATAC-seq data:

```{r, eval=FALSE}
obj.atac <- FindTopFeatures(obj.atac, min.cutoff = "q0")
obj.atac <- RunSVD(obj.atac)
obj.atac <- RunUMAP(obj.atac, reduction = "lsi", dims = 2:50)
```

Now, we visualize the predicted cluster labels on the unsupervised UMAP emebdding. We can see that predicted cluster labels (from the scRNA-seq reference) are concordant with the structure of the scATAC-seq data. However, there are some cell types (i.e. Treg), that do not appear to separate in unsupervised analysis. These may be prediction errors, or cases where the reference mapping provides additional resolution.

```{r, eval=FALSE}
DimPlot(obj.atac, group.by = "predicted.l2", reduction = "umap", label = FALSE)
```

[![](https://satijalab.org/seurat/articles/seurat5_integration_bridge_files/figure-html/pbmcdimplots-1.png)](https://satijalab.org/seurat/articles/seurat5_integration_bridge#azimuth-atac-for-bridge-integration)

Lastly, we validate the predicted cell types for the scATAC-seq data by examining their chromatin accessibility profiles at canonical loci. We use the `CoveragePlot` function to visualize accessibility patterns at the CD8A, FOXP3, and RORC, after grouping cells by their predicted labels. We see expected patterns in each case. For example, the PAX5 locus exhibits peaks that are accessible exclusively in B cells, and the CD8A locus shows the same in CD8 T cell subsets. Similarly, the accessibility of FOXP3, a canonical marker of regulatory T cells (Tregs), in predicted Tregs provides strong support for the accuracy of our prediction.

```{r, eval=FALSE}
CoveragePlot(
  obj.atac, region  = "PAX5", group.by = "predicted.l1",
  idents = c("B", "CD4 T", "Mono", "NK"), window = 200,
  extend.upstream = -150000)
```

[![](https://satijalab.org/seurat/articles/seurat5_integration_bridge_files/figure-html/unnamed-chunk-11-1.png)](https://satijalab.org/seurat/articles/seurat5_integration_bridge#azimuth-atac-for-bridge-integration)

# **Analysis of multi-omics data**

Recently, single cell multi-omics methods that run several assays on the same cells have become available. One such method is [Chromium Single Cell Multiome from 10X genomics](https://www.10xgenomics.com/products/single-cell-multiome-atac-plus-gene-expression), which simultaneously measures gene expression (RNA-seq) and chromatin accessibility (ATAC-seq) in the same nuclei. This makes it possible to i**dentify cell types and states based on both gene expression and accessibility.** It also makes it easy to use external gene expression data to annotate your cells, and at the same time study the chromatin accessibility in the cells.

## Joint RNA and ATAC analysis: 10x multiomic

In this tutorial, we'll demonstrate how to jointly analyze a single-cell dataset measuring both DNA accessibility and gene expression in the same cells using Signac and Seurat. In this vignette we'll be using a publicly available [10x Genomic Multiome dataset for human PBMCs.](https://www.10xgenomics.com/datasets/pbmc-from-a-healthy-donor-granulocytes-removed-through-cell-sorting-10-k-1-standard-1-0-0)

## Dataset overview

Libraries generated:

-   Chromium Single Cell Multiome ATAC library

-   Chromium Single Cell Multiome Gene Expression library

::: {.callout-note collapse="true"}
## View data download code

``` {.bash code-copy="true" eval="false"}
# multiomic data  
wget https://cf.10xgenomics.com/samples/cell-arc/1.0.0/pbmc_granulocyte_sorted_10k/pbmc_granulocyte_sorted_10k_filtered_feature_bc_matrix.h5
# fragments file 
wget https://cf.10xgenomics.com/samples/cell-arc/1.0.0/pbmc_granulocyte_sorted_10k/pbmc_granulocyte_sorted_10k_atac_fragments.tsv.gz
# fragments index 
wget https://cf.10xgenomics.com/samples/cell-arc/1.0.0/pbmc_granulocyte_sorted_10k/pbmc_granulocyte_sorted_10k_atac_fragments.tsv.gz.tbi
```
:::

### 📗 Step 1: Load the data and create the Seurat object

```{r load packages, warning=FALSE, message=FALSE}
library(Signac)
library(Seurat)
library(EnsDb.Hsapiens.v86) # Ensembl based annotation package (hg37)
# BiocManager::install("BSgenome.Hsapiens.UCSC.hg38")
library(BSgenome.Hsapiens.UCSC.hg38) # Full genomic sequences for Homo sapiens (UCSC genome hg38)
```

```{r parallelization}
library(future)
# parallelization options
plan("multicore", workers = 8)
# Increase the maximum memory usage
options(future.globals.maxSize = 14 * 1024^3)  # para 14 GB de RAM
```

Load data and add annotation:

```{r load data, message=FALSE, warning=FALSE}
# load the RNA and ATAC data
counts <- Read10X_h5("data/pbmc_granulocyte_sorted_10k_filtered_feature_bc_matrix.h5")
fragpath <- "data/pbmc_granulocyte_sorted_10k_atac_fragments.tsv.gz"
# get gene annotations for hg38
annotation <- GetGRangesFromEnsDb(ensdb = EnsDb.Hsapiens.v86)
seqlevels(annotation) <- paste0('chr', seqlevels(annotation))

# create a Seurat object containing the RNA adata
pbmc <- CreateSeuratObject(
  counts = counts$`Gene Expression`,
  assay = "RNA"
)

# create ATAC assay and add it to the object
pbmc[["ATAC"]] <- CreateChromatinAssay(
  counts = counts$Peaks,
  sep = c(":", "-"),
  fragments = fragpath,
  annotation = annotation
)
```

View file:

```{r view file}
pbmc
```

### 📕 Step 2: Computing QC metrics

We can compute per-cell quality control metrics using the DNA accessibility data and remove cells that are outliers for these metrics, as well as cells with low or unusually high counts for either the RNA or ATAC assay.

```{r QC metrics}
DefaultAssay(pbmc) <- "ATAC"

pbmc <- NucleosomeSignal(pbmc)
pbmc <- TSSEnrichment(pbmc)
```

The relationship between variables stored in the object metadata can be visualized using the [`DensityScatter()`](https://stuartlab.org/signac/reference/densityscatter) function. This can also be used to quickly find suitable cutoff values for different QC metrics by setting `quantiles=TRUE`:

```{r plot}
DensityScatter(pbmc, x = 'nCount_ATAC', y = 'TSS.enrichment', log_x = TRUE, quantiles = TRUE)
```

We can plot the distribution of each QC metric separately using a violin plot:

```{r remove low quality}
VlnPlot(
  object = pbmc,
  features = c("nCount_RNA", "nCount_ATAC", "TSS.enrichment", "nucleosome_signal"),
  ncol = 4,
  pt.size = 0
)

```

Finally we remove cells that are outliers for these QC metrics. The exact QC thresholds used will need to be adjusted according to your dataset.

```{r filter}
# filter out low quality cells
pbmc <- subset(
  x = pbmc,
  subset = nCount_ATAC < 100000 &
    nCount_RNA < 25000 &
    nCount_ATAC > 1800 &
    nCount_RNA > 1000 &
    nucleosome_signal < 2 &
    TSS.enrichment > 1
)
pbmc
```

### 📘 Step 3: Analysis on the RNA assay

We can normalize the gene expression data using SCTransform, and reduce the dimensionality using PCA.

```{r rna assay}
DefaultAssay(pbmc) <- "RNA"
pbmc <- SCTransform(pbmc)
pbmc <- RunPCA(pbmc)
```

::: callout-caution
If you have this error:

"Error in getGlobalsAndPackages(expr, envir = envir, globals = globals) :

The total size of the 19 globals exported for future expression ('FUN()') is 4.69 GiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are 'FUN' (4.67 GiB of class 'function'), 'umi_bin' (19.28 MiB of class 'numeric') and 'data_step1' (1.27 MiB of class 'list')"\
\
You need to use parallelization in Seurat with future. If you want know more about this read this [issue](https://github.com/satijalab/seurat/issues/1845) and [documentation](https://satijalab.org/seurat/archive/v3.0/future_vignette.html).
:::

### 📙 Step 4: Analysis on the ATAC assay

Here we process the DNA accessibility assay the same way we would process a scATAC-seq dataset, by performing latent semantic indexing (LSI).

```{r atac assay}
# Normalization and linear dimensional reduction (LSI)
DefaultAssay(pbmc) <- "ATAC"
pbmc <- FindTopFeatures(pbmc, min.cutoff = 5)
pbmc <- RunTFIDF(pbmc)
pbmc <- RunSVD(pbmc)
```

### ✒️ Step 5: Annotating cell types

To annotate cell types in the dataset we can transfer cell labels from an existing PBMC reference dataset using tools in the Seurat package. See the Seurat reference mapping [vignette](https://satijalab.org/seurat/v4.0/reference_mapping.html) for more information.

We'll use an annotated PBMC reference dataset from [Hao et al. (2020)](https://www.biorxiv.org/content/10.1101/2020.10.12.335331v1), available for download here: <https://atlas.fredhutch.org/data/nygc/multimodal/pbmc_multimodal.h5seurat>

Note that the SeuratDisk package is required to load the reference dataset. Installation instructions for SeuratDisk can be found [here](https://github.com/mojaveazure/seurat-disk).

::: {.callout-note collapse="true"}
## Install Seurat-disk

SeuratDisk is not currently available on CRAN. You can install it from [GitHub](https://github.com/mojaveazure/seurat-disk) with:

```{r, eval=FALSE}
if (!requireNamespace("remotes", quietly = TRUE)) {
  install.packages("remotes")
}
remotes::install_github("mojaveazure/seurat-disk")
```

If you have problems you can use this way, from this [issue](https://github.com/mojaveazure/seurat-disk/issues/179):

-   Download the package source locally (bash terminal):

``` {.bash code-copy="true" eval="false"}
cd ~/
git clone https://github.com/mojaveazure/seurat-disk
```

-   Install package from source:

```{r, eval=FALSE}
install.packages("~/seurat-disk", repos = NULL, type = "source")
```
:::

```{r annotation cells}
library(SeuratDisk)

# load PBMC reference
reference <- LoadH5Seurat("data/pbmc_multimodal.h5seurat", assays = list("SCT" = "counts"), reductions = 'spca')
reference <- UpdateSeuratObject(reference)

DefaultAssay(pbmc) <- "SCT"

# transfer cell type labels from reference to query
transfer_anchors <- FindTransferAnchors(
  reference = reference,
  query = pbmc,
  normalization.method = "SCT",
  reference.reduction = "spca",
  recompute.residuals = FALSE,
  dims = 1:50
)

predictions <- TransferData(
  anchorset = transfer_anchors, 
  refdata = reference$celltype.l2,
  weight.reduction = pbmc[['pca']],
  dims = 1:50
)

pbmc <- AddMetaData(
  object = pbmc,
  metadata = predictions
)

# set the cell identities to the cell type predictions
Idents(pbmc) <- "predicted.id"

# remove low-quality predictions
pbmc <- pbmc[, pbmc$prediction.score.max > 0.5]
```

### 📐 Step 6: Joint UMAP visualization

Using the weighted nearest neighbor methods in [Seurat v4](https://www.biorxiv.org/content/10.1101/2020.10.12.335331v1), we can compute a joint neighbor graph that represent both the gene expression and DNA accessibility measurements.

```{r umap}
# build a joint neighbor graph using both assays
pbmc <- FindMultiModalNeighbors(
  object = pbmc,
  reduction.list = list("pca", "lsi"), 
  dims.list = list(1:50, 2:40),
  modality.weight.name = "RNA.weight",
  verbose = TRUE
)

# build a joint UMAP visualization
pbmc <- RunUMAP(
  object = pbmc,
  nn.name = "weighted.nn",
  assay = "RNA",
  verbose = TRUE
)

DimPlot(pbmc, label = TRUE, repel = TRUE, reduction = "umap") + NoLegend()
```

### 📊 Step 7: Linking peaks to genes

For each gene, we can find the set of peaks that may regulate the gene by by computing the correlation between gene expression and accessibility at nearby peaks, and correcting for bias due to GC content, overall accessibility, and peak size. See the [Signac paper](https://www.biorxiv.org/content/10.1101/2020.11.09.373613v1) for a full description of the method we use to link peaks to genes.

Running this step on the whole genome can be time consuming, so here we demonstrate peak-gene links for a subset of genes as an example. The same function can be used to find links for all genes by omitting the `genes.use` parameter:

```{r linking peaks to genes}
DefaultAssay(pbmc) <- "ATAC"

# first compute the GC content for each peak
pbmc <- RegionStats(pbmc, genome = BSgenome.Hsapiens.UCSC.hg38)

# link peaks to genes
pbmc <- LinkPeaks(
  object = pbmc,
  peak.assay = "ATAC",
  expression.assay = "SCT",
  genes.use = c("LYZ", "MS4A1")
)
```

We can visualize these links using the [`CoveragePlot()`](https://stuartlab.org/signac/reference/coverageplot) function, or alternatively we could use the [`CoverageBrowser()`](https://stuartlab.org/signac/reference/coveragebrowser) function in an interactive analysis:

```{r}
idents.plot <- c("B naive", "B intermediate", "B memory",
                 "CD14 Mono", "CD16 Mono", "CD8 TEM", "CD8 Naive")

pbmc <- SortIdents(pbmc)

p1 <- CoveragePlot(
  object = pbmc,
  region = "MS4A1",
  features = "MS4A1",
  expression.assay = "SCT",
  idents = idents.plot,
  extend.upstream = 500,
  extend.downstream = 10000
)

p2 <- CoveragePlot(
  object = pbmc,
  region = "LYZ",
  features = "LYZ",
  expression.assay = "SCT",
  idents = idents.plot,
  extend.upstream = 8000,
  extend.downstream = 5000
)

patchwork::wrap_plots(p1, p2, ncol = 1)
```

```{r information}
sessionInfo()
```

## References

-   Signac tutorial - [Merging objects](https://stuartlab.org/signac/articles/merging#creating-a-common-peak-set)
-   [harmony batch effect](https://rpubs.com/eraz0001/Harmony)
-   10x tutorial - [Batch Effect Correction in Chromium Single Cell ATAC Data](https://www.10xgenomics.com/analysis-guides/batch-effect-correction-in-chromium-single-cell-atac-data)
-   Signac tutorial - [scATAC-seq data integration](https://stuartlab.org/signac/articles/integrate_atac)
-   Signac tutorial - [Integrating scRNA-seq and scATAC-seq data](https://satijalab.org/seurat/articles/seurat5_atacseq_integration_vignette)
-   Seurat tutorial - [Dictionary Learning for cross-modality integration](https://satijalab.org/seurat/articles/seurat5_integration_bridge#azimuth-atac-for-bridge-integration)
-   [Azimuth annotation](https://satijalab.github.io/azimuth/articles/run_azimuth_tutorial.html)
-   Epigenomics workshop 2024 - [Integrating scATAC-seq and scRNA-seq data](https://nbis-workshop-epigenomics.readthedocs.io/en/latest/content/tutorials/scAtacSeq/lab-sc_atac_seq.html)
-   Signac tutorial - [Joint RNA and ATAC analysis: 10x multiomic](https://stuartlab.org/signac/articles/pbmc_multiomic)
