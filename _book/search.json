[
  {
    "objectID": "Section2_P14_intro.html",
    "href": "Section2_P14_intro.html",
    "title": "4  Practical 14: scATAC-seq Downstream",
    "section": "",
    "text": "5 Calling peaks\nYou can call peaks on a single-cell ATAC-seq dataset using MACS2. To use this functionality in Signac, make sure MACS2 is installed—either through pip or conda, or by building it from source.\nFor example, with scATAC-seq data from human PBMCs (as shown in our tutorial or from Signac vignette), you can load the necessary packages and a pre-computed Seurat object. See the vignette for the code used to generate this object and links to the raw data.\nCode\nsessionInfo()\n\n\nR version 4.4.1 (2024-06-14 ucrt)\nPlatform: x86_64-w64-mingw32/x64\nRunning under: Windows 11 x64 (build 22631)\n\nMatrix products: default\n\n\nlocale:\n[1] LC_COLLATE=English_United States.utf8 \n[2] LC_CTYPE=English_United States.utf8   \n[3] LC_MONETARY=English_United States.utf8\n[4] LC_NUMERIC=C                          \n[5] LC_TIME=English_United States.utf8    \n\ntime zone: America/Mexico_City\ntzcode source: internal\n\nattached base packages:\n[1] stats4    stats     graphics  grDevices utils     datasets  methods  \n[8] base     \n\nother attached packages:\n [1] enrichplot_1.24.4         org.Hs.eg.db_3.19.1      \n [3] clusterProfiler_4.12.6    presto_1.0.0             \n [5] data.table_1.16.0         Rcpp_1.0.13              \n [7] future_1.34.0             EnsDb.Hsapiens.v86_2.99.0\n [9] ensembldb_2.28.1          AnnotationFilter_1.28.0  \n[11] GenomicFeatures_1.56.0    AnnotationDbi_1.66.0     \n[13] Biobase_2.64.0            patchwork_1.2.0          \n[15] ggplot2_3.5.1             GenomicRanges_1.56.1     \n[17] GenomeInfoDb_1.40.1       IRanges_2.38.1           \n[19] S4Vectors_0.42.1          BiocGenerics_0.50.0      \n[21] Seurat_5.1.0              SeuratObject_5.0.2       \n[23] sp_2.1-4                  Signac_1.14.0            \n\nloaded via a namespace (and not attached):\n  [1] fs_1.6.4                    ProtGenerics_1.36.0        \n  [3] matrixStats_1.4.0           spatstat.sparse_3.1-0      \n  [5] bitops_1.0-8                httr_1.4.7                 \n  [7] RColorBrewer_1.1-3          tools_4.4.1                \n  [9] sctransform_0.4.1           utf8_1.2.4                 \n [11] R6_2.5.1                    lazyeval_0.2.2             \n [13] uwot_0.2.2                  withr_3.0.1                \n [15] gridExtra_2.3               progressr_0.14.0           \n [17] cli_3.6.2                   spatstat.explore_3.3-2     \n [19] fastDummies_1.7.4           scatterpie_0.2.4           \n [21] labeling_0.4.3              spatstat.data_3.1-2        \n [23] ggridges_0.5.6              pbapply_1.7-2              \n [25] Rsamtools_2.20.0            yulab.utils_0.1.7          \n [27] gson_0.1.0                  DOSE_3.30.5                \n [29] R.utils_2.12.3              parallelly_1.38.0          \n [31] limma_3.60.4                rstudioapi_0.16.0          \n [33] RSQLite_2.3.7               gridGraphics_0.5-1         \n [35] generics_0.1.3              BiocIO_1.14.0              \n [37] ica_1.0-3                   spatstat.random_3.3-1      \n [39] dplyr_1.1.4                 GO.db_3.19.1               \n [41] Matrix_1.7-0                ggbeeswarm_0.7.2           \n [43] fansi_1.0.6                 abind_1.4-5                \n [45] R.methodsS3_1.8.2           lifecycle_1.0.4            \n [47] yaml_2.3.10                 SummarizedExperiment_1.34.0\n [49] qvalue_2.36.0               SparseArray_1.4.8          \n [51] Rtsne_0.17                  grid_4.4.1                 \n [53] blob_1.2.4                  promises_1.3.0             \n [55] crayon_1.5.3                miniUI_0.1.1.1             \n [57] lattice_0.22-6              cowplot_1.1.3              \n [59] KEGGREST_1.44.1             pillar_1.9.0               \n [61] knitr_1.48                  fgsea_1.30.0               \n [63] rjson_0.2.22                future.apply_1.11.2        \n [65] codetools_0.2-20            fastmatch_1.1-4            \n [67] leiden_0.4.3.1              glue_1.7.0                 \n [69] ggfun_0.1.6                 spatstat.univar_3.0-1      \n [71] treeio_1.28.0               vctrs_0.6.5                \n [73] png_0.1-8                   spam_2.10-0                \n [75] gtable_0.3.5                cachem_1.1.0               \n [77] xfun_0.45                   S4Arrays_1.4.1             \n [79] mime_0.12                   tidygraph_1.3.1            \n [81] survival_3.6-4              RcppRoll_0.3.1             \n [83] statmod_1.5.0               fitdistrplus_1.2-1         \n [85] ROCR_1.0-11                 nlme_3.1-164               \n [87] ggtree_3.12.0               bit64_4.0.5                \n [89] RcppAnnoy_0.0.22            irlba_2.3.5.1              \n [91] vipor_0.4.7                 KernSmooth_2.23-24         \n [93] colorspace_2.1-1            DBI_1.2.3                  \n [95] ggrastr_1.0.2               tidyselect_1.2.1           \n [97] bit_4.0.5                   compiler_4.4.1             \n [99] curl_5.2.2                  httr2_1.0.3                \n[101] DelayedArray_0.30.1         plotly_4.10.4              \n[103] shadowtext_0.1.4            rtracklayer_1.64.0         \n[105] scales_1.3.0                lmtest_0.9-40              \n[107] rappdirs_0.3.3              stringr_1.5.1              \n[109] digest_0.6.36               goftest_1.2-3              \n[111] spatstat.utils_3.1-0        rmarkdown_2.28             \n[113] XVector_0.44.0              htmltools_0.5.8.1          \n[115] pkgconfig_2.0.3             MatrixGenerics_1.16.0      \n[117] fastmap_1.2.0               rlang_1.1.3                \n[119] htmlwidgets_1.6.4           UCSC.utils_1.0.0           \n[121] shiny_1.9.1                 farver_2.1.2               \n[123] zoo_1.8-12                  jsonlite_1.8.8             \n[125] BiocParallel_1.38.0         GOSemSim_2.30.2            \n[127] R.oo_1.26.0                 RCurl_1.98-1.16            \n[129] magrittr_2.0.3              ggplotify_0.1.2            \n[131] GenomeInfoDbData_1.2.12     dotCall64_1.1-1            \n[133] munsell_0.5.1               ape_5.8                    \n[135] viridis_0.6.5               reticulate_1.39.0          \n[137] stringi_1.8.4               ggraph_2.2.1               \n[139] zlibbioc_1.50.0             MASS_7.3-60.2              \n[141] plyr_1.8.9                  parallel_4.4.1             \n[143] listenv_0.9.1               ggrepel_0.9.5              \n[145] deldir_2.0-4                Biostrings_2.72.1          \n[147] graphlayouts_1.1.1          splines_4.4.1              \n[149] tensor_1.5                  igraph_2.0.3               \n[151] spatstat.geom_3.3-2         RcppHNSW_0.6.0             \n[153] reshape2_1.4.4              XML_3.99-0.17              \n[155] evaluate_0.24.0             tweenr_2.0.3               \n[157] httpuv_1.6.15               RANN_2.6.2                 \n[159] tidyr_1.3.1                 purrr_1.0.2                \n[161] polyclip_1.10-7             scattermore_1.2            \n[163] ggforce_0.4.2               xtable_1.8-4               \n[165] restfulr_0.0.15             tidytree_0.4.6             \n[167] RSpectra_0.16-2             later_1.3.2                \n[169] viridisLite_0.4.2           tibble_3.2.1               \n[171] aplot_0.2.3                 memoise_2.0.1              \n[173] beeswarm_0.4.0              GenomicAlignments_1.40.0   \n[175] cluster_2.1.6               globals_0.16.3"
  },
  {
    "objectID": "Section2_P14_intro.html#option-a-gene-activity-matrix-approach",
    "href": "Section2_P14_intro.html#option-a-gene-activity-matrix-approach",
    "title": "4  Practical 14: scATAC-seq Downstream",
    "section": "4.1 Option A: Gene activity matrix approach",
    "text": "4.1 Option A: Gene activity matrix approach\n\n\n\n\n\nGene activity scores capture how much open chromatin there is in the promoter regions of each gene (by default 2000 bp (2 kb) upstream). The assumption here is that open chromatin is a proxy for gene expression. Gene activity scores are represented as a matrix, with one row per gene and one column per cell. This makes the gene activitiy scores directly compatible with single cell RNA-seq data.\n\n\n\n\n\n\nNote\n\n\n\nCalculating the gene activity scores takes around 10 minutes for 2000 cells and all genes.\n\n\nWe can try to quantify the activity of each gene in the genome by assessing the chromatin accessibility associated with the gene, and create a new gene activity assay derived from the scATAC-seq data. Here we will use a simple approach of summing the fragments intersecting the gene body and promoter region (we also recommend exploring the Cicero tool, which can accomplish a similar goal, and we provide a vignette showing how to run Cicero within a Signac workflow here).\n\n4.1.1 Step 1: Load data\nWe then count the number of fragments for each cell that map to each of these regions, using the using the FeatureMatrix() function. These steps are automatically performed by the GeneActivity() function:\n\n\n4.1.2 Step 2: Create a expression matrix\n\n\nCode\nstart &lt;- Sys.time()\ngene.activities &lt;- GeneActivity(pbmc)\n\n\nExtracting gene coordinates\n\n\nExtracting reads overlapping genomic regions\n\n\nCode\nend &lt;- Sys.time()\nend - start\n\n\nTime difference of 14.6519 mins\n\n\nAdd the gene activity matrix to the Seurat object as a new assay and normalize it.\n\n\nCode\npbmc[['RNA']] &lt;- CreateAssayObject(counts = gene.activities)\n# normalization\npbmc &lt;- NormalizeData(\n  object = pbmc,\n  assay = 'RNA',\n  normalization.method = 'LogNormalize',\n  scale.factor = median(pbmc$nCount_RNA)\n)\n\n\n\n\n4.1.3 Step 3: Check biomarkers\nWe are now able to visualize the activity of canonical biomarkers to guide our interpretation of scATAC-seq clusters. Although this new putative “scRNA-seq” experiment derived from scATAC-seq will be noisier than a canonical scRNA-seq experiment, it will still be useful. The noise arises from the assumption made when generating the gene activity matrix, which assumes a perfect correlation between promoter/ORF accessibility and gene expression—something that is not always the case.\n\n\nCode\nDefaultAssay(pbmc) &lt;- 'RNA'\n\nFeaturePlot(\n  object = pbmc,\n  features = c('MS4A1', 'CD3D', 'LEF1', 'NKG7', 'TREM1', 'LYZ'),\n  pt.size = 0.1,\n  max.cutoff = 'q95',\n  ncol = 3\n)"
  },
  {
    "objectID": "Section2_P14_intro.html#signac-workflow",
    "href": "Section2_P14_intro.html#signac-workflow",
    "title": "4  Practical 14: scATAC-seq Downstream",
    "section": "4.2 Signac Workflow",
    "text": "4.2 Signac Workflow\n\n\n\nFigure 4.1: Single-cell chromatin analysis workflow with Signac."
  },
  {
    "objectID": "Section2_P14_intro.html#label-transfer",
    "href": "Section2_P14_intro.html#label-transfer",
    "title": "4  Practical 14: scATAC-seq Downstream",
    "section": "4.3 Label transfer",
    "text": "4.3 Label transfer\nAfter calculating the gene activity scores, we can now integrate the ATAC-seq data with the RNA-seq data.\nThe process begins by identifying anchors, which are pairs of cells—one from ATAC-seq and one from RNA-seq. To achieve this, we project both datasets into a shared space and identify pairs of cells that are mutual nearest neighbors (MNNs), one from each dataset. These pairs are then filtered to retain the most reliable ones, which serve as the anchors.\nThese anchors allow us to project the ATAC-seq data onto the RNA-seq data, enabling the identification of cell type annotations for nearby cells. In this way, annotations from the RNA-seq data can be transferred to the ATAC-seq data, a method commonly known as label transfer.\n\n4.3.1 Step 4: Integrating with scRNA-seq data (multimodal)\nTo help interpret the scATAC-seq data, we can classify cells based on an scRNA-seq experiment from the same biological system (human PBMC). We utilize methods for cross-modality integration and label transfer, described here, with a more in-depth tutorial here. We aim to identify shared correlation patterns in the gene activity matrix and scRNA-seq dataset to identify matched biological states across the two modalities. This procedure returns a classification score for each cell for each scRNA-seq-defined cluster label.\n\n\n\nFigure 4.2: Schematic Overview of Reference “Assembly” Integration in Seurat v3. From: Stuart, et al. 2019. Cell.\n\n\nHere we load a pre-processed scRNA-seq dataset for human PBMCs, also provided by 10x Genomics. You can download the raw data for this experiment from the 10x website, and view the code used to construct this object on GitHub. Alternatively, you can download the pre-processed Seurat object here.\n\n\nCode\n# Load the pre-processed scRNA-seq data for PBMCs\npbmc_rna &lt;- readRDS(\"data/pbmc_10k_v3.rds\")\npbmc_rna &lt;- UpdateSeuratObject(pbmc_rna)\n# free memory\ngc()\n\n\n            used   (Mb) gc trigger    (Mb)   max used    (Mb)\nNcells  12415529  663.1   33977562  1814.6   53089940  2835.4\nVcells 781620146 5963.3 1375166230 10491.7 1363482854 10402.6\n\n\n\n\n4.3.2 Step 5: Find transfer anchors\nFind a set of anchors between a reference and query object. These anchors can later be used to transfer data from the reference to query object using the TransferData object.\n\n\nCode\ntransfer.anchors &lt;- FindTransferAnchors(\n  reference = pbmc_rna, # scRNA\n  query = pbmc, # scATAC\n  reduction = 'cca' # Perform dimensional reduction\n)\n\n\nWarning in size + sum(size_args, na.rm = FALSE): NAs produced by integer\noverflow\nWarning in size + sum(size_args, na.rm = FALSE): NAs produced by integer\noverflow\n\n\nRunning CCA\n\n\nMerging objects\n\n\nFinding neighborhoods\n\n\nFinding anchors\n\n\n    Found 19133 anchors\n\n\n\n\n4.3.3 Step 7: Annotate scATAC-seq cells via label transfer\nAfter identifying anchors, we can transfer annotations from the scRNA-seq dataset into the scATAC-seq cells. The annotations are stored in the seurat_annotations field, and are provided as input to the refdata parameter. The output will contain a matrix with predictions and confidence scores for each ATAC-seq cell.\n\n\nCode\npredicted.labels &lt;- TransferData(\n  anchorset = transfer.anchors,\n  refdata = pbmc_rna$celltype,\n  weight.reduction = pbmc[['lsi']], # reduction of the original `seurat` object's dim\n  dims = 2:30\n)\n\n\nFinding integration vectors\n\n\nFinding integration vector weights\n\n\nPredicting cell labels\n\n\nCode\npbmc &lt;- AddMetaData(object = pbmc, metadata = predicted.labels)\ngc()# free memory\n\n\n            used   (Mb) gc trigger    (Mb)   max used    (Mb)\nNcells  12476478  666.4   33977562  1814.6   53089940  2835.4\nVcells 784155391 5982.7 1375166230 10491.7 1372621778 10472.3\n\n\nCheck plot\n\n\nCode\nplot1 &lt;- DimPlot(\n  object = pbmc_rna,\n  group.by = 'celltype',\n  label = TRUE,\n  repel = TRUE) + NoLegend() + ggtitle('scRNA-seq')\n\nplot2 &lt;- DimPlot(\n  object = pbmc,\n  group.by = 'predicted.id',\n  label = TRUE,\n  repel = TRUE) + NoLegend() + ggtitle('scATAC-seq (prediction)')\n\nplot1 | plot2 \n\n\n\n\n\n\n\n4.3.4 Step 8: Remove platelets\nThe scRNA-based classifications match the UMAP visualization from the scATAC-seq data. However, a small group of cells is unexpectedly predicted to be platelets, which lack nuclei and shouldn’t be detected by scATAC-seq. These cells might actually be megakaryocytes, platelet precursors usually found in the bone marrow but rarely in peripheral blood. Given the extreme rarity of megakaryocytes in normal bone marrow (&lt;0.1%), this seems unlikely.\n\n\nCode\nVlnPlot(pbmc, 'prediction.score.max', group.by = 'predicted.id')\n\n\n\n\n\nPlotting the prediction score for the cells assigned to each label reveals that the “platelet” cells received relatively low scores (&lt; 0.8), indicating a low confidence in the assigned cell identity. In most cases, the next most likely cell identity predicted for these cells was “CD4 naive”.\n\n\nCode\n# Identify the metadata columns that start with \"prediction.score.\"\nmetadata_attributes &lt;- colnames(pbmc[[]])\nprediction_score_attributes &lt;- grep(\"^prediction.score.\", metadata_attributes, value = TRUE)\nprediction_score_attributes &lt;- setdiff(prediction_score_attributes, \"prediction.score.max\")\n\n# Extract the prediction score attributes for these cells\npredicted_platelets &lt;- which(pbmc$predicted.id == \"Platelet\")\nplatelet_scores &lt;- pbmc[[]][predicted_platelets, prediction_score_attributes]\n\n# Order the columns by their average values in descending order\nordered_columns &lt;- names(sort(colMeans(platelet_scores, na.rm = TRUE), decreasing = TRUE))\nordered_platelet_scores_df &lt;- platelet_scores[, ordered_columns]\n\nhead(ordered_platelet_scores_df)[3]\n\n\n                   prediction.score.CD4.Memory\nACAAAGAAGACACGGT-1                 0.025746481\nCACTAAGGTAATGTAG-1                 0.008556831\nCTCAACCAGCGAGCTA-1                 0.024011379\nGAATCTGCATAGTCCA-1                 0.016515476\nGCTTAAGCAAAGGTCG-1                 0.020222801\nGTCACCTGTCAGGCTC-1                 0.025835081\n\n\nAs there are only a very small number of cells classified as “platelets” (&lt; 20), it is difficult to figure out their precise cellular identity. Larger datasets would be required to confidently identify specific peaks for this population of cells, and further analysis performed to correctly annotate them. For downstream analysis we will thus remove the extremely rare cell states that were predicted, retaining only cell annotations with &gt;20 cells total.\n\n\nCode\npredicted_id_counts &lt;- table(pbmc$predicted.id)\n\n# Identify the predicted.id values that have more than 20 cells\nmajor_predicted_ids &lt;- names(predicted_id_counts[predicted_id_counts &gt; 20])\npbmc &lt;- pbmc[, pbmc$predicted.id %in% major_predicted_ids]\n\n\nFor downstream analyses, we can simply reassign the identities of each cell from their UMAP cluster index to the per-cell predicted labels. It is also possible to consider merging the cluster indexes and predicted labels.\n\n\nCode\n# change cell identities to the per-cell predicted labels\nIdents(pbmc) &lt;- pbmc$predicted.id\n\n\n\n\n4.3.5 Step 9: Rename labels\nReplace each cluster label with its most likely predicted label\n\n\nCode\nfor(i in levels(pbmc)) {\n  cells_to_reid &lt;- WhichCells(pbmc, idents = i)\n  newid &lt;- names(which.max(table(pbmc$predicted.id[cells_to_reid])))\n  Idents(pbmc, cells = cells_to_reid) &lt;- newid\n}\n\n\n\n\n4.3.6 Step 10: Compare the results\n\n\nCode\n# scRNA-seq\nplot1 &lt;- DimPlot(pbmc_rna, group.by = \"celltype\", label = TRUE) + NoLegend() + ggtitle(\"scRNA-seq\")\n# Gene matrix\nplot2 &lt;- DimPlot(pbmc, group.by = \"predicted.id\", label = TRUE) + NoLegend() + ggtitle(\"scATAC-seq (prediction)\")\n# Integration\nplot3 &lt;- DimPlot(pbmc, label = T, group.by = \"ident\") + NoLegend() + ggtitle(\"scATAC-seq (integration)\")\nplot1 + plot2 + plot3\n\n\n\n\n\n\n\n            used   (Mb) gc trigger    (Mb)   max used    (Mb)\nNcells  12533005  669.4   33977562  1814.6   53089940  2835.4\nVcells 910220618 6944.5 1656845020 12640.8 1425455803 10875.4"
  },
  {
    "objectID": "Section2_P14_intro.html#find-differentially-accessible-peaks-between-cell-types",
    "href": "Section2_P14_intro.html#find-differentially-accessible-peaks-between-cell-types",
    "title": "4  Practical 14: scATAC-seq Downstream",
    "section": "4.4 Find differentially accessible peaks between cell types",
    "text": "4.4 Find differentially accessible peaks between cell types\nIn transcriptomic studies, we analyze differentially transcribed genes, so it is logical to study in ATAC-seq the genomic regions that are differentially accessible to the Tn5 transposase. To investigate differential chromatin accessibility, logistic regressions are used, as recommended by Ntranos et al. 2018, and the total number of reads is included as a latent variable to mitigate the negative impact on results when dealing with libraries/samples with different sequencing depths.\nA simple approach is to perform a Wilcoxon rank sum test, and the presto package has implemented an extremely fast Wilcoxon test that can be run on a Seurat object.\n\n\nCode\nif (!requireNamespace(\"remotes\", quietly = TRUE))\n  install.packages('remotes')\nremotes::install_github('immunogenomics/presto')\n\n\nFor sparse data like scATAC-seq, it is necessary to adjust the min.pct parameter of the FindMarkers() function to lower values, as the default value (0.1) is designed for scRNA-seq data. Here we will focus on comparing Naive CD4 cells and CD14 monocytes, but any groups of cells can be compared using these methods. We can also visualize these marker peaks on a violin plot, feature plot, dot plot, heat map, or any visualization tool in Seurat.\n\n\nCode\nlibrary(presto)\nload(\"data/pbmc.RData\")\n\n# change back to working with peaks instead of gene activities\nDefaultAssay(pbmc) &lt;- 'peaks'\n\n# wilcox is the default option for test.use\nda_peaks &lt;- FindMarkers(\n  object = pbmc,\n  ident.1 = \"CD4 Naive\",\n  ident.2 = \"CD14+ Monocytes\",\n  test.use = 'wilcox',\n  min.pct = 0.1\n)\n\nhead(da_peaks)\n\n\n                          p_val avg_log2FC pct.1 pct.2 p_val_adj\nchr6-13302533-13303459        0  -5.308082 0.025 0.771         0\nchr19-54207815-54208728       0  -4.370882 0.050 0.794         0\nchr17-78198651-78199583       0  -5.653591 0.023 0.760         0\nchr12-119988511-119989430     0   4.163235 0.782 0.090         0\nchr7-142808530-142809435      0   3.665895 0.759 0.088         0\nchr17-82126458-82127377       0   5.017039 0.699 0.042         0\n\n\nWe visualize the results of the differential accessibility test using a violin plot and over the UMAP projection.\n\n\nCode\nplot1 &lt;- VlnPlot(\n  object = pbmc,\n  features = rownames(da_peaks)[1],\n  pt.size = 0.1,\n  idents = c(\"CD4 Naive\",\"CD14+ Monocytes\")\n)\nplot2 &lt;- FeaturePlot(\n  object = pbmc,\n  features = rownames(da_peaks)[1],\n  pt.size = 0.1\n)\n\nplot1 | plot2\n\n\n\n\n\nPeak coordinates can be difficult to interpret alone. We can find the closest gene to each of these peaks using the ClosestFeature() function.\n\n\nCode\nopen_cd4naive &lt;- rownames(da_peaks[da_peaks$avg_log2FC &gt; 3, ])\nopen_cd14mono &lt;- rownames(da_peaks[da_peaks$avg_log2FC &lt; -3, ])\n\nclosest_genes_cd4naive &lt;- ClosestFeature(pbmc, regions = open_cd4naive)\nclosest_genes_cd14mono &lt;- ClosestFeature(pbmc, regions = open_cd14mono)\n# results\nhead(closest_genes_cd4naive)\n\n\n                          tx_id    gene_name         gene_id   gene_biotype\nENSE00002206071 ENST00000397558       BICDL1 ENSG00000135127 protein_coding\nENST00000632998 ENST00000632998        PRSS2 ENSG00000275896 protein_coding\nENST00000583593 ENST00000583593       CCDC57 ENSG00000176155 protein_coding\nENST00000393054 ENST00000393054     ATP6V0A4 ENSG00000105929 protein_coding\nENST00000545320 ENST00000545320          CD6 ENSG00000013725 protein_coding\nENST00000509332 ENST00000509332 RP11-18H21.1 ENSG00000245954        lincRNA\n                type            closest_region              query_region\nENSE00002206071 exon chr12-119989869-119990297 chr12-119988511-119989430\nENST00000632998  utr  chr7-142774509-142774564  chr7-142808530-142809435\nENST00000583593  gap   chr17-82108955-82127691   chr17-82126458-82127377\nENST00000393054  cds  chr7-138752625-138752837  chr7-138752283-138753197\nENST00000545320  gap   chr11-60971915-60987907   chr11-60985909-60986801\nENST00000509332  gap  chr4-152100818-152101483  chr4-152100248-152101142\n                distance\nENSE00002206071      438\nENST00000632998    33965\nENST00000583593        0\nENST00000393054        0\nENST00000545320        0\nENST00000509332        0\n\n\nCode\nhead(closest_genes_cd14mono)\n\n\n                          tx_id     gene_name         gene_id   gene_biotype\nENST00000606214 ENST00000606214        TBC1D7 ENSG00000145979 protein_coding\nENST00000448962 ENST00000448962          RPS9 ENSG00000170889 protein_coding\nENST00000592988 ENST00000592988         AFMID ENSG00000183077 protein_coding\nENSE00001638912 ENST00000455005 RP5-1120P11.3 ENSG00000231881        lincRNA\nENST00000635379 ENST00000635379     LINC01588 ENSG00000214900        lincRNA\nENSE00001389095 ENST00000340607         PTGES ENSG00000148344 protein_coding\n                type           closest_region             query_region distance\nENST00000606214  gap   chr6-13267836-13305061   chr6-13302533-13303459        0\nENST00000448962  gap  chr19-54201610-54231740  chr19-54207815-54208728        0\nENST00000592988  gap  chr17-78191061-78202498  chr17-78198651-78199583        0\nENSE00001638912 exon   chr6-44073913-44074798   chr6-44058439-44059230    14682\nENST00000635379  gap  chr14-50039258-50039391  chr14-50038381-50039286        0\nENSE00001389095 exon chr9-129752887-129753047 chr9-129776928-129777838    23880"
  },
  {
    "objectID": "Section2_P14_intro.html#plotting-genomic-regions",
    "href": "Section2_P14_intro.html#plotting-genomic-regions",
    "title": "4  Practical 14: scATAC-seq Downstream",
    "section": "4.6 Plotting genomic regions",
    "text": "4.6 Plotting genomic regions\nWe can visualize the frequency of Tn5 integration across genomic regions for cells grouped by cluster, cell type, or any other metadata stored in the object using the CoveragePlot() function. These plots represent pseudo-bulk accessibility tracks, where the signal from all cells within a group is averaged to display DNA accessibility in a specific region. (Credit to Andrew Hill for the inspiration behind this function, as highlighted in his excellent blog post.) In addition to accessibility tracks, we can include other key information such as gene annotations, peak coordinates, and genomic links (if available in the object). For further details, refer to the visualization vignette.\nFor plotting purposes, it's nice to have related cell types grouped together. We can automatically sort the plotting order according to similarities across the annotated cell types by running the SortIdents() function:\n\n\nCode\npbmc &lt;- SortIdents(pbmc)\n\n\nCreating pseudobulk profiles for 13 variables across 165376 features\n\n\nComputing euclidean distance between pseudobulk profiles\n\n\nClustering distance matrix\n\n\nWe can then visualize the DA peaks open in CD4 naive cells and CD14 monocytes, near some key marker genes for these cell types, CD4 and LYZ respectively. Here we'll highlight the DA peaks regions in grey.\n\n\nCode\n# find DA peaks overlapping gene of interest\nregions_highlight &lt;- subsetByOverlaps(StringToGRanges(open_cd4naive), LookupGeneCoords(pbmc, \"CD4\"))\n\nCoveragePlot(\n  object = pbmc,\n  region = \"CD4\",\n  region.highlight = regions_highlight,\n  extend.upstream = 1000,\n  extend.downstream = 1000\n)\n\n\nWarning: Removed 22 rows containing missing values or values outside the scale range\n(`geom_segment()`).\n\n\nWarning: Removed 3 rows containing missing values or values outside the scale range\n(`geom_segment()`).\n\n\nWarning: Removed 1 row containing missing values or values outside the scale range\n(`geom_segment()`)."
  },
  {
    "objectID": "Section2_P14_intro.html#references",
    "href": "Section2_P14_intro.html#references",
    "title": "4  Practical 14: scATAC-seq Downstream",
    "section": "5.1 References",
    "text": "5.1 References\nhttps://www.cell.com/cell/fulltext/S0092-8674(19)30559-8?_returnURL=https%3A%2F%2Flinkinghub.elsevier.com%2Fretrieve%2Fpii%2FS0092867419305598%3Fshowall%3Dtrue\nSingle-cell ATAC sequencing https://www.sc-best-practices.org/chromatin_accessibility/introduction.html\nBest practices for single-cell analysis across modalities https://www.nature.com/articles/s41576-023-00586-w\nhttps://stuartlab.org/signac/articles/pbmc_vignette#create-a-gene-activity-matrix\nhttps://stuartlab.org/signac/articles/integrate_atac\nhttps://satijalab.org/seurat/articles/seurat5_atacseq_integration_vignette\nhttps://stuartlab.org/signac/articles/pbmc_vignette\nhttps://rpubs.com/gloknar/809238\nhttps://stuartlab.org/signac/articles/peak_calling"
  },
  {
    "objectID": "Section1_P13_retos.html",
    "href": "Section1_P13_retos.html",
    "title": "3  Exercises",
    "section": "",
    "text": "4 Complete results\nwhat happen if we use all data?"
  },
  {
    "objectID": "Section1_P13_retos.html#dataset-overview-10k-peripheral-blood-mononuclear-cells-pbmcs-from-a-healthy-donor",
    "href": "Section1_P13_retos.html#dataset-overview-10k-peripheral-blood-mononuclear-cells-pbmcs-from-a-healthy-donor",
    "title": "3  Exercises",
    "section": "3.1 Dataset overview: 10k Peripheral Blood Mononuclear Cells (PBMCs) from a Healthy Donor",
    "text": "3.1 Dataset overview: 10k Peripheral Blood Mononuclear Cells (PBMCs) from a Healthy Donor\nFor this tutorial, we will be analyzing a single-cell ATAC-seq dataset of human peripheral blood mononuclear cells (PBMCs) provided by 10x Genomics. The following files are used in this course, all available through the 10x Genomics website:\n\nThe Raw data: Filtered peak barcode matrix.\nThe Metadata: Per-barcode fragment counts & metrics.\nThe fragments file: Barcoded and aligned fragment file.\nThe fragments file index: Fragments file index.\n\n\n\n\n\n\n\nQuestions\n\n\n\nCheck the data report and answer the questions.\n\nHow many cells were recovered?\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\n8728 nuclei were recovered.\n\n\n\n\nWhich version of Cell Ranger ATAC is used?\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nSingle Cell ATAC dataset analyzed using Cell Ranger ATAC 1.0.1\n\n\n\n\nWhat version of the genome did they use?\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nhg19\n\n\n\n\n\n\n\n\nPre-processing workflow\n\n\n\n\nflowchart LR    \n  A(Import Data) --&gt; B(Annotation)     \n  B --&gt; C(Computing QC metrics)     \n  C --&gt; D(Normalization and linear \\ndimensional reduction)      \n  D --&gt; E(Non-linear dimensional \\nreduction and clustering) \n\n\n\n\n\n\n\n\n\n\n\nExercise in Google Colab\n\n\n\n\nCreate a copy of the Google colab notebook part 1 on your one drive.\nRun the exercise."
  },
  {
    "objectID": "Section1_P13_retos.html#step-1-import-data",
    "href": "Section1_P13_retos.html#step-1-import-data",
    "title": "3  Exercises",
    "section": "4.1 📗 Step 1: Import Data",
    "text": "4.1 📗 Step 1: Import Data\n\n\nCode\nlibrary(Signac)\nlibrary(Seurat) \nlibrary(GenomicRanges) # genomic data manipulation\nlibrary(ggplot2) #vizualization\nlibrary(patchwork) # Vizualization \nlibrary(EnsDb.Hsapiens.v75) # human genome hg19\nlibrary(future) # parallelization in Signac\n\n\nSettings on my computer:\n\n\nCode\n# Obtain versions\ncat(\"R version:\", R.version$version.string, \"\\n\")\n\n\nR version: R version 4.4.1 (2024-06-14 ucrt) \n\n\nCode\ncat(\"Number of cores:\", availableCores(), \"\\n\")\n\n\nNumber of cores: 8 \n\n\nCode\npackageVersion(\"Signac\")\n\n\n[1] '1.14.0'\n\n\nCode\n# parallelization options\nplan(\"multicore\", workers = 8)\nplan()\n\n\nmulticore:\n- args: function (..., workers = 8, envir = parent.frame())\n- tweaked: TRUE\n- call: plan(\"multicore\", workers = 8)\n\n\nCode\n# Increase the maximum memory usage\noptions(future.globals.maxSize = 14 * 1024^3)  # para 14 GB de RAM\n\n\nNote that as of future version 1.14.0, forked processing is disabled when running in RStudio. To enable parallel computing in RStudio, you will need to select the “multisession” option.\n\n4.1.1 Create ChromatinAssay\nThe ATAC-seq data is stored using a custom assay, the ChromatinAssay. This enables some specialized functions for analysing genomic single-cell assays such as scATAC-seq. By printing the assay we can see some of the additional information that can be contained in the ChromatinAssay, including motif information, gene annotations, and genome information.\n\n\nCode\ncounts &lt;- Read10X_h5(filename = \"data/atac_v1_pbmc_10k_filtered_peak_bc_matrix.h5\")\nmetadata &lt;- read.csv(\n  file = \"data/atac_v1_pbmc_10k_singlecell.csv\",\n  header = TRUE,\n  row.names = 1\n)\n\nchrom_assay &lt;- CreateChromatinAssay(\n  counts = counts,\n  sep = c(\":\", \"-\"),\n  genome = 'hg19', # EnsDb.Hsapiens.v75\n  fragments = \"data/atac_v1_pbmc_10k_fragments.tsv.gz\",\n  min.cells = 10,\n  min.features = 200\n)\n\n\nComputing hash\n\n\nCode\npbmc &lt;- CreateSeuratObject(\n  counts = chrom_assay,\n  assay = \"ATAC\",\n  meta.data = metadata\n)\n\n\nCheck global information\n\n\nCode\npbmc\n\n\nAn object of class Seurat \n87561 features across 8728 samples within 1 assay \nActive assay: ATAC (87561 features, 0 variable features)\n 2 layers present: counts, data\n\n\nCheck ATAC information\n\n\nCode\npbmc[['ATAC']]\n\n\nChromatinAssay data with 87561 features for 8728 cells\nVariable features: 0 \nGenome: hg19 \nAnnotation present: FALSE \nMotifs present: FALSE \nFragment files: 1 \n\n\nWe then remove the features that correspond to chromosome scaffolds e.g. (KI270713.1) or other sequences instead of the (22+2) standard chromosomes.\n\n\nCode\npeaks.keep &lt;- seqnames(granges(pbmc)) %in% standardChromosomes(granges(pbmc))\npbmc &lt;- pbmc[as.vector(peaks.keep), ]\n\n\nCheck file:\n87561 features across 8728 samples within 1 assay.\n\n\nCode\ndim(pbmc)\n\n\n[1] 87561  8728\n\n\nCode\nstr(pbmc)\n\n\nFormal class 'Seurat' [package \"SeuratObject\"] with 13 slots\n  ..@ assays      :List of 1\n  .. ..$ ATAC:Formal class 'ChromatinAssay' [package \"Signac\"] with 16 slots\n  .. .. .. ..@ ranges            :Formal class 'GRanges' [package \"GenomicRanges\"] with 7 slots\n  .. .. .. .. .. ..@ seqnames       :Formal class 'Rle' [package \"S4Vectors\"] with 4 slots\n  .. .. .. .. .. .. .. ..@ values         : Factor w/ 24 levels \"chr1\",\"chr2\",..: 1 2 3 4 5 6 7 8 9 10 ...\n  .. .. .. .. .. .. .. ..@ lengths        : int [1:24] 8555 6858 5499 3515 4389 5269 4263 3677 3540 4137 ...\n  .. .. .. .. .. .. .. ..@ elementMetadata: NULL\n  .. .. .. .. .. .. .. ..@ metadata       : list()\n  .. .. .. .. .. ..@ ranges         :Formal class 'IRanges' [package \"IRanges\"] with 6 slots\n  .. .. .. .. .. .. .. ..@ start          : int [1:87561] 565107 569174 713460 752422 762106 779589 793516 801120 804872 839520 ...\n  .. .. .. .. .. .. .. ..@ width          : int [1:87561] 444 466 1364 617 1254 683 226 219 890 1604 ...\n  .. .. .. .. .. .. .. ..@ NAMES          : NULL\n  .. .. .. .. .. .. .. ..@ elementType    : chr \"ANY\"\n  .. .. .. .. .. .. .. ..@ elementMetadata: NULL\n  .. .. .. .. .. .. .. ..@ metadata       : list()\n  .. .. .. .. .. ..@ strand         :Formal class 'Rle' [package \"S4Vectors\"] with 4 slots\n  .. .. .. .. .. .. .. ..@ values         : Factor w/ 3 levels \"+\",\"-\",\"*\": 3\n  .. .. .. .. .. .. .. ..@ lengths        : int 87561\n  .. .. .. .. .. .. .. ..@ elementMetadata: NULL\n  .. .. .. .. .. .. .. ..@ metadata       : list()\n  .. .. .. .. .. ..@ seqinfo        :Formal class 'Seqinfo' [package \"GenomeInfoDb\"] with 4 slots\n  .. .. .. .. .. .. .. ..@ seqnames   : chr [1:24] \"chr1\" \"chr2\" \"chr3\" \"chr4\" ...\n  .. .. .. .. .. .. .. ..@ seqlengths : int [1:24] NA NA NA NA NA NA NA NA NA NA ...\n  .. .. .. .. .. .. .. ..@ is_circular: logi [1:24] NA NA NA NA NA NA ...\n  .. .. .. .. .. .. .. ..@ genome     : chr [1:24] NA NA NA NA ...\n  .. .. .. .. .. ..@ elementMetadata:Formal class 'DFrame' [package \"S4Vectors\"] with 6 slots\n  .. .. .. .. .. .. .. ..@ rownames       : NULL\n  .. .. .. .. .. .. .. ..@ nrows          : int 87561\n  .. .. .. .. .. .. .. ..@ elementType    : chr \"ANY\"\n  .. .. .. .. .. .. .. ..@ elementMetadata: NULL\n  .. .. .. .. .. .. .. ..@ metadata       : list()\n  .. .. .. .. .. .. .. ..@ listData       : Named list()\n  .. .. .. .. .. ..@ elementType    : chr \"ANY\"\n  .. .. .. .. .. ..@ metadata       : list()\n  .. .. .. ..@ motifs            : NULL\n  .. .. .. ..@ fragments         :List of 1\n  .. .. .. .. ..$ :Formal class 'Fragment' [package \"Signac\"] with 3 slots\n  .. .. .. .. .. .. ..@ path : chr \"C:\\\\Users\\\\ecoss\\\\OneDrive - CINVESTAV\\\\Documentos\\\\Github_notes\\\\scATACseq_Team\\\\WCS_scATACseq_book\\\\data\\\\ata\"| __truncated__\n  .. .. .. .. .. .. ..@ hash : chr [1:2] \"8e03bd72e952a7da7c1cce52f3696e6e\" \"146e556e1311573593bd6cfa6efefcc1\"\n  .. .. .. .. .. .. ..@ cells: Named chr [1:8728] \"AAACGAAAGAGCGAAA-1\" \"AAACGAAAGAGTTTGA-1\" \"AAACGAAAGCGAGCTA-1\" \"AAACGAAAGGCTTCGC-1\" ...\n  .. .. .. .. .. .. .. ..- attr(*, \"names\")= chr [1:8728] \"AAACGAAAGAGCGAAA-1\" \"AAACGAAAGAGTTTGA-1\" \"AAACGAAAGCGAGCTA-1\" \"AAACGAAAGGCTTCGC-1\" ...\n  .. .. .. ..@ seqinfo           :Formal class 'Seqinfo' [package \"GenomeInfoDb\"] with 4 slots\n  .. .. .. .. .. ..@ seqnames   : chr [1:298] \"chr1\" \"chr2\" \"chr3\" \"chr4\" ...\n  .. .. .. .. .. ..@ seqlengths : int [1:298] 249250621 243199373 198022430 191154276 180915260 171115067 159138663 146364022 141213431 135534747 ...\n  .. .. .. .. .. ..@ is_circular: logi [1:298] FALSE FALSE FALSE FALSE FALSE FALSE ...\n  .. .. .. .. .. ..@ genome     : chr [1:298] \"hg19\" \"hg19\" \"hg19\" \"hg19\" ...\n  .. .. .. ..@ annotation        : NULL\n  .. .. .. ..@ bias              : NULL\n  .. .. .. ..@ positionEnrichment: list()\n  .. .. .. ..@ links             :Formal class 'GRanges' [package \"GenomicRanges\"] with 7 slots\n  .. .. .. .. .. ..@ seqnames       :Formal class 'Rle' [package \"S4Vectors\"] with 4 slots\n  .. .. .. .. .. .. .. ..@ values         : Factor w/ 0 levels: \n  .. .. .. .. .. .. .. ..@ lengths        : int(0) \n  .. .. .. .. .. .. .. ..@ elementMetadata: NULL\n  .. .. .. .. .. .. .. ..@ metadata       : list()\n  .. .. .. .. .. ..@ ranges         :Formal class 'IRanges' [package \"IRanges\"] with 6 slots\n  .. .. .. .. .. .. .. ..@ start          : int(0) \n  .. .. .. .. .. .. .. ..@ width          : int(0) \n  .. .. .. .. .. .. .. ..@ NAMES          : NULL\n  .. .. .. .. .. .. .. ..@ elementType    : chr \"ANY\"\n  .. .. .. .. .. .. .. ..@ elementMetadata: NULL\n  .. .. .. .. .. .. .. ..@ metadata       : list()\n  .. .. .. .. .. ..@ strand         :Formal class 'Rle' [package \"S4Vectors\"] with 4 slots\n  .. .. .. .. .. .. .. ..@ values         : Factor w/ 3 levels \"+\",\"-\",\"*\": \n  .. .. .. .. .. .. .. ..@ lengths        : int(0) \n  .. .. .. .. .. .. .. ..@ elementMetadata: NULL\n  .. .. .. .. .. .. .. ..@ metadata       : list()\n  .. .. .. .. .. ..@ seqinfo        :Formal class 'Seqinfo' [package \"GenomeInfoDb\"] with 4 slots\n  .. .. .. .. .. .. .. ..@ seqnames   : chr(0) \n  .. .. .. .. .. .. .. ..@ seqlengths : int(0) \n  .. .. .. .. .. .. .. ..@ is_circular: logi(0) \n  .. .. .. .. .. .. .. ..@ genome     : chr(0) \n  .. .. .. .. .. ..@ elementMetadata:Formal class 'DFrame' [package \"S4Vectors\"] with 6 slots\n  .. .. .. .. .. .. .. ..@ rownames       : NULL\n  .. .. .. .. .. .. .. ..@ nrows          : int 0\n  .. .. .. .. .. .. .. ..@ elementType    : chr \"ANY\"\n  .. .. .. .. .. .. .. ..@ elementMetadata: NULL\n  .. .. .. .. .. .. .. ..@ metadata       : list()\n  .. .. .. .. .. .. .. ..@ listData       : Named list()\n  .. .. .. .. .. ..@ elementType    : chr \"ANY\"\n  .. .. .. .. .. ..@ metadata       : list()\n  .. .. .. ..@ counts            :Formal class 'dgCMatrix' [package \"Matrix\"] with 6 slots\n  .. .. .. .. .. ..@ i       : int [1:52681465] 31 74 83 116 134 147 153 166 175 178 ...\n  .. .. .. .. .. ..@ p       : int [1:8729] 0 5546 12127 21340 51653 56574 61650 64340 73157 79801 ...\n  .. .. .. .. .. ..@ Dim     : int [1:2] 87561 8728\n  .. .. .. .. .. ..@ Dimnames:List of 2\n  .. .. .. .. .. .. ..$ : chr [1:87561] \"chr1-565107-565550\" \"chr1-569174-569639\" \"chr1-713460-714823\" \"chr1-752422-753038\" ...\n  .. .. .. .. .. .. ..$ : chr [1:8728] \"AAACGAAAGAGCGAAA-1\" \"AAACGAAAGAGTTTGA-1\" \"AAACGAAAGCGAGCTA-1\" \"AAACGAAAGGCTTCGC-1\" ...\n  .. .. .. .. .. ..@ x       : num [1:52681465] 2 2 2 1 2 2 2 6 2 2 ...\n  .. .. .. .. .. ..@ factors : list()\n  .. .. .. ..@ data              :Formal class 'dgCMatrix' [package \"Matrix\"] with 6 slots\n  .. .. .. .. .. ..@ i       : int [1:52681465] 31 74 83 116 134 147 153 166 175 178 ...\n  .. .. .. .. .. ..@ p       : int [1:8729] 0 5546 12127 21340 51653 56574 61650 64340 73157 79801 ...\n  .. .. .. .. .. ..@ Dim     : int [1:2] 87561 8728\n  .. .. .. .. .. ..@ Dimnames:List of 2\n  .. .. .. .. .. .. ..$ : chr [1:87561] \"chr1-565107-565550\" \"chr1-569174-569639\" \"chr1-713460-714823\" \"chr1-752422-753038\" ...\n  .. .. .. .. .. .. ..$ : chr [1:8728] \"AAACGAAAGAGCGAAA-1\" \"AAACGAAAGAGTTTGA-1\" \"AAACGAAAGCGAGCTA-1\" \"AAACGAAAGGCTTCGC-1\" ...\n  .. .. .. .. .. ..@ x       : num [1:52681465] 2 2 2 1 2 2 2 6 2 2 ...\n  .. .. .. .. .. ..@ factors : list()\n  .. .. .. ..@ scale.data        : num[0 , 0 ] \n  .. .. .. ..@ assay.orig        : NULL\n  .. .. .. ..@ var.features      : logi(0) \n  .. .. .. ..@ meta.features     :'data.frame': 87561 obs. of  2 variables:\n  .. .. .. .. ..$ count     : num [1:87561] 172 437 6807 864 4841 ...\n  .. .. .. .. ..$ percentile: num [1:87561] 0.274 0.535 0.92 0.691 0.891 ...\n  .. .. .. ..@ misc              :List of 1\n  .. .. .. .. ..$ calcN: logi TRUE\n  .. .. .. ..@ key               : chr \"atac_\"\n  ..@ meta.data   :'data.frame':    8728 obs. of  19 variables:\n  .. ..$ orig.ident                      : Factor w/ 1 level \"SeuratProject\": 1 1 1 1 1 1 1 1 1 1 ...\n  .. ..$ nCount_ATAC                     : num [1:8728] 13187 16069 28008 221734 11439 ...\n  .. ..$ nFeature_ATAC                   : int [1:8728] 5546 6581 9213 30313 4921 5076 2690 8817 6644 3632 ...\n  .. ..$ total                           : int [1:8728] 22965 21806 46233 288897 16103 266481 10753 31745 23136 14626 ...\n  .. ..$ duplicate                       : int [1:8728] 10872 9336 21197 99998 6751 45654 4760 14341 10210 5612 ...\n  .. ..$ chimeric                        : int [1:8728] 183 122 479 2830 104 3425 61 167 145 99 ...\n  .. ..$ unmapped                        : int [1:8728] 198 175 292 1512 120 1514 43 191 157 109 ...\n  .. ..$ lowmapq                         : int [1:8728] 1198 1050 2673 16347 867 41940 644 1465 1308 913 ...\n  .. ..$ mitochondrial                   : int [1:8728] 51 1 14 913 0 57 96 29 15 96 ...\n  .. ..$ passed_filters                  : int [1:8728] 10463 11122 21578 167297 8261 173891 5149 15552 11301 7797 ...\n  .. ..$ cell_id                         : chr [1:8728] \"_cell_0\" \"_cell_1\" \"_cell_2\" \"_cell_3\" ...\n  .. ..$ is__cell_barcode                : int [1:8728] 1 1 1 1 1 1 1 1 1 1 ...\n  .. ..$ TSS_fragments                   : int [1:8728] 4157 4858 10696 86433 3784 14141 2637 6587 5136 3493 ...\n  .. ..$ DNase_sensitive_region_fragments: int [1:8728] 8537 9548 17420 137387 6973 78696 3973 13546 9636 6050 ...\n  .. ..$ enhancer_region_fragments       : int [1:8728] 3079 3954 4332 32884 2509 11425 753 5745 3542 1394 ...\n  .. ..$ promoter_region_fragments       : int [1:8728] 3249 3600 8763 70515 2987 1686 2289 4911 4019 2740 ...\n  .. ..$ on_target_fragments             : int [1:8728] 8894 10034 18562 144918 7288 85168 4183 14115 10072 6346 ...\n  .. ..$ blacklist_region_fragments      : int [1:8728] 6 10 22 300 4 2121 8 23 8 13 ...\n  .. ..$ peak_region_fragments           : int [1:8728] 6796 8319 14333 113658 5879 7360 3220 11399 8215 4509 ...\n  ..@ active.assay: chr \"ATAC\"\n  ..@ active.ident: Factor w/ 1 level \"SeuratProject\": 1 1 1 1 1 1 1 1 1 1 ...\n  .. ..- attr(*, \"names\")= chr [1:8728] \"AAACGAAAGAGCGAAA-1\" \"AAACGAAAGAGTTTGA-1\" \"AAACGAAAGCGAGCTA-1\" \"AAACGAAAGGCTTCGC-1\" ...\n  ..@ graphs      : list()\n  ..@ neighbors   : list()\n  ..@ reductions  : list()\n  ..@ images      : list()\n  ..@ project.name: chr \"SeuratProject\"\n  ..@ misc        : list()\n  ..@ version     :Classes 'package_version', 'numeric_version'  hidden list of 1\n  .. ..$ : int [1:3] 5 0 2\n  ..@ commands    : list()\n  ..@ tools       : list()\n\n\nFor example, we can call granges on a Seurat object with a ChromatinAssay set as the active assay (or on a ChromatinAssay) to see the genomic ranges associated with each feature in the object. See the object interaction vignette for more information about the ChromatinAssay class.\n\n\nCode\ngranges(pbmc)\n\n\nGRanges object with 87561 ranges and 0 metadata columns:\n          seqnames            ranges strand\n             &lt;Rle&gt;         &lt;IRanges&gt;  &lt;Rle&gt;\n      [1]     chr1     565107-565550      *\n      [2]     chr1     569174-569639      *\n      [3]     chr1     713460-714823      *\n      [4]     chr1     752422-753038      *\n      [5]     chr1     762106-763359      *\n      ...      ...               ...    ...\n  [87557]     chrY 58993392-58993760      *\n  [87558]     chrY 58994571-58994823      *\n  [87559]     chrY 58996352-58997331      *\n  [87560]     chrY 59001782-59002175      *\n  [87561]     chrY 59017143-59017246      *\n  -------\n  seqinfo: 24 sequences from an unspecified genome; no seqlengths\n\n\nBarcodes:\n\n\nCode\nhead(colnames(pbmc))\n\n\n[1] \"AAACGAAAGAGCGAAA-1\" \"AAACGAAAGAGTTTGA-1\" \"AAACGAAAGCGAGCTA-1\"\n[4] \"AAACGAAAGGCTTCGC-1\" \"AAACGAAAGTGCTGAG-1\" \"AAACGAACAAGGGTAC-1\"\n\n\nPositions:\n\n\nCode\nhead(rownames(pbmc))\n\n\n[1] \"chr1-565107-565550\" \"chr1-569174-569639\" \"chr1-713460-714823\"\n[4] \"chr1-752422-753038\" \"chr1-762106-763359\" \"chr1-779589-780271\""
  },
  {
    "objectID": "Section1_P13_retos.html#step-2-annotation",
    "href": "Section1_P13_retos.html#step-2-annotation",
    "title": "3  Exercises",
    "section": "4.2 ✒️ Step 2: Annotation",
    "text": "4.2 ✒️ Step 2: Annotation\nWe can also add gene annotations to the pbmc object for the human genome. This will allow downstream functions to pull the gene annotation information directly from the object.\nBefore annotation\n\n\nCode\npbmc@assays$ATAC@annotation\n\n\nNULL\n\n\n\n4.2.1 Get gene annotations for the peaks and add to the object\nFrom the dataset summary, we can see that the reference package 10x Genomics used to perform the mapping was “hg19”, which corresponds to the Ensembl v75 (hg19) patch release.\n\n\nCode\n# extract gene annotations from EnsDb\nannotations &lt;- GetGRangesFromEnsDb(ensdb = EnsDb.Hsapiens.v75)\n\n# change to UCSC style since the data was mapped to hg19\nseqlevelsStyle(annotations) &lt;- 'UCSC'\n\n# add the gene information to the object\nAnnotation(pbmc) &lt;- annotations\n# check\nhead(seqlevels(pbmc))\n\n\n[1] \"chr1\" \"chr2\" \"chr3\" \"chr4\" \"chr5\" \"chr6\"\n\n\nAfter adding the gene annotation:\n\n\nCode\npbmc@assays$ATAC@annotation\n\n\nGRanges object with 3072120 ranges and 5 metadata columns:\n                  seqnames        ranges strand |           tx_id   gene_name\n                     &lt;Rle&gt;     &lt;IRanges&gt;  &lt;Rle&gt; |     &lt;character&gt; &lt;character&gt;\n  ENSE00001489430     chrX 192989-193061      + | ENST00000399012      PLCXD1\n  ENSE00001536003     chrX 192991-193061      + | ENST00000484611      PLCXD1\n  ENSE00002160563     chrX 193020-193061      + | ENST00000430923      PLCXD1\n  ENSE00001750899     chrX 197722-197788      + | ENST00000445062      PLCXD1\n  ENSE00001489388     chrX 197859-198351      + | ENST00000381657      PLCXD1\n              ...      ...           ...    ... .             ...         ...\n  ENST00000361739    chrMT     7586-8269      + | ENST00000361739      MT-CO2\n  ENST00000361789    chrMT   14747-15887      + | ENST00000361789      MT-CYB\n  ENST00000361851    chrMT     8366-8572      + | ENST00000361851     MT-ATP8\n  ENST00000361899    chrMT     8527-9207      + | ENST00000361899     MT-ATP6\n  ENST00000362079    chrMT     9207-9990      + | ENST00000362079      MT-CO3\n                          gene_id   gene_biotype     type\n                      &lt;character&gt;    &lt;character&gt; &lt;factor&gt;\n  ENSE00001489430 ENSG00000182378 protein_coding     exon\n  ENSE00001536003 ENSG00000182378 protein_coding     exon\n  ENSE00002160563 ENSG00000182378 protein_coding     exon\n  ENSE00001750899 ENSG00000182378 protein_coding     exon\n  ENSE00001489388 ENSG00000182378 protein_coding     exon\n              ...             ...            ...      ...\n  ENST00000361739 ENSG00000198712 protein_coding      cds\n  ENST00000361789 ENSG00000198727 protein_coding      cds\n  ENST00000361851 ENSG00000228253 protein_coding      cds\n  ENST00000361899 ENSG00000198899 protein_coding      cds\n  ENST00000362079 ENSG00000198938 protein_coding      cds\n  -------\n  seqinfo: 25 sequences (1 circular) from hg19 genome"
  },
  {
    "objectID": "Section1_P13_retos.html#step-3-computing-qc-metrics",
    "href": "Section1_P13_retos.html#step-3-computing-qc-metrics",
    "title": "3  Exercises",
    "section": "4.3 📕 Step 3: Computing QC metrics",
    "text": "4.3 📕 Step 3: Computing QC metrics\nWe can now compute some QC metrics for the scATAC-seq experiment as the original tutorial. We currently suggest the following metrics below to assess data quality. As with scRNA-seq, the expected range of values for these parameters will vary depending on your biological system, cell viability, and other factors.\nCalculate the strength of the nucleosome signal per cell using NucleosomeSignal(). Computes the ratio of fragments between 147 bp and 294 bp (mononucleosome) to fragments &lt; 147 bp (nucleosome-free).\nWe can inspect the TSS enrichment scores by grouping the cells based on the score and plotting the accessibility signal over all TSS sites. Setting the `fast=TRUE` option in TSSEnrichment() will only compute the TSS enrichment score without storing the entire cell by position matrix of Tn5 insertion frequency for each cell, and can save memory.\n\n\nCode\n# compute nucleosome signal score per cell\npbmc &lt;- NucleosomeSignal(object = pbmc)\n\n# compute TSS enrichment score per cell\npbmc &lt;- TSSEnrichment(object = pbmc)\n\n# add fraction of reads in peaks\npbmc$pct_reads_in_peaks &lt;- pbmc$peak_region_fragments / pbmc$passed_filters * 100\n\n# add blacklist ratio\npbmc$blacklist_ratio &lt;- pbmc$blacklist_region_fragments/pbmc$peak_region_fragments\n\n\n\n4.3.1 Impact of Sample Type on Fragment Yield and Sequencing Quality\n\n\n\n\n\n\nNote\n\n\n\n\nScatterplot colored by point density: This plot shows the log10(unique nuclear fragments) vs TSS enrichment score and indicates the thresholds used with dotted lines.\nHistogram: These plot shows the fragment size distribution.\n\n\n\nThe relationship between variables stored in the object metadata can be visualized using the DensityScatter() function. This can also be used to quickly find suitable cutoff values for different QC metrics by setting quantiles=TRUE:\n\n\nCode\nDensityScatter(pbmc, x = 'nCount_ATAC', y = 'TSS.enrichment', log_x = TRUE, quantiles = TRUE)\n\n\n\n\n\nWe can also look at the fragment length periodicity for all the cells, and group by cells with high or low nucleosomal signal strength. You can see that cells that are outliers for the mononucleosomal / nucleosome-free ratio (based on the plots above) have different nucleosomal banding patterns. The remaining cells exhibit a pattern that is typical for a successful ATAC-seq experiment.\n\n\n4.3.2 Fragment size distribution\n\n\nCode\npbmc$nucleosome_group &lt;- ifelse(pbmc$nucleosome_signal &gt; 4, 'NS &gt; 4', 'NS &lt; 4')\nFragmentHistogram(object = pbmc, group.by = 'nucleosome_group')\n\n\n\n\n\nWe can plot the distribution of each QC metric separately using a violin plot:\n\n\nCode\nVlnPlot(\n  object = pbmc,\n  features = c('nCount_ATAC', 'TSS.enrichment', 'blacklist_ratio', 'nucleosome_signal', 'pct_reads_in_peaks'),\n  pt.size = 0.1,\n  ncol = 5\n)\n\n\n\n\n\nFinally we remove cells that are outliers for these QC metrics. The exact QC thresholds used will need to be adjusted according to your dataset.\n\n\nCode\npbmc &lt;- subset(\n  x = pbmc,\n  subset = nCount_ATAC &gt; 3000 & \n    nCount_ATAC &lt; 20000 &  \n    pct_reads_in_peaks &gt; 15 & # 15 % of the reads in the peaks\n    blacklist_ratio &lt; 0.01 & # 1 % of the reads mapeaning in blacklist ratio\n    nucleosome_signal &lt; 4 &\n    TSS.enrichment &gt; 4\n)\npbmc\n\n\nAn object of class Seurat \n87561 features across 5628 samples within 1 assay \nActive assay: ATAC (87561 features, 0 variable features)\n 2 layers present: counts, data\n\n\n\n\n            used   (Mb) gc trigger   (Mb)  max used   (Mb)\nNcells  14744424  787.5   39499445 2109.5  31091560 1660.5\nVcells 300690801 2294.1  514189314 3923.0 514189312 3923.0"
  },
  {
    "objectID": "Section1_P13_retos.html#step-4-normalization-and-linear-dimensional-reduction-lsi",
    "href": "Section1_P13_retos.html#step-4-normalization-and-linear-dimensional-reduction-lsi",
    "title": "3  Exercises",
    "section": "4.4 📘 Step 4: Normalization and linear dimensional reduction (LSI)",
    "text": "4.4 📘 Step 4: Normalization and linear dimensional reduction (LSI)\n\n\nCode\npbmc &lt;- RunTFIDF(pbmc)\n\n\nPerforming TF-IDF normalization\n\n\nWarning in RunTFIDF.default(object = GetAssayData(object = object, layer =\n\"counts\"), : Some features contain 0 total counts\n\n\nCode\npbmc &lt;- FindTopFeatures(pbmc, min.cutoff = 'q0')\npbmc &lt;- RunSVD(pbmc)\n\n\nRunning SVD\n\n\nScaling cell embeddings\n\n\n\n\n            used   (Mb) gc trigger   (Mb)  max used   (Mb)\nNcells  14753702  788.0   39499445 2109.5  31091560 1660.5\nVcells 296878213 2265.1  514189314 3923.0 514189312 3923.0\n\n\nThe first LSI component often captures sequencing depth (technical variation) rather than biological variation. If this is the case, the component should be removed from downstream analysis. We can assess the correlation between each LSI component and sequencing depth using the DepthCor() function:\n\n\nCode\nDepthCor(pbmc)\n\n\n\n\n\nHere we see there is a very strong correlation between the first LSI component and the total number of counts for the cell. We will perform downstream steps without this component as we don’t want to group cells together based on their total sequencing depth, but rather by their patterns of accessibility at cell-type-specific peaks."
  },
  {
    "objectID": "Section1_P13_retos.html#step-5-non-linear-dimensional-reduction-and-clustering",
    "href": "Section1_P13_retos.html#step-5-non-linear-dimensional-reduction-and-clustering",
    "title": "3  Exercises",
    "section": "4.5 📙 Step 5: Non-linear dimensional reduction and clustering",
    "text": "4.5 📙 Step 5: Non-linear dimensional reduction and clustering\n\n\nCode\npbmc &lt;- RunUMAP(object = pbmc, reduction = 'lsi', dims = 2:30)\n\n\n13:00:54 UMAP embedding parameters a = 0.9922 b = 1.112\n\n\n13:00:54 Read 5628 rows and found 29 numeric columns\n\n\n13:00:54 Using Annoy for neighbor search, n_neighbors = 30\n\n\n13:00:54 Building Annoy index with metric = cosine, n_trees = 50\n\n\n0%   10   20   30   40   50   60   70   80   90   100%\n\n\n[----|----|----|----|----|----|----|----|----|----|\n\n\n**************************************************|\n13:00:55 Writing NN index file to temp file C:\\Users\\ecoss\\AppData\\Local\\Temp\\Rtmp6dLVBu\\file1440705513a5\n13:00:55 Searching Annoy index using 8 threads, search_k = 3000\n13:00:55 Annoy recall = 100%\n13:00:56 Commencing smooth kNN distance calibration using 8 threads with target n_neighbors = 30\n13:00:59 Initializing from normalized Laplacian + noise (using RSpectra)\n13:00:59 Commencing optimization for 500 epochs, with 212950 positive edges\n13:01:15 Optimization finished\n\n\nCode\npbmc &lt;- FindNeighbors(object = pbmc, reduction = 'lsi', dims = 2:30)\n\n\nComputing nearest neighbor graph\nComputing SNN\n\n\nCode\npbmc &lt;- FindClusters(object = pbmc, verbose = FALSE, algorithm = 3)\nDimPlot(object = pbmc, label = TRUE) + NoLegend()"
  },
  {
    "objectID": "Section1_P13_retos.html#references",
    "href": "Section1_P13_retos.html#references",
    "title": "3  Exercises",
    "section": "4.6 References",
    "text": "4.6 References\nAnalyzing PBMC scATAC-seq (Signac tutorial)\nAnalyzing PBMC scATAC-seq"
  },
  {
    "objectID": "Section1_P13_intro.html#dataset-overview",
    "href": "Section1_P13_intro.html#dataset-overview",
    "title": "2  Practical 13: scATAC-seq Pre-Processing and Quality Control",
    "section": "2.1 Dataset overview",
    "text": "2.1 Dataset overview\nFor this tutorial, we will be analyzing a single-cell ATAC-seq dataset of human peripheral blood mononuclear cells (PBMCs) provided by 10x Genomics. The following files are used in this course, all available through the 10x Genomics website:\n\nThe Raw data: Filtered peak barcode matrix. File name: Peak by cell matrix HDF5 (filtered). Format: h5 / hdf5.\nThe Metadata: Per-barcode fragment counts & metrics. Per Barcode metrics . Format: csv.\nThe fragments file: Barcoded and aligned fragment file. File name: Fragments. Format: tsv.gz.\nThe fragments file index: Fragments file index. File name: Fragments index. Format: tbi.\n\nOur starting points is the output of cellranger-atac (v2.1.0), a 10x Genomics software used for alignment peak calling and initial quality control (QC) of the assay on 10x PBMCs from healthy donor (unimodal scATAC-seq assay).\n\n\n\n\n\n\nView data download code\n\n\n\n\n\nTotal 2.7 Gb\n# Raw data\nwget https://cf.10xgenomics.com/samples/cell-atac/2.1.0/10k_pbmc_ATACv2_nextgem_Chromium_Controller/10k_pbmc_ATACv2_nextgem_Chromium_Controller_filtered_peak_bc_matrix.h5\n# metadata\nwget https://cf.10xgenomics.com/samples/cell-atac/2.1.0/10k_pbmc_ATACv2_nextgem_Chromium_Controller/10k_pbmc_ATACv2_nextgem_Chromium_Controller_singlecell.csv\n# fragments file\nwget https://cf.10xgenomics.com/samples/cell-atac/2.1.0/10k_pbmc_ATACv2_nextgem_Chromium_Controller/10k_pbmc_ATACv2_nextgem_Chromium_Controller_fragments.tsv.gz\n# fragments index\nwget https://cf.10xgenomics.com/samples/cell-atac/2.1.0/10k_pbmc_ATACv2_nextgem_Chromium_Controller/10k_pbmc_ATACv2_nextgem_Chromium_Controller_fragments.tsv.gz.tbi\n\n\n\n\n2.1.1 Summary file metrics\nAccording to the data report, we observed 10,246 PBMC nuclei were recovered. ATAC libraries were generated as described in the Chromium Single Cell ATAC Reagent Kits User Guide (v2 chemistry) using the Chromium Controller and sequenced on Illumina NovaSeq 6000 to approximately 55 k read pairs per cell.\n\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nGreen text indicates that the key metrics are in the expected range while red/yellow text indicates errors/warnings. Descriptions of the metrics can also be found by clicking the icon ? next to the section header. The summary tab reports various metrics including sample, sequencing, cells, cell clustering, insert sizes, targeting, and library complexity.\n\n\nIf you want to know more information about how to analyze the report check this information or check this web page.\n\n\n2.1.2 PBMCs\n\n\n\n\n\n\nNote\n\n\n\nPeripheral Blood Mononuclear Cells (PBMCs) are all blood cells with a single nucleus, including lymphocytes (T cells, B cells, and NK cells) and monocytes. Erythrocytes, platelets, and granulocytes are not considered PBMCs because they have either no nuclei or multiple nuclei. PBMCs play a crucial role in the immune system and serve as important tools for immunological research.\n\n\n\n\n\nFigure 2.1: Expected cell types in PBMCs"
  },
  {
    "objectID": "Section1_P13_intro.html#seurat-signac-workflow",
    "href": "Section1_P13_intro.html#seurat-signac-workflow",
    "title": "2  Practical 13: scATAC-seq Pre-Processing and Quality Control",
    "section": "2.2 Seurat + Signac Workflow",
    "text": "2.2 Seurat + Signac Workflow\n\n\n\nFigure 2.2: Single-cell chromatin analysis workflow with Signac.\n\n\n\nPre-processing workflow\n\n\n\n\nflowchart LR\n\n  A(Import Data) --&gt; B(Annotation)\n \n  B --&gt; C(Computing QC metrics)\n \n  C --&gt; D(Normalization and linear \\ndimensional reduction)\n  \n  D --&gt; E(Non-linear dimensional \\nreduction and clustering)"
  },
  {
    "objectID": "Section1_P13_intro.html#step-1-import-data",
    "href": "Section1_P13_intro.html#step-1-import-data",
    "title": "2  Practical 13: scATAC-seq Pre-Processing and Quality Control",
    "section": "2.3 📗 Step 1: Import Data",
    "text": "2.3 📗 Step 1: Import Data\nWhen pre-processing chromatin data, Signac uses information from 4 related input files, both of which can be created using Cell Ranger ATAC:\n\n\nPeak/Cell Matrix (raw data): Similar to the gene expression count matrix used in single-cell RNA-seq, but instead of genes, the rows represent regions of the genome (peaks) that indicate areas of open chromatin. Each value in the matrix represents the number of Tn5 integration sites for each barcode (cell) that map within each peak. More information about this file on the 10x Genomics website.\nMetadata: Cell Ranger ATAC identifies cells by determining whether each barcode corresponds to a cell from any species in the reference. It also generates QC data, including the number of fragments per barcode and ATAC signal, based on metrics like the overlap of fragments with transcription start sites (TSS) from the reference. This barcode-level information is compiled into a single output table. More information about this file on the 10x Genomics website.\nFragment File: Contains a complete list of all unique fragments across all single cells. Although it is larger and slower to process, and is stored on-disk (instead of in memory), its advantage is that it includes all fragments associated with each cell, not just those that map to peaks. More information about the fragment file can be found on the 10x Genomics website or on the sinto website.\nFragment index file: The fragment index file enables fast access to specific fragments in a sequencing file by indexing their positions. This speeds up retrieval and improves analysis efficiency.\n\n\n\n\n\n\n\n\nWhat if I don’t have a H5 file?\n\n\n\n\n\nThen you can use other outputs from cellranger:\n\ncounts: matrix.mtx\nbarcodes: barcodes.tsv\npeaks: peaks.bed\n\nAlternatively, you might only have a fragment file. In this case you can create a count matrix using the FeatureMatrix() function. If you want to know about this check the Signac tutorial.\n\n\n\n\n\nCode\nlibrary(Signac)\nlibrary(Seurat) \nlibrary(GenomicRanges) # genomic data manipulation\nlibrary(ggplot2) #vizualization\nlibrary(patchwork) # Vizualization \nlibrary(EnsDb.Hsapiens.v86) # human genome hg38\nlibrary(future) # parallelization in Signac\n\n\n\n\nR version: R version 4.4.1 (2024-06-14 ucrt) \n\n\nNumber of cores: 8 \n\n\n[1] '1.14.0'\n\n\nmulticore:\n- args: function (..., workers = 8, envir = parent.frame())\n- tweaked: TRUE\n- call: plan(\"multicore\", workers = 8)\n\n\n\n2.3.1 Create ChromatinAssay\nThe ATAC-seq data is stored using a custom assay, the ChromatinAssay. This enables some specialized functions for analysing genomic single-cell assays such as scATAC-seq. By printing the assay we can see some of the additional information that can be contained in the ChromatinAssay, including motif information, gene annotations, and genome information.\n\n\nCode\ncounts &lt;- Read10X_h5(filename = \"data/10k_pbmc_ATACv2_nextgem_Chromium_Controller_filtered_peak_bc_matrix.h5\")\nmetadata &lt;- read.csv(\n  file = \"data/10k_pbmc_ATACv2_nextgem_Chromium_Controller_singlecell.csv\",\n  header = TRUE,\n  row.names = 1\n)\n\nchrom_assay &lt;- CreateChromatinAssay(\n  counts = counts,\n  sep = c(\":\", \"-\"),\n  fragments = \"data/10k_pbmc_ATACv2_nextgem_Chromium_Controller_fragments.tsv.gz\",\n  min.cells = 10,\n  min.features = 200\n)\n\n\nComputing hash\n\n\nCode\npbmc &lt;- CreateSeuratObject(\n  counts = chrom_assay,\n  assay = \"peaks\",\n  meta.data = metadata\n)\n\n\nCheck global information\n\n\nCode\npbmc\n\n\nAn object of class Seurat \n165434 features across 10246 samples within 1 assay \nActive assay: peaks (165434 features, 0 variable features)\n 2 layers present: counts, data\n\n\nCheck ATAC information\n\n\nCode\npbmc[['peaks']]\n\n\nChromatinAssay data with 165434 features for 10246 cells\nVariable features: 0 \nGenome: \nAnnotation present: FALSE \nMotifs present: FALSE \nFragment files: 1 \n\n\nWe then remove features that correspond to chromosome scaffolds (e.g., KI270713.1) or any other sequences that are not part of the 22 standard autosomes or the two sex chromosomes (X and Y), ensuring that only well-characterized and fully assembled chromosomal regions are included in the analysis.We then remove the features that correspond to chromosome scaffolds e.g. (KI270713.1) or other sequences instead of the (22+2) standard chromosomes.\n\n\nCode\npeaks.keep &lt;- seqnames(granges(pbmc)) %in% standardChromosomes(granges(pbmc))\npbmc &lt;- pbmc[as.vector(peaks.keep), ]"
  },
  {
    "objectID": "Section1_P13_intro.html#step-2-annotation",
    "href": "Section1_P13_intro.html#step-2-annotation",
    "title": "2  Practical 13: scATAC-seq Pre-Processing and Quality Control",
    "section": "2.4 ✒️ Step 2: Annotation",
    "text": "2.4 ✒️ Step 2: Annotation\nWe can also add gene annotations to the pbmc object for the human genome. This will allow downstream functions to pull the gene annotation information directly from the object.\n\nBefore annotation\n\n\nCode\npbmc@assays$peaks@annotation\n\n\nNULL\n\n\n\n\n2.4.1 Get gene annotations for the peaks and add to the object\nFrom the dataset summary, we can see that the reference package 10x Genomics used to perform the mapping was “GRCh38-2020-A”, which corresponds to the Ensembl v98 (hg38) patch release.\n\n\nCode\n# extract gene annotations from EnsDb\nannotations &lt;- GetGRangesFromEnsDb(ensdb = EnsDb.Hsapiens.v86)\n# change to UCSC style since the data was mapped to hg38\nseqlevelsStyle(annotations) &lt;- 'UCSC'\ngenome(annotations) &lt;- \"hg38\"\n\n#  Check chromosomes\nseqlevels(annotations)\n\n\n [1] \"chrX\"  \"chr20\" \"chr1\"  \"chr6\"  \"chr3\"  \"chr7\"  \"chr12\" \"chr11\" \"chr4\" \n[10] \"chr17\" \"chr2\"  \"chr16\" \"chr8\"  \"chr19\" \"chr9\"  \"chr13\" \"chr14\" \"chr5\" \n[19] \"chr22\" \"chr10\" \"chrY\"  \"chr18\" \"chr15\" \"chr21\" \"chrM\" \n\n\nCode\n# add the gene information to the object\nAnnotation(pbmc) &lt;- annotations\n\n\n\nOther options\n\n\nCode\nlibrary(AnnotationHub)\nah &lt;- AnnotationHub()\n\n# Search for the Ensembl 98 EnsDb for Homo sapiens on AnnotationHub\nquery(ah, \"EnsDb.Hsapiens.v98\")\nensdb_v98 &lt;- ah[[\"AH75011\"]]\n\n# extract gene annotations from EnsDb\nannotations &lt;- GetGRangesFromEnsDb(ensdb = ensdb_v98)\n\n# change to UCSC style since the data was mapped to hg38\nseqlevels(annotations) &lt;- paste0('chr', seqlevels(annotations))\ngenome(annotations) &lt;- \"hg38\"\n\n# add the gene information to the object\nAnnotation(pbmc) &lt;- annotations\n\n\n\n\nOlder version (hg19)\n\n\nCode\n# BiocManager::install(c('BSgenome.Hsapiens.UCSC.hg19', 'EnsDb.Hsapiens.v75'))\n# first get some gene annotations for hg19\nlibrary(EnsDb.Hsapiens.v75)\n\n# convert EnsDb to GRanges\nannotation &lt;- GetGRangesFromEnsDb(ensdb = EnsDb.Hsapiens.v75)\n\n# convert to UCSC style\nseqlevels(annotation) &lt;- paste0('chr', seqlevels(annotation))\ngenome(annotation) &lt;- \"hg19\"\n\n# set gene annotations\nAnnotation(pbmc) &lt;- annotation\n\n# get gene annotation information\nAnnotation(pbmc)\n\n\n\n\nOlder version (hg19)\n\n\nCode\nlibrary(EnsDb.Hsapiens.v75)\n\n# extract gene annotations from EnsDb\nannotation &lt;- GetGRangesFromEnsDb(ensdb = EnsDb.Hsapiens.v75)\n\n# change to UCSC style since the data was mapped to hg19\nseqlevelsStyle(annotation) &lt;- 'UCSC'\n\n# add the gene information to the object\nAnnotation(pbmc) &lt;- annotation\n# check\nhead(seqlevels(pbmc))\n\n\nFor more details on Data structures and object interaction in Signac. EnsDb.Hsapiens.v86 was used for Joint RNA and ATAC analysis: 10x multiomic. Informations about genome version can be found at this link.\nAfter adding the gene annotation:\n\n\nCode\npbmc@assays$peaks@annotation\n\n\nGRanges object with 3021151 ranges and 5 metadata columns:\n                  seqnames        ranges strand |           tx_id   gene_name\n                     &lt;Rle&gt;     &lt;IRanges&gt;  &lt;Rle&gt; |     &lt;character&gt; &lt;character&gt;\n  ENSE00001489430     chrX 276322-276394      + | ENST00000399012      PLCXD1\n  ENSE00001536003     chrX 276324-276394      + | ENST00000484611      PLCXD1\n  ENSE00002160563     chrX 276353-276394      + | ENST00000430923      PLCXD1\n  ENSE00001750899     chrX 281055-281121      + | ENST00000445062      PLCXD1\n  ENSE00001489388     chrX 281192-281684      + | ENST00000381657      PLCXD1\n              ...      ...           ...    ... .             ...         ...\n  ENST00000361739     chrM     7586-8269      + | ENST00000361739      MT-CO2\n  ENST00000361789     chrM   14747-15887      + | ENST00000361789      MT-CYB\n  ENST00000361851     chrM     8366-8572      + | ENST00000361851     MT-ATP8\n  ENST00000361899     chrM     8527-9207      + | ENST00000361899     MT-ATP6\n  ENST00000362079     chrM     9207-9990      + | ENST00000362079      MT-CO3\n                          gene_id   gene_biotype     type\n                      &lt;character&gt;    &lt;character&gt; &lt;factor&gt;\n  ENSE00001489430 ENSG00000182378 protein_coding     exon\n  ENSE00001536003 ENSG00000182378 protein_coding     exon\n  ENSE00002160563 ENSG00000182378 protein_coding     exon\n  ENSE00001750899 ENSG00000182378 protein_coding     exon\n  ENSE00001489388 ENSG00000182378 protein_coding     exon\n              ...             ...            ...      ...\n  ENST00000361739 ENSG00000198712 protein_coding      cds\n  ENST00000361789 ENSG00000198727 protein_coding      cds\n  ENST00000361851 ENSG00000228253 protein_coding      cds\n  ENST00000361899 ENSG00000198899 protein_coding      cds\n  ENST00000362079 ENSG00000198938 protein_coding      cds\n  -------\n  seqinfo: 25 sequences (1 circular) from hg38 genome"
  },
  {
    "objectID": "Section1_P13_intro.html#step-3-computing-qc-metrics",
    "href": "Section1_P13_intro.html#step-3-computing-qc-metrics",
    "title": "2  Practical 13: scATAC-seq Pre-Processing and Quality Control",
    "section": "2.5 📕 Step 3: Computing QC metrics",
    "text": "2.5 📕 Step 3: Computing QC metrics\nWe can now compute QC metrics for the scATAC-seq experiment. Below are the recommended metrics for assessing data quality. As with scRNA-seq, expected values may vary depending on factors such as biological system and cell viability.\n\nNucleosome banding pattern: The DNA fragment size histogram should show a distinct nucleosome banding pattern, indicating DNA wrapped around nucleosomes. We calculate this per cell and quantify the ratio of mononucleosomal to nucleosome-free fragments (stored as nucleosome_signal).\n\nratio of nucleosome size fragments (147-294 nucleotides)\nnucleosome-free fragments (&lt;147 nucleotides)\n\nTSS enrichment score: Defined by ENCODE, this score measures the ratio of fragments centered at transcription start sites (TSS) compared to flanking regions. Poor experiments tend to have low TSS enrichment. You can calculate it per cell using TSSEnrichment(), with results stored in the TSS.enrichment metadata column.\nTotal fragments in peaks: A measure of sequencing depth. Cells with very few reads may need to be excluded, while those with excessively high reads might indicate doublets or artifacts.\nFraction of fragments in peaks: This is the proportion of fragments falling within ATAC-seq peaks. Cells with low values (&lt;15-20%) may indicate low quality or technical artifacts and should be removed.\nRatio of reads in blacklist regions: The ENCODE blacklist identifies regions prone to artefactual signal. Cells with a high fraction of reads mapping to these regions should be excluded. You can calculate this using FractionCountsInRegion() with the blacklist regions included in Signac.\n\nThese metrics can be obtained from Cell Ranger output or calculated for non-10x datasets using Signac.\n\n\n\nFigure 2.3: Assessing ATAC-seq library quality. The schematic shows transposition events near genes, with TSS regions (±2 kb) aligned across the genome. Reads are aggregated into a ‘meta-TSS’ to calculate per-base enrichment scores, plotted along the ±2 kb region. From: Grandi, et al. 2022. Nature Protocols.\n\n\n\n2.5.1 Bioanalyzer results and TSS region\n\n\n\nFigure 2.4: Bioanalyzer results and QC graph. d–f. Left: Bioanalyzer trace and gel. Middle: TSS enrichment plot. Right: fragment size distribution. From: Grandi, et al. 2022. Nature Protocols.\n\n\n\nd. Successful library (TSS score: 8.3) with clear nucleosomal periodicity.\ne. Successful library (TSS score: 8.8) with minimal nucleosomal periodicity.\nf. Unsuccessful library (TSS score: 1.7) with poor signal-to-background and low quality.\n\nLarge fragments (&gt;2,000 bp) appear in Bioanalyzer traces but not in sequencing data.\n\n\n2.5.2 Impact of Sample Type on Fragment Yield and Sequencing Quality\n\n\n\n\n\n\nNote\n\n\n\n\nScatterplot colored by point density: This plot shows the log10(unique nuclear fragments) vs TSS enrichment score and indicates the thresholds used with dotted lines.\nHistogram: These plot shows the fragment size distribution.\n\n\n\n\n\n\nBMMC QC graphs. From: ArchR tutorial\n\n\n\n\n\nPBMCs QC graphs. From: ArchR tutorial\n\n\n\n\n2.5.3 ATAC-seq insert sizes disclose nucleosome positions\nATAC-seq paired-end reads provided detailed insights into nucleosome packing and positioning. The fragment size distribution from human chromatin showed clear 200 bp periodicity, indicating fragments protected by multiple nucleosomes.\n\n\n\nFigure 2.5: ATAC-seq provides genome-wide information on chromatin compaction. Inset, log-transformed histogram shows clear periodicity persists to six nucleosomes. From: Buenrostro, et al. 2013. Nature.\n\n\nAgain in the code:\n\n\nCode\n# compute nucleosome signal score per cell\npbmc &lt;- NucleosomeSignal(object = pbmc)\n\n# compute TSS enrichment score per cell\npbmc &lt;- TSSEnrichment(object = pbmc)\n\n# add fraction of reads in peaks\npbmc$pct_reads_in_peaks &lt;- pbmc$peak_region_fragments / pbmc$passed_filters * 100\n\n# add blacklist ratio\npbmc$blacklist_ratio &lt;- FractionCountsInRegion(\n  object = pbmc, \n  assay = 'peaks',\n  regions = blacklist_hg38_unified\n)\n\n\nThe relationship between variables stored in the object metadata can be visualized using the DensityScatter() function. This can also be used to quickly find suitable cutoff values for different QC metrics by setting quantiles=TRUE:\n\n\nCode\nDensityScatter(pbmc, x = 'nCount_peaks', y = 'TSS.enrichment', log_x = TRUE, quantiles = TRUE)\n\n\n\n\n\nWe can also look at the fragment length periodicity for all the cells, and group by cells with high or low nucleosomal signal strength. You can see that cells that are outliers for the mononucleosomal / nucleosome-free ratio (based on the plots above) have different nucleosomal banding patterns. The remaining cells exhibit a pattern that is typical for a successful ATAC-seq experiment.\n\n\n2.5.4 Fragment size distribution\n\n\nCode\npbmc$nucleosome_group &lt;- ifelse(pbmc$nucleosome_signal &gt; 4, 'NS &gt; 4', 'NS &lt; 4')\nFragmentHistogram(object = pbmc, group.by = 'nucleosome_group')\n\n\n\n\n\nWe can plot the distribution of each QC metric separately using a violin plot:\n\n\nCode\nVlnPlot(\n  object = pbmc,\n  features = c('nCount_peaks', 'TSS.enrichment', 'blacklist_ratio', 'nucleosome_signal', 'pct_reads_in_peaks'),\n  pt.size = 0.1,\n  ncol = 5\n)\n\n\n\n\n\nFinally we remove cells that are outliers for these QC metrics. The exact QC thresholds used will need to be adjusted according to your dataset.\n\n\nCode\npbmc &lt;- subset(\n  x = pbmc,\n  subset = nCount_peaks &gt; 9000 & \n    nCount_peaks &lt; 100000 &\n    pct_reads_in_peaks &gt; 40 & # 40 % of the reads in the peaks\n    blacklist_ratio &lt; 0.01 & # more of 1 % of the reads mapeaning in blacklist ratio\n    nucleosome_signal &lt; 4 &\n    TSS.enrichment &gt; 4 # enrichment score\n)\npbmc\n\n\nAn object of class Seurat \n165376 features across 9649 samples within 1 assay \nActive assay: peaks (165376 features, 0 variable features)\n 2 layers present: counts, data\n\n\n\n\n            used   (Mb) gc trigger   (Mb)   max used   (Mb)\nNcells  14848910  793.1   44127650 2356.7   44127650 2356.7\nVcells 585590329 4467.7 1160573644 8854.5 1160573644 8854.5\n\n\n\n\n\n\n\n\nNote\n\n\n\nThis code filters the pbmc object to retain only high-quality cells based on specific criteria:\n\nnCount_peaks &gt; 9000: Keeps cells with more than 9000 reads in accessible regions.\nnCount_peaks &lt; 100000: Removes cells with an excessive number of reads, likely artifacts.\npct_reads_in_peaks &gt; 40: Retains cells where over 40% of reads fall within peaks (high-quality signal).\nblacklist_ratio &lt; 0.01: Excludes cells with more than 1% of reads in blacklisted regions (unreliable areas).\nnucleosome_signal &lt; 4: Keeps cells with low nucleosome signal, indicating accessible chromatin.\nTSS.enrichment &gt; 4: Retains cells with strong enrichment near transcription start sites (good data quality)."
  },
  {
    "objectID": "Section1_P13_intro.html#step-4-normalization-and-linear-dimensional-reduction-lsi",
    "href": "Section1_P13_intro.html#step-4-normalization-and-linear-dimensional-reduction-lsi",
    "title": "2  Practical 13: scATAC-seq Pre-Processing and Quality Control",
    "section": "2.6 📘 Step 4: Normalization and linear dimensional reduction (LSI)",
    "text": "2.6 📘 Step 4: Normalization and linear dimensional reduction (LSI)\n\n✅ Normalization: Signac performs term frequency-inverse document frecuency (TF-IDF) normalization, a two-step process that adjusts for differences in sequencing depth across cells and assigns higher values to rare peaks. Run term frequency inverse document frequency (TF-IDF) normalization on a matrix using RunTFIDF().\n\n\n\nFigure 2.6: TF-IDF(term frequency-inverse document frequency). From: Almarashy, et al. 2023. IEEE Access\n\n\n\n\n\n\n\n\n\nMore information\n\n\n\nTerm-Frequency Inverse-Document-Frequency (TF-IDF) is a technique commonly used in text processing, but in the context of scATAC-seq (single-cell Assay for Transposase-Accessible Chromatin sequencing), it is adapted to quantify and normalize chromatin accessibility signals across different cells.\nHere’s how this concept is applied in scATAC-seq:\n\nTerm Frequency (TF): In scATAC-seq, “terms” correspond to peaks of chromatin accessibility, and the “document” is an individual cell. “TF” measures how frequently a given accessible site (a peak) is present in a particular cell. Essentially, it represents the frequency of accessibility of a peak within a cell.\nInverse Document Frequency (IDF): “IDF” measures how common or rare a peak is across all cells. If a peak is present in many cells, its IDF will be low because it is not informative. Conversely, if a peak is present only in a few cells, its IDF will be high, reflecting its specificity.\nApplication in scATAC-seq: The purpose of using TF-IDF in scATAC-seq is to improve the representation of accessibility data. Given the high sparsity of single-cell data and the binary nature of accessibility (present or absent), applying TF-IDF helps to highlight peaks that are specific to certain cells. This enables better downstream analysis, such as dimensionality reduction or clustering, to capture biological differences between cells more accurately.\n\nSummary:\n\nTF measures how frequently a peak is accessible in a cell.\nIDF penalizes peaks that are accessible in many cells and gives more weight to those specific to fewer cells.\nTF-IDF in scATAC-seq is used to normalize the data, providing a better representation of chromatin accessibility for analyses like clustering or dimensionality reduction.\n\n\n\n\n\n\n✅ Feature selection: Unlike scRNA-seq, scATAC-seq has low dynamic range, making variable feature selection difficult.\n\nA) Instead, we can choose to use only the top n% of features (peaks) for dimensional reduction, or remove features present in less than n cells with the FindTopFeatures() function.\nB) Features used for dimensional reduction are automatically set as VariableFeatures() for the Seurat object by this function.\n\nNOTE: Even when using all features, similar results are observed, with faster runtimes when using a subset (e.g., the top 25% of peaks with min.cutoff = ‘q75’).\n\n\n✅ Dimension reduction: Singular Value Decomposition (SVD) is applied to the TF-IDF matrix using the selected peaks, generating a reduced dimensional representation similar to PCA in scRNA-seq analyses. Run singular value decomposition using RunSVD().\n\nThe combined steps of TF-IDF followed by SVD are known as latent semantic indexing (LSI), and were first introduced for the analysis of scATAC-seq data by Cusanovich et al. 2015.\n\n\nCode\npbmc &lt;- RunTFIDF(pbmc)\n\n\nPerforming TF-IDF normalization\n\n\nCode\npbmc &lt;- FindTopFeatures(pbmc, min.cutoff = 'q0')\npbmc &lt;- RunSVD(pbmc)\n\n\nRunning SVD\n\n\nScaling cell embeddings\n\n\n\n\n            used   (Mb) gc trigger   (Mb)   max used   (Mb)\nNcells  14857990  793.6   44127650 2356.7   44127650 2356.7\nVcells 546696312 4171.0 1160573644 8854.5 1160573644 8854.5\n\n\nThe first LSI component often captures sequencing depth (technical variation) rather than biological variation. If this is the case, the component should be removed from downstream analysis. We can assess the correlation between each LSI component and sequencing depth using the DepthCor() function:\n\n\nCode\nDepthCor(pbmc)\n\n\n\n\n\nHere we see there is a very strong correlation between the first LSI component and the total number of counts for the cell. We will perform downstream steps without this component as we don’t want to group cells together based on their total sequencing depth, but rather by their patterns of accessibility at cell-type-specific peaks.\n\n\n\n\n\n\nWhy did we eliminate component 1?\n\n\n\nComponent 1 is often removed in dimensionality reduction analyses because it may capture non-biological variability or technical artifacts rather than biologically relevant patterns. Removing it helps focus on components that better reflect the true biological structure of the data."
  },
  {
    "objectID": "Section1_P13_intro.html#step-5-non-linear-dimensional-reduction-and-clustering",
    "href": "Section1_P13_intro.html#step-5-non-linear-dimensional-reduction-and-clustering",
    "title": "2  Practical 13: scATAC-seq Pre-Processing and Quality Control",
    "section": "2.7 📙 Step 5: Non-linear dimensional reduction and clustering",
    "text": "2.7 📙 Step 5: Non-linear dimensional reduction and clustering\nNow that the cells are embedded in a low-dimensional space we can use methods commonly applied for the analysis of scRNA-seq data to perform graph-based clustering and non-linear dimension reduction for visualization. The functions RunUMAP(), FindNeighbors(), and FindClusters() all come from the Seurat package.\n\n2.7.1 Perform UMAP\nUniform Manifold Approximation and Projection (UMAP) is a dimension reduction technique that can be used for visualisation similarly to t-SNE, but also for general non-linear dimension reduction. It was proposed by McInnes et al. 2018.\nThis results in the creation of two new parameters UMAP 1 and UMAP 2. UMAP captures local relationships within a cluster as well as global relationships between distinct clusters.\n\n\n\n\n\n\nNote\n\n\n\nWhile PCA assumes that the variation of interest follows a specific distribution (generally normal), UMAP is more flexible and can learn complex, non-linear distributions directly from the data. This flexibility allows UMAP to better separate clusters, particularly when some clusters are more similar to each other. As a result, UMAP often excels at revealing nuanced relationships and improving cluster separation in datasets with intricate patterns.\nUMAP Visualization - bulk RNA-seq\nAlso you can extract the normalized counts data from the DESeqDataSet object and perform UMAP on the normalized data using umap() from the umap package.\n\n\n\n\nCode\npbmc &lt;- RunUMAP(object = pbmc, reduction = 'lsi', dims = 2:30)\n\n\n21:55:08 UMAP embedding parameters a = 0.9922 b = 1.112\n\n\n21:55:08 Read 9649 rows and found 29 numeric columns\n\n\n21:55:08 Using Annoy for neighbor search, n_neighbors = 30\n\n\n21:55:08 Building Annoy index with metric = cosine, n_trees = 50\n\n\n0%   10   20   30   40   50   60   70   80   90   100%\n\n\n[----|----|----|----|----|----|----|----|----|----|\n\n\n**************************************************|\n21:55:09 Writing NN index file to temp file C:\\Users\\ecoss\\AppData\\Local\\Temp\\RtmpovQGFE\\file4b7cfbb4fc9\n21:55:09 Searching Annoy index using 8 threads, search_k = 3000\n21:55:10 Annoy recall = 100%\n21:55:11 Commencing smooth kNN distance calibration using 8 threads with target n_neighbors = 30\n21:55:14 Initializing from normalized Laplacian + noise (using RSpectra)\n21:55:14 Commencing optimization for 500 epochs, with 384536 positive edges\n21:55:40 Optimization finished\n\n\nCode\npbmc &lt;- FindNeighbors(object = pbmc, reduction = 'lsi', dims = 2:30)\n\n\nComputing nearest neighbor graph\nComputing SNN\n\n\nCode\npbmc &lt;- FindClusters(object = pbmc, verbose = FALSE, algorithm = 3)\nDimPlot(object = pbmc, label = TRUE) + NoLegend()\n\n\n\n\n\nNow, we can cluster the cells to find groups that belong to the same cell types. It is possible to plot the results from the SVD, but these often are not informative. Instead, we use the UMAP algorithm, which shows a better separation between the cell types. If you are interested, the paper describing UMAP can be found here.\n\n\nCode\np1 &lt;- DimPlot(object = pbmc, label = TRUE, dims = c(2, 3), reduction = \"lsi\") +\n    NoLegend()  +\n    ggtitle('SVD')\n\np2 &lt;- DimPlot(object = pbmc, label = TRUE) +\n    NoLegend() +\n    ggtitle('UMAP')\n\np1 | p2\n\n\n\n\n\n\n\n            used   (Mb) gc trigger   (Mb)   max used   (Mb)\nNcells  14904626  796.0   44127650 2356.7   44127650 2356.7\nVcells 548217690 4182.6 1160573644 8854.5 1160573644 8854.5\n\n\n\n\nCode\nsessionInfo()\n\n\nR version 4.4.1 (2024-06-14 ucrt)\nPlatform: x86_64-w64-mingw32/x64\nRunning under: Windows 11 x64 (build 22631)\n\nMatrix products: default\n\n\nlocale:\n[1] LC_COLLATE=English_United States.utf8 \n[2] LC_CTYPE=English_United States.utf8   \n[3] LC_MONETARY=English_United States.utf8\n[4] LC_NUMERIC=C                          \n[5] LC_TIME=English_United States.utf8    \n\ntime zone: America/Mexico_City\ntzcode source: internal\n\nattached base packages:\n[1] stats4    stats     graphics  grDevices utils     datasets  methods  \n[8] base     \n\nother attached packages:\n [1] future_1.34.0             EnsDb.Hsapiens.v86_2.99.0\n [3] ensembldb_2.28.1          AnnotationFilter_1.28.0  \n [5] GenomicFeatures_1.56.0    AnnotationDbi_1.66.0     \n [7] Biobase_2.64.0            patchwork_1.2.0          \n [9] ggplot2_3.5.1             GenomicRanges_1.56.1     \n[11] GenomeInfoDb_1.40.1       IRanges_2.38.1           \n[13] S4Vectors_0.42.1          BiocGenerics_0.50.0      \n[15] Seurat_5.1.0              SeuratObject_5.0.2       \n[17] sp_2.1-4                  Signac_1.14.0            \n\nloaded via a namespace (and not attached):\n  [1] RcppAnnoy_0.0.22            splines_4.4.1              \n  [3] later_1.3.2                 BiocIO_1.14.0              \n  [5] bitops_1.0-8                tibble_3.2.1               \n  [7] polyclip_1.10-7             rpart_4.1.23               \n  [9] XML_3.99-0.17               fastDummies_1.7.4          \n [11] lifecycle_1.0.4             hdf5r_1.3.11               \n [13] globals_0.16.3              lattice_0.22-6             \n [15] MASS_7.3-60.2               backports_1.5.0            \n [17] magrittr_2.0.3              Hmisc_5.1-3                \n [19] plotly_4.10.4               rmarkdown_2.28             \n [21] yaml_2.3.10                 httpuv_1.6.15              \n [23] sctransform_0.4.1           spam_2.10-0                \n [25] spatstat.sparse_3.1-0       reticulate_1.39.0          \n [27] cowplot_1.1.3               pbapply_1.7-2              \n [29] DBI_1.2.3                   RColorBrewer_1.1-3         \n [31] abind_1.4-5                 zlibbioc_1.50.0            \n [33] Rtsne_0.17                  purrr_1.0.2                \n [35] biovizBase_1.52.0           RCurl_1.98-1.16            \n [37] nnet_7.3-19                 VariantAnnotation_1.50.0   \n [39] GenomeInfoDbData_1.2.12     ggrepel_0.9.5              \n [41] irlba_2.3.5.1               listenv_0.9.1              \n [43] spatstat.utils_3.1-0        goftest_1.2-3              \n [45] RSpectra_0.16-2             spatstat.random_3.3-1      \n [47] fitdistrplus_1.2-1          parallelly_1.38.0          \n [49] leiden_0.4.3.1              codetools_0.2-20           \n [51] DelayedArray_0.30.1         RcppRoll_0.3.1             \n [53] tidyselect_1.2.1            farver_2.1.2               \n [55] UCSC.utils_1.0.0            base64enc_0.1-3            \n [57] matrixStats_1.4.0           spatstat.explore_3.3-2     \n [59] GenomicAlignments_1.40.0    jsonlite_1.8.8             \n [61] Formula_1.2-5               progressr_0.14.0           \n [63] ggridges_0.5.6              survival_3.6-4             \n [65] tools_4.4.1                 ica_1.0-3                  \n [67] Rcpp_1.0.13                 glue_1.7.0                 \n [69] SparseArray_1.4.8           gridExtra_2.3              \n [71] xfun_0.45                   MatrixGenerics_1.16.0      \n [73] dplyr_1.1.4                 withr_3.0.1                \n [75] fastmap_1.2.0               fansi_1.0.6                \n [77] digest_0.6.36               R6_2.5.1                   \n [79] mime_0.12                   colorspace_2.1-1           \n [81] scattermore_1.2             tensor_1.5                 \n [83] dichromat_2.0-0.1           spatstat.data_3.1-2        \n [85] RSQLite_2.3.7               utf8_1.2.4                 \n [87] tidyr_1.3.1                 generics_0.1.3             \n [89] data.table_1.16.0           rtracklayer_1.64.0         \n [91] httr_1.4.7                  htmlwidgets_1.6.4          \n [93] S4Arrays_1.4.1              uwot_0.2.2                 \n [95] pkgconfig_2.0.3             gtable_0.3.5               \n [97] blob_1.2.4                  lmtest_0.9-40              \n [99] XVector_0.44.0              htmltools_0.5.8.1          \n[101] dotCall64_1.1-1             ProtGenerics_1.36.0        \n[103] scales_1.3.0                png_0.1-8                  \n[105] spatstat.univar_3.0-1       knitr_1.48                 \n[107] rstudioapi_0.16.0           reshape2_1.4.4             \n[109] rjson_0.2.22                checkmate_2.3.2            \n[111] nlme_3.1-164                curl_5.2.2                 \n[113] zoo_1.8-12                  cachem_1.1.0               \n[115] stringr_1.5.1               KernSmooth_2.23-24         \n[117] vipor_0.4.7                 parallel_4.4.1             \n[119] miniUI_0.1.1.1              foreign_0.8-86             \n[121] ggrastr_1.0.2               restfulr_0.0.15            \n[123] pillar_1.9.0                grid_4.4.1                 \n[125] vctrs_0.6.5                 RANN_2.6.2                 \n[127] promises_1.3.0              xtable_1.8-4               \n[129] cluster_2.1.6               beeswarm_0.4.0             \n[131] htmlTable_2.4.3             evaluate_0.24.0            \n[133] cli_3.6.2                   compiler_4.4.1             \n[135] Rsamtools_2.20.0            rlang_1.1.3                \n[137] crayon_1.5.3                future.apply_1.11.2        \n[139] labeling_0.4.3              ggbeeswarm_0.7.2           \n[141] plyr_1.8.9                  stringi_1.8.4              \n[143] viridisLite_0.4.2           deldir_2.0-4               \n[145] BiocParallel_1.38.0         munsell_0.5.1              \n[147] Biostrings_2.72.1           lazyeval_0.2.2             \n[149] spatstat.geom_3.3-2         Matrix_1.7-0               \n[151] BSgenome_1.72.0             RcppHNSW_0.6.0             \n[153] bit64_4.0.5                 KEGGREST_1.44.1            \n[155] shiny_1.9.1                 SummarizedExperiment_1.34.0\n[157] ROCR_1.0-11                 igraph_2.0.3               \n[159] memoise_2.0.1               fastmatch_1.1-4            \n[161] bit_4.0.5"
  },
  {
    "objectID": "Section1_P13_intro.html#references",
    "href": "Section1_P13_intro.html#references",
    "title": "2  Practical 13: scATAC-seq Pre-Processing and Quality Control",
    "section": "2.8 References",
    "text": "2.8 References\nhttps://www.jpt.com/support-contact/resources/pbmc/\nData structures and object interaction\nJoint RNA and ATAC analysis: 10x multiomic.\nhttps://stuartlab.org/signac/1.2.0/articles/install\nhttps://stuartlab.org/signac/articles/pbmc_multiomic\nhttps://support.10xgenomics.com/single-cell-atac/software/pipelines/latest/output/metrics\nhttps://www.nature.com/articles/nmeth.2688\nAnalyzing adult mouse brain scATAC-seq\nRaton https://rpubs.com/kshridevi/1176302\nhttps://ieeexplore.ieee.org/document/10343156\nhttps://stuartlab.org/signac/articles/pbmc_vignette\nhttps://arxiv.org/abs/1802.03426\nhttps://alexslemonade.github.io/refinebio-examples/03-rnaseq/dimension-reduction_rnaseq_02_umap.html#4_UMAP_Visualization_-_RNA-seq\nUMAP Github"
  },
  {
    "objectID": "Section2_P15_retos.html#section",
    "href": "Section2_P15_retos.html#section",
    "title": "7  Exercises",
    "section": "7.1 ",
    "text": "7.1"
  },
  {
    "objectID": "Section3_P16_intro.html",
    "href": "Section3_P16_intro.html",
    "title": "8  Practical 16: Motif analysis with Signac",
    "section": "",
    "text": "8.0.1 Motif analysis\nWe can also analyze motif occurrence in the peaks, to see how this varies between the different cell types.\n\n\n8.0.2 The Motif Class\nThe Motif class stores information needed for DNA sequence motif analysis, and has the following slots:\n\ndata: a sparse feature by motif matrix, where entries are 1 if the feature contains the motif, and 0 otherwise\npwm: A named list of position weight or position frequency matrices\nmotif.names: a list of motif IDs and their common names\npositions: A GRangesList object containing the exact positions of each motif\nmeta.data: Additional information about the motifs\n\nMany of these slots are optional and do not need to be filled, but are only required when running certain functions. For example, the positions slot will be needed if running TF footprinting. For more details on the Motif class.\n\nIdentifying enriched motifs\nFirst, we will look at motifs that are enriched in a set of peaks, e.g. in peaks that show differential accessibility between two cell types. Do you notice anything particular about these motifs?\nhttps://nbis-workshop-epigenomics.readthedocs.io/en/latest/content/tutorials/scAtacSeq/lab-sc_atac_seq.html"
  },
  {
    "objectID": "Section3_P16_retos.html#section",
    "href": "Section3_P16_retos.html#section",
    "title": "9  Exercises",
    "section": "9.1 ",
    "text": "9.1"
  },
  {
    "objectID": "Section2_P14_intro.html#go-enrichment-analysis-with-clusterprofiler",
    "href": "Section2_P14_intro.html#go-enrichment-analysis-with-clusterprofiler",
    "title": "4  Practical 14: scATAC-seq Downstream",
    "section": "4.5 GO enrichment analysis with clusterProfiler",
    "text": "4.5 GO enrichment analysis with clusterProfiler\nWe could follow up with this result by doing gene ontology enrichment analysis on the gene sets returned by ClosestFeature(),and there are many R packages that can do this (see theGOstats or clusterProfiler packages for example).\n\n\nCode\nlibrary(clusterProfiler)\nlibrary(org.Hs.eg.db)\nlibrary(enrichplot)\n\n\n\n\nCode\ncd4naive_ego &lt;- enrichGO(gene = closest_genes_cd4naive$gene_id, # like DEG\n                keyType = \"ENSEMBL\", \n                OrgDb = org.Hs.eg.db, # organism\n                ont = \"BP\", # Biological process\n                pAdjustMethod = \"BH\", # Benjamini-Hochberg (BH)\n                pvalueCutoff = 0.05,\n                qvalueCutoff = 0.05,\n                readable = TRUE) # Convert the gene identifiers (ENSEMBL) to readable gene names.\n\nbarplot(cd4naive_ego,showCategory = 20)\n\n\n\n\n\n\n\nCode\ncd14mono_ego &lt;- enrichGO(gene = closest_genes_cd14mono$gene_id,\n                keyType = \"ENSEMBL\",\n                OrgDb = org.Hs.eg.db,\n                ont = \"BP\",\n                pAdjustMethod = \"BH\",\n                pvalueCutoff = 0.05,\n                qvalueCutoff = 0.05,\n                readable = TRUE)\n\nbarplot(cd14mono_ego,showCategory = 20)"
  },
  {
    "objectID": "Section2_P15_intro.html",
    "href": "Section2_P15_intro.html",
    "title": "6  Practical 15: Analyses and scRNA-seq Integration",
    "section": "",
    "text": "7 Joint RNA and ATAC analysis: 10x multiomic\nhttps://stuartlab.org/signac/articles/pbmc_multiomic"
  },
  {
    "objectID": "Section2_P15_intro.html#dataset-overview",
    "href": "Section2_P15_intro.html#dataset-overview",
    "title": "6  Practical 15: Analyses and scRNA-seq Integration",
    "section": "6.1 Dataset overview",
    "text": "6.1 Dataset overview"
  },
  {
    "objectID": "Section2_P15_intro.html#merging-objects",
    "href": "Section2_P15_intro.html#merging-objects",
    "title": "6  Practical 15: Analyses and scRNA-seq Integration",
    "section": "6.2 Merging objects",
    "text": "6.2 Merging objects\ndiferentes numeros de celulas\nhttps://stuartlab.org/signac/articles/merging"
  },
  {
    "objectID": "Section2_P15_intro.html#scatac-seq-data-integration-batch-effect",
    "href": "Section2_P15_intro.html#scatac-seq-data-integration-batch-effect",
    "title": "6  Practical 15: Analyses and scRNA-seq Integration",
    "section": "6.3 scATAC-seq data integration / batch effect",
    "text": "6.3 scATAC-seq data integration / batch effect\nhttps://stuartlab.org/signac/articles/pbmc_multiomic\nY si tengo muchos datos\nhttps://stuartlab.org/signac/articles/integrate_atac"
  },
  {
    "objectID": "Section2_P15_intro.html#option-b-dictionary-learning-for-cross-modality-integration",
    "href": "Section2_P15_intro.html#option-b-dictionary-learning-for-cross-modality-integration",
    "title": "6  Practical 15: Analyses and scRNA-seq Integration",
    "section": "6.4 Option B: Dictionary Learning for cross-modality integration",
    "text": "6.4 Option B: Dictionary Learning for cross-modality integration\n\n\n\nBroad schematic of the bridge integration workflow. From: Seurat v5, Hao et al, 2023. Nature biotechnology\n\n\n\n6.4.1 Step 1: Load the bridge, query, and reference datasets (each modality individually)\nInput files:\n\n10x multiome dataset: Consisting of ~12,000 PBMC from a helthy donor. The dataset measures scRNA-seq and scATAC-seq in the same cell, and is available for download from 10x Genomics here.\nscATAC-seq Query: Represents ~10,000 PBMC from a healthy donor, and is available for download here.\nReference from Azimuth: We load the reference (download here) from our recent paper. This reference is stored as an h5Seurat file, a format that enables on-disk storage of multimodal Seurat objects (more details on h5Seurat and SeuratDisk can be found here).\n\n\n\n6.4.2 Azimuth annotation\nhttps://satijalab.github.io/azimuth/articles/run_azimuth_tutorial.html\n\n\n\n\n\n\nView data download code\n\n\n\nTotal 2.7 Gb\n# 10x multiome dataset \n# Raw data \nwget https://cf.10xgenomics.com/samples/cell-arc/2.0.0/pbmc_granulocyte_sorted_10k/pbmc_granulocyte_sorted_10k_filtered_feature_bc_matrix.h5 \n# fragments file \nwget https://cf.10xgenomics.com/samples/cell-arc/2.0.0/pbmc_granulocyte_sorted_10k/pbmc_granulocyte_sorted_10k_atac_fragments.tsv.gz # fragments index \nwget https://cf.10xgenomics.com/samples/cell-arc/2.0.0/pbmc_granulocyte_sorted_10k/pbmc_granulocyte_sorted_10k_atac_fragments.tsv.gz.tbi  \n\n# scATAC-seq Query (Total 2.7 Gb) \n# Raw data  \nwget https://cf.10xgenomics.com/samples/cell-atac/2.1.0/10k_pbmc_ATACv2_nextgem_Chromium_Controller/10k_pbmc_ATACv2_nextgem_Chromium_Controller_filtered_peak_bc_matrix.h5 # metadata \nwget https://cf.10xgenomics.com/samples/cell-atac/2.1.0/10k_pbmc_ATACv2_nextgem_Chromium_Controller/10k_pbmc_ATACv2_nextgem_Chromium_Controller_singlecell.csv \n# fragments file \nwget https://cf.10xgenomics.com/samples/cell-atac/2.1.0/10k_pbmc_ATACv2_nextgem_Chromium_Controller/10k_pbmc_ATACv2_nextgem_Chromium_Controller_fragments.tsv.gz \n# fragments index \nwget https://cf.10xgenomics.com/samples/cell-atac/2.1.0/10k_pbmc_ATACv2_nextgem_Chromium_Controller/10k_pbmc_ATACv2_nextgem_Chromium_Controller_fragments.tsv.gz.tbi  \n\n# Azimuth Reference \nwget https://atlas.fredhutch.org/data/nygc/multimodal/pbmc_multimodal.h5seurat\n\n\n\n\n6.4.3 Step 2: Annotate scATAC-seq cells via label transfer\nAfter identifying anchors, we can transfer annotations from the scRNA-seq dataset into the scATAC-seq cells. The annotations are stored in the seurat_annotations field, and are provided as input to the refdata parameter. The output will contain a matrix with predictions and confidence scores for each ATAC-seq cell.\n\n\nCode\npredicted.labels &lt;- TransferData(\n  anchorset = transfer.anchors,\n  refdata = pbmc_rna$celltype, # pbmc.rna$seurat_annotations\n  weight.reduction = pbmc[['lsi']],\n  dims = 2:30\n)\npbmc &lt;- AddMetaData(object = pbmc, metadata = predicted.labels)\n\n\nplot\n\n\nCode\nplot1 &lt;- DimPlot(\n  object = pbmc_rna,\n  group.by = 'celltype',\n  label = TRUE,\n  repel = TRUE) + NoLegend() + ggtitle('scRNA-seq')\n\nplot2 &lt;- DimPlot(\n  object = pbmc,\n  group.by = 'predicted.id',\n  label = TRUE,\n  repel = TRUE) + NoLegend() + ggtitle('scATAC-seq')\n\nplot1 + plot2\n\n\nYou can see that the scRNA-based classifications are consistent with the UMAP visualization that was computed using the scATAC-seq data. Notice, however, that a small population of cells are predicted to be platelets in the scATAC-seq dataset. This is unexpected as platelets are not nucleated and should not be detected by scATAC-seq. It is possible that the cells predicted to be platelets could instead be the platelet-precursors megakaryocytes, which largely reside in the bone marrow but are rarely found in the peripheral blood of healthy patients, such as the individual these PBMCs were drawn from. Given the already extreme rarity of megakaryocytes within normal bone marrow (&lt; 0.1%), this scenario seems unlikely.\nCheck cell types\nPlotting the prediction score for the cells assigned to each label reveals that the “platelet” cells received relatively low scores (&lt; 0.8), indicating a low confidence in the assigned cell identity. In most cases, the next most likely cell identity predicted for these cells was “CD4 naive”.\n\n\nCode\nVlnPlot(pbmc, 'prediction.score.max', group.by = 'predicted.id')"
  },
  {
    "objectID": "Section2_P15_intro.html#analysis-of-multi-omics-data",
    "href": "Section2_P15_intro.html#analysis-of-multi-omics-data",
    "title": "6  Practical 15: Analyses and scRNA-seq Integration",
    "section": "6.5 Analysis of multi-omics data",
    "text": "6.5 Analysis of multi-omics data\nRecently, single cell multi-omics methods that run several assays on the same cells have become available. One such method is Chromium Single Cell Multiome from 10X genomics, which simultaneously measures gene expression (RNA-seq) and chromatin accessibility (ATAC-seq) in the same nuclei. This makes it possible to identify cell types and states based on both gene expression and accessibility. It also makes it easy to use external gene expression data to annotate your cells, and at the same time study the chromatin accessibility in the cells. In this exercise, we will look at a public data set downloaded from 10X genomics, from embyomic mouse brain. You will load both the RNA-seq and ATAC-seq data into the same Seurat object and do some simple pre-processing as was done for the ATAC-seq data above. Then, you will run joint clustering and visuaization of the combined data set, and finally use the gene expression measurements together with a public data set to annotate the cells.\nhttps://nbis-workshop-epigenomics.readthedocs.io/en/latest/content/tutorials/scAtacSeq/lab-sc_atac_seq.html"
  },
  {
    "objectID": "Section2_P15_intro.html#bridge-integration",
    "href": "Section2_P15_intro.html#bridge-integration",
    "title": "6  Practical 15: Analyses and scRNA-seq Integration",
    "section": "7.1 Bridge integration",
    "text": "7.1 Bridge integration"
  },
  {
    "objectID": "Section3_P17_intro.html",
    "href": "Section3_P17_intro.html",
    "title": "10  Practical 17: Exploring results (graphs)",
    "section": "",
    "text": "https://www.nature.com/articles/nature14590\n\n11 CITE-seq and scATAC-seq\nhttps://broadinstitute.github.io/2019_scWorkshop/cite-seq-and-scatac-seq.html"
  },
  {
    "objectID": "Section3_P17_retos.html#section",
    "href": "Section3_P17_retos.html#section",
    "title": "11  Exercises",
    "section": "11.1 ",
    "text": "11.1"
  },
  {
    "objectID": "Section3_P18_others.html",
    "href": "Section3_P18_others.html",
    "title": "12  Other tools used in scATAC-seq",
    "section": "",
    "text": "Overview of the scATAC-seq analysis steps."
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "13  Summary",
    "section": "",
    "text": "This is a callout block of the type “note”.\n\n\n\n\n\n\nCaution\n\n\n\n\n\nCallouts can be collapsible.\n\n\n\n\n\n\n\n\n\nMy heading\n\n\n\nThe first heading used within the callout is used as the callout heading.\n\n\n\n\n\n\n\n\nTip\n\n\n\nThe icon can also be hidden, like this.\n\n\n\n\n\n\n\n\nThis is a simpler callout, without specifying the “type”."
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "https://www.nature.com/articles/s43586-020-00008-9\nhttps://www.nature.com/articles/s43586-020-00008-9\nhttps://www.nature.com/articles/s43586-020-00008-9\nhttps://www.nature.com/articles/s43586-020-00008-9\n\n\nhttps://www.nature.com/articles/s41596-022-00692-9\n\nsessionInfo()"
  },
  {
    "objectID": "Section1_intro.html#what-are-atac-seq-and-scatac-seq",
    "href": "Section1_intro.html#what-are-atac-seq-and-scatac-seq",
    "title": "1  Fundamentals of Single Cell ATAC-seq (scATAC-seq) analysis",
    "section": "1.1 What are ATAC-seq and scATAC-seq?",
    "text": "1.1 What are ATAC-seq and scATAC-seq?\nATAC-seq (Assay for Transposase-Accessible Chromatin with high-throughput sequencing) is a widely used, cost-effective method for genome-wide profiling of chromatin accessibility, utilizing the hyperactive Tn5 transposase for NGS library preparation.\nSingle-cell ATAC-seq (scATAC-seq) extends this approach to single cells, enabling the study of chromatin accessibility in specific cell types within heterogeneous tissue samples."
  },
  {
    "objectID": "Section1_intro.html#what-is-chromatin-accesibility",
    "href": "Section1_intro.html#what-is-chromatin-accesibility",
    "title": "1  Fundamentals of Single Cell ATAC-seq (scATAC-seq) analysis",
    "section": "1.2 What is Chromatin accesibility?",
    "text": "1.2 What is Chromatin accesibility?\nChromatin accessibility refers to the degree of physical compaction of chromatin, a structure made up of DNA and proteins, primarily histones, transcription factors (TFs), chromatin-modifying enzymes, and remodeling complexes. While eukaryotic genomes are generally organized into nucleosomes (with ~147 bp of DNA wrapped around a histone octamer), nucleosome positioning varies across tissues and cell types. Regions like enhancers and promoters (cis-regulatory elements), which interact with transcriptional regulators, tend to be nucleosome-depleted, making the chromatin more accessible.\nGenome-wide profiling of chromatin accessibility is a powerful method for identifying potential regulatory elements specific to cell types or states.\n\n\n\nFigure 1.1: Chromatin accessibility profiling in bulk and at single-cell level reveals putative regulatory regions. H3K27ac, histone H3 acetylated at lysine 27; Pol II, polymerase II; TSS, transcription start site; TFs, transcription factors. From: Minnoye, et al. 2021. Nat Rev Methods Primers.rimers."
  },
  {
    "objectID": "Section1_intro.html#how-does-atac-seq-work",
    "href": "Section1_intro.html#how-does-atac-seq-work",
    "title": "1  Fundamentals of Single Cell ATAC-seq (scATAC-seq) analysis",
    "section": "1.3 How does ATAC-Seq work?",
    "text": "1.3 How does ATAC-Seq work?\nATAC-seq identifies open, accessible regions of chromatin across the genome. Here’s a step-by-step breakdown of how it works:\n\nCell/Nuclei Isolation: Cells or nuclei are isolated, ensuring the chromatin structure remains intact, along with DNA-binding proteins such as nucleosomes and transcription factors.\nTn5 Transposase Treatment: The chromatin is exposed to a hyperactive Tn5 transposase enzyme, which simultaneously cuts the DNA and inserts special sequences called adapters.\nAdapter Insertion: These adapters (i5/P5 and i7/P7) are added at both ends of the DNA fragments. Only fragments that receive both adapters can be amplified in the next steps.\nLibrary Amplification: The adapter-tagged fragments are amplified through PCR, creating a library of accessible chromatin regions.\nHigh-Throughput Sequencing: The amplified fragments are sequenced using next-generation sequencing (NGS) technologies.\nData Analysis: Sequencing reads are mapped back to the genome. Regions with high concentrations of Tn5 activity (where many fragments originate) are identified as “peaks”, indicating open, accessible chromatin regions, which often correspond to regulatory elements such as enhancers and promoters.\n\n\n\n\nFigure 1.2: Schematic of ATAC-seq Transposition and Library Preparation. A) Overview of ATAC-seq steps: nuclei isolation, Tn5 transposase-mediated chromatin fragmentation and adapter insertion, PCR amplification, and high-throughput sequencing. C) Toy example of hypothetical ATAC-seq data: both cell types X and Y show peaks at gene A’s promoter, but cell type X has an additional peak at an upstream enhancer, driving higher expression. From: Grandi, et al. 2022. Nature Protocols and Footprinting with ArchR. From: ArchR tutorial.\n\n\nIn a hypothetical ATAC-seq dataset, cell types X and Y both show peaks at the promoter of gene A, indicating shared accessibility. However, cell type X has an additional peak at an upstream enhancer, which drives higher gene A expression. This cell-type-specific peak is due to transcription factor B binding to the enhancer, a feature absent in cell type Y. ATAC-seq data also helps reveal transcription factor binding motifs, such as “GATAA” in this example, linked to differential accessibility.\n\n\n\nFootprinting with ArchR. From: ArchR tutorial\n\n\n\n\n\n\n\n\nNote\n\n\n\nATAC-seq uses a hyperactive Tn5 transposase, engineered with three mutations to boost its activity. This enzyme simultaneously cuts and tags accessible chromatin regions, similar to how DNase I identifies DNase hypersensitive sites (DHSs). The tagged DNA fragments are then amplified and sequenced, offering a powerful method to map open chromatin."
  },
  {
    "objectID": "Section1_intro.html#workflow",
    "href": "Section1_intro.html#workflow",
    "title": "1  Fundamentals of Single Cell ATAC-seq (scATAC-seq) analysis",
    "section": "1.4 Workflow",
    "text": "1.4 Workflow\nIn the following sections, we will walk you through a standard workflow for analyzing scATAC-seq data. The accompanying summary figure outlines the different stages of the analysis and emphasizes the distinctions between commonly used frameworks. We’ll start by explaining the concepts of quality control and dimensionality reduction using R.\n\n\n\nFigure 1.3: Data analysis workflow. From: Heumos, et al. 2023. Nature review genetics"
  },
  {
    "objectID": "Section1_intro.html#data-structure",
    "href": "Section1_intro.html#data-structure",
    "title": "1  Fundamentals of Single Cell ATAC-seq (scATAC-seq) analysis",
    "section": "1.5 Data Structure",
    "text": "1.5 Data Structure\n\n1.5.1 The ChromatinAssay Class\nscATAC-seq data is stored in a ChromatinAssay object, which includes slots for additional information about motifs, gene annotations, and genome data. From this object, we create the main Seurat object for our analyses.\nThe ChromatinAssay class extends the standard Seurat Assay class and adds several additional slots for data useful for the analysis of single-cell chromatin datasets. The class includes all the slots present in a standard Seurat Assay, with the following additional slots:\n\nranges: A GRanges object containing the genomic coordinates of each feature in the data matrix.\nmotifs: A Motif object\nfragments: A list of Fragment objects\nseqinfo: A Seqinfo object containing information about the genome that the data was mapped to\nannotation: A GRanges object containing gene annotations\nbias: A vector containing Tn5 integration bias information (the frequency of Tn5 integration at different hexamers)\npositionEnrichment: A named list of matrices containing positional enrichment scores for Tn5 integration (for example, enrichment at the TSS or at different TF motifs)\nlinks: A GRanges object describing linked genomic positions, such as co-accessible sites or enhancer-gene regulatory relationships.\n\nWe can use the granges() function on a Seurat object with an active ChromatinAssay experiment to view the chromosomal regions associated with each gene. For more details on the ChromatinAssay class, refer to the object interaction vignette and check this example.\n\n\n\nFigure 1.4: Design of a custom Assay for single-cell chromatin data. We designed a specialized ChromatinAssay class with the capacity to store data required for analysis of single-cell chromatin datasets. From: [Stuart, et al. 2021. Nat Methods](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC9255697/)\n\n\n\n\n1.5.2 The Fragment Class\nThe Fragment class is designed for storing and interacting with a fragment file commonly used for single-cell chromatin data. It contains the path to an indexed fragment file on disk, a MD5 hash for the fragment file and the fragment file index, and a vector of cell names contained in the fragment file. Importantly, this is a named vector where the elements of the vector are the cell names as they appear in the fragment file, and the name of each element is the cell name as it appears in the ChromatinAssay object storing the Fragment object. This allows a mapping of cell names on disk to cell names in R, and avoids the need to alter fragment files on disk. This path can also be a remote file accessible by http or ftp. For more details on the Fragment class.\n\nColumn definitions from Single Cell ATAC.\n\n\nColumn Number\nName\nDescription\n\n\n\n\n1\nchrom\nReference genome chromosome of fragment.\n\n\n2\nchromStart\nAdjusted start position of fragment on chromosome.\n\n\n3\nchromEnd\nAdjusted end position of fragment on chromosome. The end position is exclusive, so represents the position immediately following the fragment interval.\n\n\n4\nbarcode\nThe 10x cell barcode of this fragment. This corresponds to the CB tag attached to the corresponding BAM file records for this fragment.\n\n\n5\nreadSupport\nThe total number of read pairs associated with this fragment. This includes the read pair marked unique and all duplicate read pairs.\n\n\n\nExample:\n  chrom  start    end            barcode readCount \n1  chr1  10245  10302 AAAGATGAGGCTAAAT-1         1\n2  chr1  55313  55699 AAACTCGTCTGGCACG-1         2 \n3  chr1  56455  56658 AAACTCGTCTGGCACG-1         1\n4  chr1  60687  60726 AAACTGCAGTCTGTGT-1         1\n5  chr1 235723 235936 AAACTGCTCCTATCCG-1         1"
  },
  {
    "objectID": "Section1_intro.html#references",
    "href": "Section1_intro.html#references",
    "title": "1  Fundamentals of Single Cell ATAC-seq (scATAC-seq) analysis",
    "section": "1.6 References",
    "text": "1.6 References\nhttps://www.nature.com/articles/s41596-022-00692-9\nhttps://www.nature.com/articles/s43586-020-00008-9\nhttps://www.sc-best-practices.org/chromatin_accessibility/introduction.html\nhttps://www.nature.com/articles/s41576-023-00586-w\nhttps://www.archrproject.com/bookdown/footprinting-with-archr.html\nhttps://support.10xgenomics.com/single-cell-atac/software/pipelines/latest/output/matrices\nCalling peaks\nIssue 560\nSeuratv4\nImport data"
  }
]