[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Analyzing PBMCs Single Cell ATAC- Seq (scATAC-Seq) and Multiome data: Theory and practice",
    "section": "",
    "text": "Global information\n\n\nAbout the course üìåAgenda üìÜAbout datasets üìñAbout packages üìö\n\n\nThis course is part of the Workshop Single Cell Genomic Approaches to Study the Immune System - Latin America & the Caribbean (9-11 Novembrer 2024), Universidad CES, Medell√≠n, Colombia.\n\nDate: 11 November 2024\nCourse duration: 5 hours\n\nCourse Instructors:\n\nDiego Ramirez - Bachelor in Genomic Sciences, Escuela Nacional de Estudios Superiores Unidad Juriquilla UNAM (ENES Juriquilla), Mexico.\nEvelia Lorena Coss-Navarrete - PostDoc, International Laboratory for Human Genome Research (LIIGH)-UNAM, Mexico. Contact: Web page\n\nAbstract:\nSingle-cell transposase-accessible chromatin sequencing (scATAC-seq) represents the most innovative technology for examining genome-wide regulatory landscapes in single cells. For this tutorial, we will be analyzing a single-cell ATAC-seq dataset of human peripheral blood mononuclear cells (PBMCs) provided by 10x Genomics. We will run bridge integration for PBMC with the newly released Azimuth ATAC workflow. In this workshop we will review the existing statistical tools for analyzing scATAC-seq data, how to document your analysis and review some tools for interpreting results.\nLearning objectives:\n\nFundamentals of Single Cell ATAC-seq (scATAC-seq) and Multiome analysis.\nSingle-Cell ATAC-seq Pre-Processing and Quality Control.\nLoading in and pre-processing the scATAC-seq, multiome, and scRNA-seq reference datasets.\nMapping the scATAC-seq dataset via bridge integration.\nExploring and assessing the resulting annotations.\nMotif analysis with Signac\n\nCiting and Re-using Course Material\nThe course data are free to reuse and adapt with appropriate attribution. All course data in these repositories are licensed under the¬†Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0).\n\n\n\n\n\n\n\n\n\n\nSubject\nTime\nInstructor\n\n\n\n\nüî∑ Section 1 - Introduction and Quality control (45 min) - (9:45-10:30 h)\n\n\n\n\n\nFundamentals of Single Cell ATAC-seq (scATAC-seq) analysis\n\n15 min (9:45- 10:00)\nEvelia Coss\n\n\n\nPractical 13: scATAC-seq Pre-Processing and Quality Control\n\n30 min\n(10:00-10:30)\nEvelia Coss\n\n\n‚òï Coffee break (30 min) - (10:30-11:00 h) ‚òï\n\n\n\n\nüî∑¬†Section 2 - scATAC-seq Downstream analysis (2 h) - (11:00-13:00 h)\n\n\n\n\n\nPractical 14: scATAC-seq Downstream\n\n1 h\n(11:00-12:00)\nDiego Ramirez\n\n\n\nPractical 15: Analyses and scRNA-seq Integration\n\n1 h\n(12:00-13:00)\nDiego Ramirez\n\n\nüçñüçó Lunch (1 h) - (13:00 - 14:00) üçñüçó\n\n\n\n\nüî∑¬†Section 3 - Motif analysis and results (14:00 - 15:30 h)\n\n\n\n\n\nPractical 16: Motif analysis with Signac\n\n30 min\n(14:00-14:30)\nDiego Ramirez\n\n\n\nPractical 17: Exploring results (graphs)\n\n30 min (14:30-15:00)\nDiego Ramirez\n\n\n\nOther tools used in scATAC-seq\n\n30 min (15:00-15:30)\nEvelia Coss and Diego Ramirez\n\n\n\n\n\nüî∑ Section 1 - Practical 13\nFor this tutorial, we will be analyzing a single-cell ATAC-seq dataset of human peripheral blood mononuclear cells (PBMCs) provided by 10x Genomics (Next GEM v1.1). The following files are used in this course, all available through the 10x Genomics website:\n\nThe Raw data: Filtered peak barcode matrix.\nThe Metadata: Per-barcode fragment counts & metrics.\nThe fragments file: Barcoded and aligned fragment file.\nThe fragments file index: Fragments file index.\n\nGoogle Colab - Practical 13\nüî∑ Section 2 - Practical 14\nFor this tutorial, we will use the results from Practical 13, where we analyzed a single-cell ATAC-seq dataset of human peripheral blood mononuclear cells (PBMCs). Additionally, we will use the pre-processed Seurat object available here.\n\nDownload the file previously generated in the previous practice (Practical 13). If you did not download it (‚Äúpbmc.RData‚Äù) then download it by clicking¬†here¬†and upload the file to google colab.\n\nGoogle Colab - Practical 14\nüî∑ Section 2 - Practical 15\nFor this tutorial, we will be analyzing a single-cell ATAC-seq dataset of human peripheral blood mononuclear cells (PBMCs) (3K) provided by 10x Genomics (Cell Ranger ARC 2.0.0). The following files are used in this course, all available through the 10x Genomics website:\n\nThe Raw data: Filtered peak barcode matrix.\nThe fragments file: Barcoded and aligned fragment file.\nThe fragments file index: Fragments file index.\n\nGoogle Colab - Practical 15\nüî∑ Section 3 - Practical 16\nFor this tutorial, we will be analyzing a single-cell ATAC-seq dataset of human peripheral blood mononuclear cells (PBMCs) provided by 10x Genomics (Next GEM v1.1). The following files are used in this course, all available through the 10x Genomics website:\n\nThe Raw data: Filtered peak barcode matrix.\nThe Metadata: Per-barcode fragment counts & metrics.\nThe fragments file: Barcoded and aligned fragment file.\nThe fragments file index: Fragments file index.\n\nGoogle Colab - Practical 16\n\n\n\nFrom CRAN:\n\nSeurat, cowplot, SingleCellExperiment, scDblFinder, Rtsne, hdf5r, clustree, tidyverse, Signac, SeuratObject, hdf5r, reticulate, patchwork, ggplot2, future.\n\nFrom Bioconductor:\n\ncelldex, SingleR, SeuratDisk, clusterProfile, preprocessCore, EnsDb.Hsapiens.v86, EnsDb.Hsapiens.v75, biovizBase, LoomExperiment, SingleCellExperiment, SeuratData, JASPAR2020, TFBSTools, glmGamPoi, clusterProfiler, org.Hs.eg.db , BSgenome.Hsapiens.UCSC.hg38\n\nFrom Github:\n\nSeuratData, presto and sceasy"
  },
  {
    "objectID": "index.html#citing-and-re-using-course-material",
    "href": "index.html#citing-and-re-using-course-material",
    "title": "Analyzing PBMCs Single Cell ATAC- Seq (scATAC-Seq) and Multiome data: Theory and practice",
    "section": "Citing and Re-using Course Material",
    "text": "Citing and Re-using Course Material\nThe course data are free to reuse and adapt with appropriate attribution. All course data in these repositories are licensed under the¬†Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0)."
  },
  {
    "objectID": "Section1_intro.html#what-are-atac-seq-and-scatac-seq",
    "href": "Section1_intro.html#what-are-atac-seq-and-scatac-seq",
    "title": "1¬† Fundamentals of Single Cell ATAC-seq (scATAC-seq) analysis",
    "section": "1.1 What are ATAC-seq and scATAC-seq?",
    "text": "1.1 What are ATAC-seq and scATAC-seq?\nATAC-seq (Assay for Transposase-Accessible Chromatin with high-throughput sequencing) is a widely used, cost-effective method for genome-wide profiling of chromatin accessibility, utilizing the hyperactive Tn5 transposase for NGS library preparation.\nSingle-cell ATAC-seq (scATAC-seq) extends this approach to single cells, enabling the study of chromatin accessibility in specific cell types within heterogeneous tissue samples."
  },
  {
    "objectID": "Section1_intro.html#what-is-chromatin-accesibility",
    "href": "Section1_intro.html#what-is-chromatin-accesibility",
    "title": "1¬† Fundamentals of Single Cell ATAC-seq (scATAC-seq) analysis",
    "section": "1.2 What is Chromatin accesibility?",
    "text": "1.2 What is Chromatin accesibility?\nChromatin accessibility refers to the degree of physical compaction of chromatin, a structure made up of DNA and proteins, primarily histones, transcription factors (TFs), chromatin-modifying enzymes, and remodeling complexes. While eukaryotic genomes are generally organized into nucleosomes (with ~147 bp of DNA wrapped around a histone octamer), nucleosome positioning varies across tissues and cell types. Regions like enhancers and promoters (cis-regulatory elements), which interact with transcriptional regulators, tend to be nucleosome-depleted, making the chromatin more accessible.\nGenome-wide profiling of chromatin accessibility is a powerful method for identifying potential regulatory elements specific to cell types or states.\n\n\n\nFigure¬†1.1: Chromatin accessibility profiling in bulk and at single-cell level reveals putative regulatory regions. H3K27ac, histone H3 acetylated at lysine 27; Pol II, polymerase II; TSS, transcription start site; TFs, transcription factors. From: Minnoye, et al.¬†2021. Nat Rev Methods Primers.rimers."
  },
  {
    "objectID": "Section1_intro.html#how-does-atac-seq-work",
    "href": "Section1_intro.html#how-does-atac-seq-work",
    "title": "1¬† Fundamentals of Single Cell ATAC-seq (scATAC-seq) analysis",
    "section": "1.3 How does ATAC-Seq work?",
    "text": "1.3 How does ATAC-Seq work?\nATAC-seq identifies open, accessible regions of chromatin across the genome. Here‚Äôs a step-by-step breakdown of how it works:\n\nCell/Nuclei Isolation: Cells or nuclei are isolated, ensuring the chromatin structure remains intact, along with DNA-binding proteins such as nucleosomes and transcription factors.\nTn5 Transposase Treatment: The chromatin is exposed to a hyperactive Tn5 transposase enzyme, which simultaneously cuts the DNA and inserts special sequences called adapters.\nAdapter Insertion: These adapters (i5/P5 and i7/P7) are added at both ends of the DNA fragments. Only fragments that receive both adapters can be amplified in the next steps.\nLibrary Amplification: The adapter-tagged fragments are amplified through PCR, creating a library of accessible chromatin regions.\nHigh-Throughput Sequencing: The amplified fragments are sequenced using next-generation sequencing (NGS) technologies.\nData Analysis: Sequencing reads are mapped back to the genome. Regions with high concentrations of Tn5 activity (where many fragments originate) are identified as ‚Äúpeaks‚Äù, indicating open, accessible chromatin regions, which often correspond to regulatory elements such as enhancers and promoters.\n\n\n\n\nFigure¬†1.2: Schematic of ATAC-seq Transposition and Library Preparation. A) Overview of ATAC-seq steps: nuclei isolation, Tn5 transposase-mediated chromatin fragmentation and adapter insertion, PCR amplification, and high-throughput sequencing. C) Toy example of hypothetical ATAC-seq data: both cell types X and Y show peaks at gene A‚Äôs promoter, but cell type X has an additional peak at an upstream enhancer, driving higher expression. From: Grandi, et al.¬†2022. Nature Protocols and Footprinting with ArchR. From: ArchR tutorial.\n\n\nIn a hypothetical ATAC-seq dataset, cell types X and Y both show peaks at the promoter of gene A, indicating shared accessibility. However, cell type X has an additional peak at an upstream enhancer, which drives higher gene A expression. This cell-type-specific peak is due to transcription factor B binding to the enhancer, a feature absent in cell type Y. ATAC-seq data also helps reveal transcription factor binding motifs, such as ‚ÄúGATAA‚Äù in this example, linked to differential accessibility.\n\n\n\nFootprinting with ArchR. From: ArchR tutorial\n\n\n\n\n\n\n\n\nNote\n\n\n\nATAC-seq uses a hyperactive Tn5 transposase, engineered with three mutations to boost its activity. This enzyme simultaneously cuts and tags accessible chromatin regions, similar to how DNase I identifies DNase hypersensitive sites (DHSs). The tagged DNA fragments are then amplified and sequenced, offering a powerful method to map open chromatin."
  },
  {
    "objectID": "Section1_intro.html#workflow",
    "href": "Section1_intro.html#workflow",
    "title": "1¬† Fundamentals of Single Cell ATAC-seq (scATAC-seq) analysis",
    "section": "1.4 Workflow",
    "text": "1.4 Workflow\nIn the following sections, we will walk you through a standard workflow for analyzing scATAC-seq data. The accompanying summary figure outlines the different stages of the analysis and emphasizes the distinctions between commonly used frameworks. We‚Äôll start by explaining the concepts of quality control and dimensionality reduction using R.\n\n\n\nFigure¬†1.3: Data analysis workflow. From: Heumos, et al.¬†2023. Nature review genetics"
  },
  {
    "objectID": "Section1_intro.html#data-structure",
    "href": "Section1_intro.html#data-structure",
    "title": "1¬† Fundamentals of Single Cell ATAC-seq (scATAC-seq) analysis",
    "section": "1.5 Data Structure",
    "text": "1.5 Data Structure\n\n1.5.1 The ChromatinAssay Class\nscATAC-seq data is stored in a ChromatinAssay object, which includes slots for additional information about motifs, gene annotations, and genome data. From this object, we create the main Seurat object for our analyses.\nThe ChromatinAssay class extends the standard Seurat Assay class and adds several additional slots for data useful for the analysis of single-cell chromatin datasets. The class includes all the slots present in a standard Seurat Assay, with the following additional slots:\n\nranges: A GRanges object containing the genomic coordinates of each feature in the data matrix.\nmotifs: A Motif object\nfragments: A list of Fragment objects\nseqinfo: A Seqinfo object containing information about the genome that the data was mapped to\nannotation: A GRanges object containing gene annotations\nbias: A vector containing Tn5 integration bias information (the frequency of Tn5 integration at different hexamers)\npositionEnrichment: A named list of matrices containing positional enrichment scores for Tn5 integration (for example, enrichment at the TSS or at different TF motifs)\nlinks: A GRanges object describing linked genomic positions, such as co-accessible sites or enhancer-gene regulatory relationships.\n\nWe can use the granges() function on a Seurat object with an active ChromatinAssay experiment to view the chromosomal regions associated with each gene. For more details on the ChromatinAssay class, refer to the object interaction vignette and check this example.\n\n\n\nFigure¬†1.4: Design of a custom Assay for single-cell chromatin data. We designed a specialized ChromatinAssay class with the capacity to store data required for analysis of single-cell chromatin datasets. From: [Stuart, et al.¬†2021. Nat Methods](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC9255697/)\n\n\n\n\n1.5.2 The Fragment Class\nThe Fragment class is designed for storing and interacting with a fragment file commonly used for single-cell chromatin data. It contains the path to an indexed fragment file on disk, a MD5 hash for the fragment file and the fragment file index, and a vector of cell names contained in the fragment file. Importantly, this is a named vector where the elements of the vector are the cell names as they appear in the fragment file, and the name of each element is the cell name as it appears in the ChromatinAssay object storing the Fragment object. This allows a mapping of cell names on disk to cell names in R, and avoids the need to alter fragment files on disk. This path can also be a remote file accessible by http or ftp. For more details on the Fragment class.\n\nColumn definitions from Single Cell ATAC.\n\n\nColumn Number\nName\nDescription\n\n\n\n\n1\nchrom\nReference genome chromosome of fragment.\n\n\n2\nchromStart\nAdjusted start position of fragment on chromosome.\n\n\n3\nchromEnd\nAdjusted end position of fragment on chromosome. The end position is exclusive, so represents the position immediately following the fragment interval.\n\n\n4\nbarcode\nThe 10x cell barcode of this fragment. This corresponds to the¬†CB¬†tag attached to the corresponding BAM file records for this fragment.\n\n\n5\nreadSupport\nThe total number of read pairs associated with this fragment. This includes the read pair marked unique and all duplicate read pairs.\n\n\n\nExample:\n  chrom  start    end            barcode readCount \n1  chr1  10245  10302 AAAGATGAGGCTAAAT-1         1\n2  chr1  55313  55699 AAACTCGTCTGGCACG-1         2 \n3  chr1  56455  56658 AAACTCGTCTGGCACG-1         1\n4  chr1  60687  60726 AAACTGCAGTCTGTGT-1         1\n5  chr1 235723 235936 AAACTGCTCCTATCCG-1         1"
  },
  {
    "objectID": "Section1_intro.html#references",
    "href": "Section1_intro.html#references",
    "title": "1¬† Fundamentals of Single Cell ATAC-seq (scATAC-seq) analysis",
    "section": "1.6 References",
    "text": "1.6 References\n\nGrandi, et al.¬†2022. Chromatin accessibility profiling by ATAC-seq. Nature protocols.\nMinnoye, et al.¬†2021. Chromatin accessibility profiling methods.Nature reviews methods primers.\nHeumos, et al.¬†2023. Best practices for single-cell analysis across modalities. Nature reviews genetics.\nBest practices. 23. Single-cell ATAC sequencing.\nSignac Tutorial. Calling peaks\nSeuratv4\nArchR tutorial. Chapter 14 Footprinting with ArchR\nPeak Calling using MACS2. Issue 560\n10Xgenomics tutorial. Cell Ranger ATAC count: Feature-Barcode Matrices."
  },
  {
    "objectID": "Section1_P13_intro.html#dataset-overview",
    "href": "Section1_P13_intro.html#dataset-overview",
    "title": "2¬† Practical 13: scATAC-seq Pre-Processing and Quality Control",
    "section": "2.1 Dataset overview",
    "text": "2.1 Dataset overview\nFor this tutorial, we will be analyzing a single-cell ATAC-seq dataset of human peripheral blood mononuclear cells (PBMCs) provided by 10x Genomics. The following files are used in this course, all available through the 10x Genomics website:\n\nThe Raw data: Filtered peak barcode matrix. File name: Peak by cell matrix HDF5 (filtered). Format: h5 / hdf5.\nThe Metadata: Per-barcode fragment counts & metrics. Per Barcode metrics . Format: csv.\nThe fragments file: Barcoded and aligned fragment file. File name: Fragments. Format: tsv.gz.\nThe fragments file index: Fragments file index. File name: Fragments index. Format: tbi.\n\nOur starting points is the output of cellranger-atac (v2.1.0), a 10x Genomics software used for alignment peak calling and initial quality control (QC) of the assay on 10x PBMCs from healthy donor (unimodal scATAC-seq assay).\n\n\n\n\n\n\nView data download code\n\n\n\n\n\nTotal 2.7 Gb\n# Raw data\nwget https://cf.10xgenomics.com/samples/cell-atac/2.1.0/10k_pbmc_ATACv2_nextgem_Chromium_Controller/10k_pbmc_ATACv2_nextgem_Chromium_Controller_filtered_peak_bc_matrix.h5\n# metadata\nwget https://cf.10xgenomics.com/samples/cell-atac/2.1.0/10k_pbmc_ATACv2_nextgem_Chromium_Controller/10k_pbmc_ATACv2_nextgem_Chromium_Controller_singlecell.csv\n# fragments file\nwget https://cf.10xgenomics.com/samples/cell-atac/2.1.0/10k_pbmc_ATACv2_nextgem_Chromium_Controller/10k_pbmc_ATACv2_nextgem_Chromium_Controller_fragments.tsv.gz\n# fragments index\nwget https://cf.10xgenomics.com/samples/cell-atac/2.1.0/10k_pbmc_ATACv2_nextgem_Chromium_Controller/10k_pbmc_ATACv2_nextgem_Chromium_Controller_fragments.tsv.gz.tbi\n\n\n\n\n2.1.1 Summary file metrics\nAccording to the data report, we observed 10,246 PBMC nuclei were recovered. ATAC libraries were generated as described in the Chromium Single Cell ATAC Reagent Kits User Guide (v2 chemistry) using the Chromium Controller and sequenced on Illumina NovaSeq 6000 to approximately 55 k read pairs per cell.\n\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nGreen text indicates that the key metrics are in the expected range while red/yellow text indicates errors/warnings. Descriptions of the metrics can also be found by clicking the icon ? next to the section header. The summary tab reports various metrics including sample, sequencing, cells, cell clustering, insert sizes, targeting, and library complexity.\n\n\nIf you want to know more information about how to analyze the report check this information or check this web page.\n\n\n2.1.2 PBMCs\n\n\n\n\n\n\nNote\n\n\n\nPeripheral Blood Mononuclear Cells (PBMCs) are all blood cells with a single nucleus, including lymphocytes (T cells, B cells, and NK cells) and monocytes. Erythrocytes, platelets, and granulocytes are not considered PBMCs because they have either no nuclei or multiple nuclei. PBMCs play a crucial role in the immune system and serve as important tools for immunological research.\n\n\n\n\n\nFigure¬†2.1: Expected cell types in PBMCs"
  },
  {
    "objectID": "Section1_P13_intro.html#seurat-signac-workflow",
    "href": "Section1_P13_intro.html#seurat-signac-workflow",
    "title": "2¬† Practical 13: scATAC-seq Pre-Processing and Quality Control",
    "section": "2.2 Seurat + Signac Workflow",
    "text": "2.2 Seurat + Signac Workflow\n\n\n\nFigure¬†2.2: Single-cell chromatin analysis workflow with Signac.\n\n\n\nPre-processing workflow\n\n\n\n\nflowchart LR\n\n  A(Import Data) --&gt; B(Annotation)\n \n  B --&gt; C(Computing QC metrics)\n \n  C --&gt; D(Normalization and linear \\ndimensional reduction)\n  \n  D --&gt; E(Non-linear dimensional \\nreduction and clustering)"
  },
  {
    "objectID": "Section1_P13_intro.html#step-1-import-data",
    "href": "Section1_P13_intro.html#step-1-import-data",
    "title": "2¬† Practical 13: scATAC-seq Pre-Processing and Quality Control",
    "section": "2.3 üìó Step 1: Import Data",
    "text": "2.3 üìó Step 1: Import Data\nWhen pre-processing chromatin data, Signac uses information from 4 related input files, both of which can be created using Cell Ranger ATAC:\n\n\nPeak/Cell Matrix (raw data): Similar to the gene expression count matrix used in single-cell RNA-seq, but instead of genes, the rows represent regions of the genome (peaks) that indicate areas of open chromatin. Each value in the matrix represents the number of Tn5 integration sites for each barcode (cell) that map within each peak. More information about this file on the 10x Genomics website.\nMetadata: Cell Ranger ATAC identifies cells by determining whether each barcode corresponds to a cell from any species in the reference. It also generates QC data, including the number of fragments per barcode and ATAC signal, based on metrics like the overlap of fragments with transcription start sites (TSS) from the reference. This barcode-level information is compiled into a single output table. More information about this file on the 10x Genomics website.\nFragment File: Contains a complete list of all unique fragments across all single cells. Although it is larger and slower to process, and is stored on-disk (instead of in memory), its advantage is that it includes all fragments associated with each cell, not just those that map to peaks. More information about the fragment file can be found on the 10x Genomics website or on the sinto website.\nFragment index file: The fragment index file enables fast access to specific fragments in a sequencing file by indexing their positions. This speeds up retrieval and improves analysis efficiency.\n\n\n\n\n\n\n\n\nWhat if I don‚Äôt have a H5 file?\n\n\n\n\n\nThen you can use other outputs from cellranger:\n\ncounts: matrix.mtx\nbarcodes: barcodes.tsv\npeaks: peaks.bed\n\nAlternatively, you might only have a fragment file. In this case you can create a count matrix using the¬†FeatureMatrix()¬†function. If you want to know about this check the Signac tutorial.\n\n\n\n\n\nCode\nlibrary(Signac)\nlibrary(Seurat) \nlibrary(GenomicRanges) # genomic data manipulation\nlibrary(ggplot2) #vizualization\nlibrary(patchwork) # Vizualization \nlibrary(EnsDb.Hsapiens.v86) # human genome hg38\nlibrary(future) # parallelization in Signac\n\n\n\n\nR version: R version 4.4.1 (2024-06-14 ucrt) \n\n\nNumber of cores: 8 \n\n\n[1] '1.14.0'\n\n\nmulticore:\n- args: function (..., workers = 8, envir = parent.frame())\n- tweaked: TRUE\n- call: plan(\"multicore\", workers = 8)\n\n\n\n2.3.1 Create ChromatinAssay\nThe ATAC-seq data is stored using a custom assay, the¬†ChromatinAssay. This enables some specialized functions for analysing genomic single-cell assays such as scATAC-seq. By printing the assay we can see some of the additional information that can be contained in the¬†ChromatinAssay, including motif information, gene annotations, and genome information.\n\n\nCode\ncounts &lt;- Read10X_h5(filename = \"data/10k_pbmc_ATACv2_nextgem_Chromium_Controller_filtered_peak_bc_matrix.h5\")\nmetadata &lt;- read.csv(\n  file = \"data/10k_pbmc_ATACv2_nextgem_Chromium_Controller_singlecell.csv\",\n  header = TRUE,\n  row.names = 1\n)\n\nchrom_assay &lt;- CreateChromatinAssay(\n  counts = counts,\n  sep = c(\":\", \"-\"),\n  fragments = \"data/10k_pbmc_ATACv2_nextgem_Chromium_Controller_fragments.tsv.gz\",\n  min.cells = 10,\n  min.features = 200\n)\n\n\nComputing hash\n\n\nCode\npbmc &lt;- CreateSeuratObject(\n  counts = chrom_assay,\n  assay = \"peaks\",\n  meta.data = metadata\n)\n\n\nCheck global information\n\n\nCode\npbmc\n\n\nAn object of class Seurat \n165434 features across 10246 samples within 1 assay \nActive assay: peaks (165434 features, 0 variable features)\n 2 layers present: counts, data\n\n\nCheck ATAC information\n\n\nCode\npbmc[['peaks']]\n\n\nChromatinAssay data with 165434 features for 10246 cells\nVariable features: 0 \nGenome: \nAnnotation present: FALSE \nMotifs present: FALSE \nFragment files: 1 \n\n\nWe then remove features that correspond to chromosome scaffolds (e.g., KI270713.1) or any other sequences that are not part of the 22 standard autosomes or the two sex chromosomes (X and Y), ensuring that only well-characterized and fully assembled chromosomal regions are included in the analysis.We then remove the features that correspond to chromosome scaffolds e.g.¬†(KI270713.1) or other sequences instead of the (22+2) standard chromosomes.\n\n\nCode\npeaks.keep &lt;- seqnames(granges(pbmc)) %in% standardChromosomes(granges(pbmc))\npbmc &lt;- pbmc[as.vector(peaks.keep), ]"
  },
  {
    "objectID": "Section1_P13_intro.html#step-2-annotation",
    "href": "Section1_P13_intro.html#step-2-annotation",
    "title": "2¬† Practical 13: scATAC-seq Pre-Processing and Quality Control",
    "section": "2.4 ‚úíÔ∏è Step 2: Annotation",
    "text": "2.4 ‚úíÔ∏è Step 2: Annotation\nWe can also add gene annotations to the¬†pbmc¬†object for the human genome. This will allow downstream functions to pull the gene annotation information directly from the object.\n\nBefore annotation\n\n\nCode\npbmc@assays$peaks@annotation\n\n\nNULL\n\n\n\n\n2.4.1 Get gene annotations for the peaks and add to the object\nFrom the¬†dataset summary, we can see that the reference package 10x Genomics used to perform the mapping was ‚ÄúGRCh38-2020-A‚Äù, which¬†corresponds to¬†the Ensembl v98 (hg38) patch release.\n\n\nCode\n# extract gene annotations from EnsDb\nannotations &lt;- GetGRangesFromEnsDb(ensdb = EnsDb.Hsapiens.v86)\n# change to UCSC style since the data was mapped to hg38\nseqlevelsStyle(annotations) &lt;- 'UCSC'\ngenome(annotations) &lt;- \"hg38\"\n\n#  Check chromosomes\nseqlevels(annotations)\n\n\n [1] \"chrX\"  \"chr20\" \"chr1\"  \"chr6\"  \"chr3\"  \"chr7\"  \"chr12\" \"chr11\" \"chr4\" \n[10] \"chr17\" \"chr2\"  \"chr16\" \"chr8\"  \"chr19\" \"chr9\"  \"chr13\" \"chr14\" \"chr5\" \n[19] \"chr22\" \"chr10\" \"chrY\"  \"chr18\" \"chr15\" \"chr21\" \"chrM\" \n\n\nCode\n# add the gene information to the object\nAnnotation(pbmc) &lt;- annotations\n\n\n\nOther options\n\n\nCode\nlibrary(AnnotationHub)\nah &lt;- AnnotationHub()\n\n# Search for the Ensembl 98 EnsDb for Homo sapiens on AnnotationHub\nquery(ah, \"EnsDb.Hsapiens.v98\")\nensdb_v98 &lt;- ah[[\"AH75011\"]]\n\n# extract gene annotations from EnsDb\nannotations &lt;- GetGRangesFromEnsDb(ensdb = ensdb_v98)\n\n# change to UCSC style since the data was mapped to hg38\nseqlevels(annotations) &lt;- paste0('chr', seqlevels(annotations))\ngenome(annotations) &lt;- \"hg38\"\n\n# add the gene information to the object\nAnnotation(pbmc) &lt;- annotations\n\n\n\n\nOlder version (hg19)\n\n\nCode\n# BiocManager::install(c('BSgenome.Hsapiens.UCSC.hg19', 'EnsDb.Hsapiens.v75'))\n# first get some gene annotations for hg19\nlibrary(EnsDb.Hsapiens.v75)\n\n# convert EnsDb to GRanges\nannotation &lt;- GetGRangesFromEnsDb(ensdb = EnsDb.Hsapiens.v75)\n\n# convert to UCSC style\nseqlevels(annotation) &lt;- paste0('chr', seqlevels(annotation))\ngenome(annotation) &lt;- \"hg19\"\n\n# set gene annotations\nAnnotation(pbmc) &lt;- annotation\n\n# get gene annotation information\nAnnotation(pbmc)\n\n\n\n\nOlder version (hg19)\n\n\nCode\nlibrary(EnsDb.Hsapiens.v75)\n\n# extract gene annotations from EnsDb\nannotation &lt;- GetGRangesFromEnsDb(ensdb = EnsDb.Hsapiens.v75)\n\n# change to UCSC style since the data was mapped to hg19\nseqlevelsStyle(annotation) &lt;- 'UCSC'\n\n# add the gene information to the object\nAnnotation(pbmc) &lt;- annotation\n# check\nhead(seqlevels(pbmc))\n\n\nFor more details on Data structures and object interaction in Signac. EnsDb.Hsapiens.v86 was used for Joint RNA and ATAC analysis: 10x multiomic. Informations about genome version can be found at this link.\nAfter adding the gene annotation:\n\n\nCode\npbmc@assays$peaks@annotation\n\n\nGRanges object with 3021151 ranges and 5 metadata columns:\n                  seqnames        ranges strand |           tx_id   gene_name\n                     &lt;Rle&gt;     &lt;IRanges&gt;  &lt;Rle&gt; |     &lt;character&gt; &lt;character&gt;\n  ENSE00001489430     chrX 276322-276394      + | ENST00000399012      PLCXD1\n  ENSE00001536003     chrX 276324-276394      + | ENST00000484611      PLCXD1\n  ENSE00002160563     chrX 276353-276394      + | ENST00000430923      PLCXD1\n  ENSE00001750899     chrX 281055-281121      + | ENST00000445062      PLCXD1\n  ENSE00001489388     chrX 281192-281684      + | ENST00000381657      PLCXD1\n              ...      ...           ...    ... .             ...         ...\n  ENST00000361739     chrM     7586-8269      + | ENST00000361739      MT-CO2\n  ENST00000361789     chrM   14747-15887      + | ENST00000361789      MT-CYB\n  ENST00000361851     chrM     8366-8572      + | ENST00000361851     MT-ATP8\n  ENST00000361899     chrM     8527-9207      + | ENST00000361899     MT-ATP6\n  ENST00000362079     chrM     9207-9990      + | ENST00000362079      MT-CO3\n                          gene_id   gene_biotype     type\n                      &lt;character&gt;    &lt;character&gt; &lt;factor&gt;\n  ENSE00001489430 ENSG00000182378 protein_coding     exon\n  ENSE00001536003 ENSG00000182378 protein_coding     exon\n  ENSE00002160563 ENSG00000182378 protein_coding     exon\n  ENSE00001750899 ENSG00000182378 protein_coding     exon\n  ENSE00001489388 ENSG00000182378 protein_coding     exon\n              ...             ...            ...      ...\n  ENST00000361739 ENSG00000198712 protein_coding      cds\n  ENST00000361789 ENSG00000198727 protein_coding      cds\n  ENST00000361851 ENSG00000228253 protein_coding      cds\n  ENST00000361899 ENSG00000198899 protein_coding      cds\n  ENST00000362079 ENSG00000198938 protein_coding      cds\n  -------\n  seqinfo: 25 sequences (1 circular) from hg38 genome"
  },
  {
    "objectID": "Section1_P13_intro.html#step-3-computing-qc-metrics",
    "href": "Section1_P13_intro.html#step-3-computing-qc-metrics",
    "title": "2¬† Practical 13: scATAC-seq Pre-Processing and Quality Control",
    "section": "2.5 üìï Step 3: Computing QC metrics",
    "text": "2.5 üìï Step 3: Computing QC metrics\nWe can now compute QC metrics for the scATAC-seq experiment. Below are the recommended metrics for assessing data quality. As with scRNA-seq, expected values may vary depending on factors such as biological system and cell viability.\n\nNucleosome banding pattern: The DNA fragment size histogram should show a distinct nucleosome banding pattern, indicating DNA wrapped around nucleosomes. We calculate this per cell and quantify the ratio of mononucleosomal to nucleosome-free fragments (stored as nucleosome_signal).\n\nratio of nucleosome size fragments (147-294 nucleotides)\nnucleosome-free fragments (&lt;147 nucleotides)\n\nTSS enrichment score: Defined by ENCODE, this score measures the ratio of fragments centered at transcription start sites (TSS) compared to flanking regions. Poor experiments tend to have low TSS enrichment. You can calculate it per cell using TSSEnrichment(), with results stored in the TSS.enrichment metadata column.\nTotal fragments in peaks: A measure of sequencing depth. Cells with very few reads may need to be excluded, while those with excessively high reads might indicate doublets or artifacts.\nFraction of fragments in peaks: This is the proportion of fragments falling within ATAC-seq peaks. Cells with low values (&lt;15-20%) may indicate low quality or technical artifacts and should be removed.\nRatio of reads in blacklist regions: The ENCODE blacklist identifies regions prone to artefactual signal. Cells with a high fraction of reads mapping to these regions should be excluded. You can calculate this using FractionCountsInRegion() with the blacklist regions included in Signac.\n\nThese metrics can be obtained from Cell Ranger output or calculated for non-10x datasets using Signac.\n\n\n\nFigure¬†2.3: Assessing ATAC-seq library quality. The schematic shows transposition events near genes, with TSS regions (¬±2 kb) aligned across the genome. Reads are aggregated into a ‚Äòmeta-TSS‚Äô to calculate per-base enrichment scores, plotted along the ¬±2 kb region. From: Grandi, et al.¬†2022. Nature Protocols.\n\n\n\n2.5.1 Bioanalyzer results and TSS region\n\n\n\nFigure¬†2.4: Bioanalyzer results and QC graph. d‚Äìf.¬†Left: Bioanalyzer trace and gel. Middle: TSS enrichment plot. Right: fragment size distribution. From: Grandi, et al.¬†2022. Nature Protocols.\n\n\n\nd. Successful library (TSS score: 8.3) with clear nucleosomal periodicity.\ne. Successful library (TSS score: 8.8) with minimal nucleosomal periodicity.\nf. Unsuccessful library (TSS score: 1.7) with poor signal-to-background and low quality.\n\nLarge fragments (&gt;2,000 bp) appear in Bioanalyzer traces but not in sequencing data.\n\n\n2.5.2 Impact of Sample Type on Fragment Yield and Sequencing Quality\n\n\n\n\n\n\nNote\n\n\n\n\nScatterplot colored by point density: This plot shows the log10(unique nuclear fragments) vs TSS enrichment score and indicates the thresholds used with dotted lines.\nHistogram: These plot shows the fragment size distribution.\n\n\n\n\n\n\nBMMC QC graphs. From: ArchR tutorial\n\n\n\n\n\nPBMCs QC graphs. From: ArchR tutorial\n\n\n\n\n2.5.3 ATAC-seq insert sizes disclose nucleosome positions\nATAC-seq paired-end reads provided detailed insights into nucleosome packing and positioning. The fragment size distribution from human chromatin showed clear 200 bp periodicity, indicating fragments protected by multiple nucleosomes.\n\n\n\nFigure¬†2.5: ATAC-seq provides genome-wide information on chromatin compaction. Inset, log-transformed histogram shows clear periodicity persists to six nucleosomes. From: Buenrostro, et al.¬†2013. Nature.\n\n\nAgain in the code:\n\n\nCode\n# compute nucleosome signal score per cell\npbmc &lt;- NucleosomeSignal(object = pbmc)\n\n# compute TSS enrichment score per cell\npbmc &lt;- TSSEnrichment(object = pbmc)\n\n# add fraction of reads in peaks\npbmc$pct_reads_in_peaks &lt;- pbmc$peak_region_fragments / pbmc$passed_filters * 100\n\n# add blacklist ratio\npbmc$blacklist_ratio &lt;- FractionCountsInRegion(\n  object = pbmc, \n  assay = 'peaks',\n  regions = blacklist_hg38_unified\n)\n\n\nThe relationship between variables stored in the object metadata can be visualized using the¬†DensityScatter()¬†function. This can also be used to quickly find suitable cutoff values for different QC metrics by setting¬†quantiles=TRUE:\n\n\nCode\nDensityScatter(pbmc, x = 'nCount_peaks', y = 'TSS.enrichment', log_x = TRUE, quantiles = TRUE)\n\n\n\n\n\nWe can also look at the fragment length periodicity for all the cells, and group by cells with high or low nucleosomal signal strength. You can see that cells that are outliers for the mononucleosomal / nucleosome-free ratio (based on the plots above) have different nucleosomal banding patterns. The remaining cells exhibit a pattern that is typical for a successful ATAC-seq experiment.\n\n\n2.5.4 Fragment size distribution\n\n\nCode\npbmc$nucleosome_group &lt;- ifelse(pbmc$nucleosome_signal &gt; 4, 'NS &gt; 4', 'NS &lt; 4')\nFragmentHistogram(object = pbmc, group.by = 'nucleosome_group')\n\n\n\n\n\nWe can plot the distribution of each QC metric separately using a violin plot:\n\n\nCode\nVlnPlot(\n  object = pbmc,\n  features = c('nCount_peaks', 'TSS.enrichment', 'blacklist_ratio', 'nucleosome_signal', 'pct_reads_in_peaks'),\n  pt.size = 0.1,\n  ncol = 5\n)\n\n\n\n\n\nFinally we remove cells that are outliers for these QC metrics. The exact QC thresholds used will need to be adjusted according to your dataset.\n\n\nCode\npbmc &lt;- subset(\n  x = pbmc,\n  subset = nCount_peaks &gt; 9000 & \n    nCount_peaks &lt; 100000 &\n    pct_reads_in_peaks &gt; 40 & # 40 % of the reads in the peaks\n    blacklist_ratio &lt; 0.01 & # more of 1 % of the reads mapeaning in blacklist ratio\n    nucleosome_signal &lt; 4 &\n    TSS.enrichment &gt; 4 # enrichment score\n)\npbmc\n\n\nAn object of class Seurat \n165376 features across 9649 samples within 1 assay \nActive assay: peaks (165376 features, 0 variable features)\n 2 layers present: counts, data\n\n\n\n\n            used   (Mb) gc trigger    (Mb)   max used   (Mb)\nNcells  14851936  793.2   44328732  2367.5   44328732 2367.5\nVcells 585597127 4467.8 1391138032 10613.6 1159215027 8844.2\n\n\n\n\n\n\n\n\nNote\n\n\n\nThis code filters the pbmc object to retain only high-quality cells based on specific criteria:\n\nnCount_peaks &gt; 9000: Keeps cells with more than 9000 reads in accessible regions.\nnCount_peaks &lt; 100000: Removes cells with an excessive number of reads, likely artifacts.\npct_reads_in_peaks &gt; 40: Retains cells where over 40% of reads fall within peaks (high-quality signal).\nblacklist_ratio &lt; 0.01: Excludes cells with more than 1% of reads in blacklisted regions (unreliable areas).\nnucleosome_signal &lt; 4: Keeps cells with low nucleosome signal, indicating accessible chromatin.\nTSS.enrichment &gt; 4: Retains cells with strong enrichment near transcription start sites (good data quality)."
  },
  {
    "objectID": "Section1_P13_intro.html#step-4-normalization-and-linear-dimensional-reduction-lsi",
    "href": "Section1_P13_intro.html#step-4-normalization-and-linear-dimensional-reduction-lsi",
    "title": "2¬† Practical 13: scATAC-seq Pre-Processing and Quality Control",
    "section": "2.6 üìò Step 4: Normalization and linear dimensional reduction (LSI)",
    "text": "2.6 üìò Step 4: Normalization and linear dimensional reduction (LSI)\n\n‚úÖ Normalization: Signac performs term frequency-inverse document frecuency (TF-IDF) normalization, a two-step process that adjusts for differences in sequencing depth across cells and assigns higher values to rare peaks. Run term frequency inverse document frequency (TF-IDF) normalization on a matrix using RunTFIDF().\n\n\n\nFigure¬†2.6: TF-IDF(term frequency-inverse document frequency). From: Almarashy, et al.¬†2023. IEEE Access\n\n\n\n\n\n\n\n\n\nMore information\n\n\n\nTerm-Frequency Inverse-Document-Frequency (TF-IDF) is a technique commonly used in text processing, but in the context of scATAC-seq (single-cell Assay for Transposase-Accessible Chromatin sequencing), it is adapted to quantify and normalize chromatin accessibility signals across different cells.\nHere‚Äôs how this concept is applied in scATAC-seq:\n\nTerm Frequency (TF): In scATAC-seq, ‚Äúterms‚Äù correspond to peaks of chromatin accessibility, and the ‚Äúdocument‚Äù is an individual cell. ‚ÄúTF‚Äù measures how frequently a given accessible site (a peak) is present in a particular cell. Essentially, it represents the frequency of accessibility of a peak within a cell.\nInverse Document Frequency (IDF): ‚ÄúIDF‚Äù measures how common or rare a peak is across all cells. If a peak is present in many cells, its IDF will be low because it is not informative. Conversely, if a peak is present only in a few cells, its IDF will be high, reflecting its specificity.\nApplication in scATAC-seq: The purpose of using TF-IDF in scATAC-seq is to improve the representation of accessibility data. Given the high sparsity of single-cell data and the binary nature of accessibility (present or absent), applying TF-IDF helps to highlight peaks that are specific to certain cells. This enables better downstream analysis, such as dimensionality reduction or clustering, to capture biological differences between cells more accurately.\n\nSummary:\n\nTF measures how frequently a peak is accessible in a cell.\nIDF penalizes peaks that are accessible in many cells and gives more weight to those specific to fewer cells.\nTF-IDF in scATAC-seq is used to normalize the data, providing a better representation of chromatin accessibility for analyses like clustering or dimensionality reduction.\nBy default, the TF-IDF is then defined as TF times IDF followed by log-transformation (method = 1). There are also other options, for instance, TF times log-transformed IDF (method = 2), and log-transformed TF times log-transformed IDF (method = 3).\n\n\n\n\n\n\n‚úÖ Feature selection: Unlike scRNA-seq, scATAC-seq has low dynamic range, making variable feature selection difficult.\n\nA) Instead, we can choose to use only the top n% of features (peaks) for dimensional reduction, or remove features present in less than n cells with the FindTopFeatures() function.\nB) Features used for dimensional reduction are automatically set as VariableFeatures() for the Seurat object by this function.\n\nNOTE: Even when using all features, similar results are observed, with faster runtimes when using a subset (e.g., the top 25% of peaks with min.cutoff = ‚Äòq75‚Äô).\n\n\n‚úÖ Dimension reduction: Singular Value Decomposition (SVD) is applied to the TF-IDF matrix using the selected peaks, generating a reduced dimensional representation similar to PCA in scRNA-seq analyses. Run singular value decomposition using RunSVD().\n\nThe combined steps of TF-IDF followed by SVD are known as latent semantic indexing (LSI), and were first introduced for the analysis of scATAC-seq data by Cusanovich et al.¬†2015.\n\n\nCode\npbmc &lt;- RunTFIDF(pbmc)\n\n\nPerforming TF-IDF normalization\n\n\nCode\npbmc &lt;- FindTopFeatures(pbmc, min.cutoff = 'q0')\npbmc &lt;- RunSVD(pbmc)\n\n\nRunning SVD\n\n\nScaling cell embeddings\n\n\n\n\n            used   (Mb) gc trigger    (Mb)   max used    (Mb)\nNcells  14861031  793.7   44328732  2367.5   44328732  2367.5\nVcells 546703133 4171.1 1391138032 10613.6 1339365755 10218.6\n\n\n\n\n\n\n\n\nNote\n\n\n\nAnother reason of using TF-IDF for ATAC-seq data is that its scales of different peaks, regardless the size of the peaks, should be comparable, and therefore the further data scaling becomes unnecessary. Computationally this is very important. From the definition it is clear that for peaks with no fragment detected in a cell, its TF-IDF value remains zero. Therefore, the TF-IDF matrix can be still represented by a sparse matrix, and then is directly used as the input for the next analysis without the need to generating a scaled data matrix which is likely a high-dimensional dense matrix that needs huge amount of memory to store.\n\n\nThe first LSI component often captures sequencing depth (technical variation) rather than biological variation. If this is the case, the component should be removed from downstream analysis. We can assess the correlation between each LSI component and sequencing depth using the¬†DepthCor()¬†function:\n\n\nCode\nDepthCor(pbmc)\n\n\n\n\n\nHere we see there is a very strong correlation between the first LSI component and the total number of counts for the cell. We will perform downstream steps without this component as we don‚Äôt want to group cells together based on their total sequencing depth, but rather by their patterns of accessibility at cell-type-specific peaks.\n\n\n\n\n\n\nWhy did we eliminate component 1?\n\n\n\nComponent 1 is often removed in dimensionality reduction analyses because it may capture non-biological variability or technical artifacts rather than biologically relevant patterns. Removing it helps focus on components that better reflect the true biological structure of the data."
  },
  {
    "objectID": "Section1_P13_intro.html#step-5-non-linear-dimensional-reduction-and-clustering",
    "href": "Section1_P13_intro.html#step-5-non-linear-dimensional-reduction-and-clustering",
    "title": "2¬† Practical 13: scATAC-seq Pre-Processing and Quality Control",
    "section": "2.7 üìô Step 5: Non-linear dimensional reduction and clustering",
    "text": "2.7 üìô Step 5: Non-linear dimensional reduction and clustering\nNow that the cells are embedded in a low-dimensional space we can use methods commonly applied for the analysis of scRNA-seq data to perform graph-based clustering and non-linear dimension reduction for visualization. The functions¬†RunUMAP(),¬†FindNeighbors(), and¬†FindClusters()¬†all come from the Seurat package.\n\n2.7.1 Perform UMAP\nUniform Manifold Approximation and Projection (UMAP) is a dimension reduction technique that can be used for visualisation similarly to t-SNE, but also for general non-linear dimension reduction. It was proposed by McInnes¬†et al. 2018.\nThis¬†results in the creation of two new parameters UMAP 1 and UMAP 2. UMAP captures local relationships within a cluster as well as global relationships between distinct clusters.\n\n\n\n\n\n\nNote\n\n\n\nWhile PCA assumes that the variation of interest follows a specific distribution (generally normal), UMAP is more flexible and can learn complex, non-linear distributions directly from the data. This flexibility allows UMAP to better separate clusters, particularly when some clusters are more similar to each other. As a result, UMAP often excels at revealing nuanced relationships and improving cluster separation in datasets with intricate patterns.\nUMAP Visualization - bulk RNA-seq\nAlso you can extract the normalized counts data from the¬†DESeqDataSet¬†object and perform UMAP on the normalized data using¬†umap()¬†from the¬†umap¬†package.\n\n\n\n\nCode\npbmc &lt;- RunUMAP(object = pbmc, reduction = 'lsi', dims = 2:30)\n\n\n01:59:03 UMAP embedding parameters a = 0.9922 b = 1.112\n\n\n01:59:03 Read 9649 rows and found 29 numeric columns\n\n\n01:59:03 Using Annoy for neighbor search, n_neighbors = 30\n\n\n01:59:03 Building Annoy index with metric = cosine, n_trees = 50\n\n\n0%   10   20   30   40   50   60   70   80   90   100%\n\n\n[----|----|----|----|----|----|----|----|----|----|\n\n\n**************************************************|\n01:59:04 Writing NN index file to temp file C:\\Users\\ecoss\\AppData\\Local\\Temp\\Rtmps5Do8y\\file2de47cdf17ab\n01:59:04 Searching Annoy index using 8 threads, search_k = 3000\n01:59:04 Annoy recall = 100%\n01:59:06 Commencing smooth kNN distance calibration using 8 threads with target n_neighbors = 30\n01:59:08 Initializing from normalized Laplacian + noise (using RSpectra)\n01:59:09 Commencing optimization for 500 epochs, with 384536 positive edges\n01:59:35 Optimization finished\n\n\nCode\npbmc &lt;- FindNeighbors(object = pbmc, reduction = 'lsi', dims = 2:30)\n\n\nComputing nearest neighbor graph\nComputing SNN\n\n\nCode\npbmc &lt;- FindClusters(object = pbmc, verbose = FALSE, algorithm = 3)\n\n# save\nsave(pbmc, file = \"data/pbmc.RData\")\n\n# plot\nDimPlot(object = pbmc, label = TRUE) + NoLegend()\n\n\n\n\n\nNow, we can cluster the cells to find groups that belong to the same cell types. It is possible to plot the results from the SVD, but these often are not informative. Instead, we use the UMAP algorithm, which shows a better separation between the cell types. If you are interested, the paper describing UMAP can be found¬†here.\n\n\nCode\np1 &lt;- DimPlot(object = pbmc, label = TRUE, dims = c(2, 3), reduction = \"lsi\") +\n    NoLegend()  +\n    ggtitle('SVD')\n\np2 &lt;- DimPlot(object = pbmc, label = TRUE) +\n    NoLegend() +\n    ggtitle('UMAP')\n\np1 | p2\n\n\n\n\n\n\n\nCode\n# Remove ALL objects from workspace\nrm(list = ls())\n# free memory\ngc()\n\n\n            used   (Mb) gc trigger   (Mb)   max used    (Mb)\nNcells  14178933  757.3   44328732 2367.5   44328732  2367.5\nVcells 365350483 2787.5 1112910426 8490.9 1339365755 10218.6\n\n\n\n\nCode\nsessionInfo()\n\n\nR version 4.4.1 (2024-06-14 ucrt)\nPlatform: x86_64-w64-mingw32/x64\nRunning under: Windows 11 x64 (build 22631)\n\nMatrix products: default\n\n\nlocale:\n[1] LC_COLLATE=English_United States.utf8 \n[2] LC_CTYPE=English_United States.utf8   \n[3] LC_MONETARY=English_United States.utf8\n[4] LC_NUMERIC=C                          \n[5] LC_TIME=English_United States.utf8    \n\ntime zone: America/Mexico_City\ntzcode source: internal\n\nattached base packages:\n[1] stats4    stats     graphics  grDevices utils     datasets  methods  \n[8] base     \n\nother attached packages:\n [1] future_1.34.0             EnsDb.Hsapiens.v86_2.99.0\n [3] ensembldb_2.28.1          AnnotationFilter_1.28.0  \n [5] GenomicFeatures_1.56.0    AnnotationDbi_1.66.0     \n [7] Biobase_2.64.0            patchwork_1.2.0          \n [9] ggplot2_3.5.1             GenomicRanges_1.56.1     \n[11] GenomeInfoDb_1.40.1       IRanges_2.38.1           \n[13] S4Vectors_0.42.1          BiocGenerics_0.50.0      \n[15] Seurat_5.1.0              SeuratObject_5.0.2       \n[17] sp_2.1-4                  Signac_1.14.0            \n\nloaded via a namespace (and not attached):\n  [1] RcppAnnoy_0.0.22            splines_4.4.1              \n  [3] later_1.3.2                 BiocIO_1.14.0              \n  [5] bitops_1.0-8                tibble_3.2.1               \n  [7] polyclip_1.10-7             rpart_4.1.23               \n  [9] XML_3.99-0.17               fastDummies_1.7.4          \n [11] lifecycle_1.0.4             hdf5r_1.3.11               \n [13] globals_0.16.3              lattice_0.22-6             \n [15] MASS_7.3-60.2               backports_1.5.0            \n [17] magrittr_2.0.3              Hmisc_5.1-3                \n [19] plotly_4.10.4               rmarkdown_2.28             \n [21] yaml_2.3.10                 httpuv_1.6.15              \n [23] sctransform_0.4.1           spam_2.10-0                \n [25] spatstat.sparse_3.1-0       reticulate_1.39.0          \n [27] cowplot_1.1.3               pbapply_1.7-2              \n [29] DBI_1.2.3                   RColorBrewer_1.1-3         \n [31] abind_1.4-8                 zlibbioc_1.50.0            \n [33] Rtsne_0.17                  purrr_1.0.2                \n [35] biovizBase_1.52.0           RCurl_1.98-1.16            \n [37] nnet_7.3-19                 VariantAnnotation_1.50.0   \n [39] GenomeInfoDbData_1.2.12     ggrepel_0.9.5              \n [41] irlba_2.3.5.1               listenv_0.9.1              \n [43] spatstat.utils_3.1-0        goftest_1.2-3              \n [45] RSpectra_0.16-2             spatstat.random_3.3-1      \n [47] fitdistrplus_1.2-1          parallelly_1.38.0          \n [49] leiden_0.4.3.1              codetools_0.2-20           \n [51] DelayedArray_0.30.1         RcppRoll_0.3.1             \n [53] tidyselect_1.2.1            farver_2.1.2               \n [55] UCSC.utils_1.0.0            base64enc_0.1-3            \n [57] matrixStats_1.4.0           spatstat.explore_3.3-2     \n [59] GenomicAlignments_1.40.0    jsonlite_1.8.8             \n [61] Formula_1.2-5               progressr_0.14.0           \n [63] ggridges_0.5.6              survival_3.6-4             \n [65] tools_4.4.1                 ica_1.0-3                  \n [67] Rcpp_1.0.13                 glue_1.7.0                 \n [69] SparseArray_1.4.8           gridExtra_2.3              \n [71] xfun_0.45                   MatrixGenerics_1.16.0      \n [73] dplyr_1.1.4                 withr_3.0.1                \n [75] fastmap_1.2.0               fansi_1.0.6                \n [77] digest_0.6.36               R6_2.5.1                   \n [79] mime_0.12                   colorspace_2.1-1           \n [81] scattermore_1.2             tensor_1.5                 \n [83] dichromat_2.0-0.1           spatstat.data_3.1-2        \n [85] RSQLite_2.3.7               utf8_1.2.4                 \n [87] tidyr_1.3.1                 generics_0.1.3             \n [89] data.table_1.16.0           rtracklayer_1.64.0         \n [91] httr_1.4.7                  htmlwidgets_1.6.4          \n [93] S4Arrays_1.4.1              uwot_0.2.2                 \n [95] pkgconfig_2.0.3             gtable_0.3.5               \n [97] blob_1.2.4                  lmtest_0.9-40              \n [99] XVector_0.44.0              htmltools_0.5.8.1          \n[101] dotCall64_1.1-1             ProtGenerics_1.36.0        \n[103] scales_1.3.0                png_0.1-8                  \n[105] spatstat.univar_3.0-1       knitr_1.48                 \n[107] rstudioapi_0.16.0           reshape2_1.4.4             \n[109] rjson_0.2.22                checkmate_2.3.2            \n[111] nlme_3.1-164                curl_5.2.2                 \n[113] zoo_1.8-12                  cachem_1.1.0               \n[115] stringr_1.5.1               KernSmooth_2.23-24         \n[117] vipor_0.4.7                 parallel_4.4.1             \n[119] miniUI_0.1.1.1              foreign_0.8-86             \n[121] ggrastr_1.0.2               restfulr_0.0.15            \n[123] pillar_1.9.0                grid_4.4.1                 \n[125] vctrs_0.6.5                 RANN_2.6.2                 \n[127] promises_1.3.0              xtable_1.8-4               \n[129] cluster_2.1.6               beeswarm_0.4.0             \n[131] htmlTable_2.4.3             evaluate_1.0.0             \n[133] cli_3.6.2                   compiler_4.4.1             \n[135] Rsamtools_2.20.0            rlang_1.1.3                \n[137] crayon_1.5.3                future.apply_1.11.2        \n[139] labeling_0.4.3              ggbeeswarm_0.7.2           \n[141] plyr_1.8.9                  stringi_1.8.4              \n[143] viridisLite_0.4.2           deldir_2.0-4               \n[145] BiocParallel_1.38.0         munsell_0.5.1              \n[147] Biostrings_2.72.1           lazyeval_0.2.2             \n[149] spatstat.geom_3.3-2         Matrix_1.7-0               \n[151] BSgenome_1.72.0             RcppHNSW_0.6.0             \n[153] bit64_4.0.5                 KEGGREST_1.44.1            \n[155] shiny_1.9.1                 SummarizedExperiment_1.34.0\n[157] ROCR_1.0-11                 igraph_2.0.3               \n[159] memoise_2.0.1               fastmatch_1.1-4            \n[161] bit_4.0.5"
  },
  {
    "objectID": "Section1_P13_intro.html#references",
    "href": "Section1_P13_intro.html#references",
    "title": "2¬† Practical 13: scATAC-seq Pre-Processing and Quality Control",
    "section": "2.8 References",
    "text": "2.8 References\n\nMouse - Analyzing PBMC scATAC-seq\nHuman - Analyzing PBMC scATAC-seq\nWhat are PBMCs- Peripheral Blood Mononuclear Cells\nSignac tutorial - Data structures and object interaction\nSignac tutorial - Joint RNA and ATAC analysis: 10x multiomic\nSignac tutorial - Signac Install\nCell Ranger ATAC count: Summary Metrics\nBuenrostro, et al.¬†2013. Transposition of native chromatin for fast and sensitive epigenomic profiling of open chromatin, DNA-binding proteins and nucleosome position. Nature.\nAnalyzing adult mouse brain scATAC-seq\nAlmarashy, et al.¬†2023. Enhancing Fake News Detection by Multi-Feature Classification. IEEE access\nMcIness, et al.¬†2020. UMAP: Uniform Manifold Approximation and Projection for Dimension Reduction. arxiv.\nUMAP Visualization - RNA-seq\nUMAP Github"
  },
  {
    "objectID": "Section1_P13_retos.html",
    "href": "Section1_P13_retos.html",
    "title": "3¬† Exercises",
    "section": "",
    "text": "4 Complete results\nwhat happen if we use all data?"
  },
  {
    "objectID": "Section1_P13_retos.html#dataset-overview-10k-peripheral-blood-mononuclear-cells-pbmcs-from-a-healthy-donor",
    "href": "Section1_P13_retos.html#dataset-overview-10k-peripheral-blood-mononuclear-cells-pbmcs-from-a-healthy-donor",
    "title": "3¬† Exercises",
    "section": "3.1 Dataset overview: 10k Peripheral Blood Mononuclear Cells (PBMCs) from a Healthy Donor",
    "text": "3.1 Dataset overview: 10k Peripheral Blood Mononuclear Cells (PBMCs) from a Healthy Donor\nFor this tutorial, we will be analyzing a single-cell ATAC-seq dataset of human peripheral blood mononuclear cells (PBMCs) provided by 10x Genomics. The following files are used in this course, all available through the 10x Genomics website:\n\nThe Raw data: Filtered peak barcode matrix.\nThe Metadata: Per-barcode fragment counts & metrics.\nThe fragments file: Barcoded and aligned fragment file.\nThe fragments file index: Fragments file index.\n\n\n\n\n\n\n\nQuestions\n\n\n\nCheck the data report and answer the questions.\n\nHow many cells were recovered?\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\n8728 nuclei were recovered.\n\n\n\n\nWhich version of Cell Ranger ATAC is used?\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nSingle Cell ATAC dataset analyzed using Cell Ranger ATAC 1.0.1\n\n\n\n\nWhat version of the genome did they use?\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nhg19\n\n\n\n\n\n\n\n\nPre-processing workflow\n\n\n\n\nflowchart LR    \n  A(Import Data) --&gt; B(Annotation)     \n  B --&gt; C(Computing QC metrics)     \n  C --&gt; D(Normalization and linear \\ndimensional reduction)      \n  D --&gt; E(Non-linear dimensional \\nreduction and clustering) \n\n\n\n\n\n\n\n\n\n\n\nExercise in Google Colab\n\n\n\n\nCreate a copy of the Google colab notebook part 1 on your one drive.\nRun the exercise."
  },
  {
    "objectID": "Section1_P13_retos.html#step-1-import-data",
    "href": "Section1_P13_retos.html#step-1-import-data",
    "title": "3¬† Exercises",
    "section": "4.1 üìó Step 1: Import Data",
    "text": "4.1 üìó Step 1: Import Data\n\n\nCode\nlibrary(Signac)\nlibrary(Seurat) \nlibrary(GenomicRanges) # genomic data manipulation\nlibrary(ggplot2) #vizualization\nlibrary(patchwork) # Vizualization \nlibrary(EnsDb.Hsapiens.v75) # human genome hg19\nlibrary(future) # parallelization in Signac\n\n\nSettings on my computer:\n\n\nCode\n# Obtain versions\ncat(\"R version:\", R.version$version.string, \"\\n\")\n\n\nR version: R version 4.4.1 (2024-06-14 ucrt) \n\n\nCode\ncat(\"Number of cores:\", availableCores(), \"\\n\")\n\n\nNumber of cores: 8 \n\n\nCode\npackageVersion(\"Signac\")\n\n\n[1] '1.14.0'\n\n\nCode\n# parallelization options\nplan(\"multicore\", workers = 8)\nplan()\n\n\nmulticore:\n- args: function (..., workers = 8, envir = parent.frame())\n- tweaked: TRUE\n- call: plan(\"multicore\", workers = 8)\n\n\nCode\n# Increase the maximum memory usage\noptions(future.globals.maxSize = 14 * 1024^3)  # para 14 GB de RAM\n\n\nNote that as of future version 1.14.0, forked processing is disabled when running in RStudio. To enable parallel computing in RStudio, you will need to select the ‚Äúmultisession‚Äù option.\n\n4.1.1 Create ChromatinAssay\nThe ATAC-seq data is stored using a custom assay, the¬†ChromatinAssay. This enables some specialized functions for analysing genomic single-cell assays such as scATAC-seq. By printing the assay we can see some of the additional information that can be contained in the¬†ChromatinAssay, including motif information, gene annotations, and genome information.\n\n\nCode\ncounts &lt;- Read10X_h5(filename = \"data/atac_v1_pbmc_10k_filtered_peak_bc_matrix.h5\")\nmetadata &lt;- read.csv(\n  file = \"data/atac_v1_pbmc_10k_singlecell.csv\",\n  header = TRUE,\n  row.names = 1\n)\n\nchrom_assay &lt;- CreateChromatinAssay(\n  counts = counts,\n  sep = c(\":\", \"-\"),\n  genome = 'hg19', # EnsDb.Hsapiens.v75\n  fragments = \"data/atac_v1_pbmc_10k_fragments.tsv.gz\",\n  min.cells = 10,\n  min.features = 200\n)\n\n\nComputing hash\n\n\nCode\npbmc &lt;- CreateSeuratObject(\n  counts = chrom_assay,\n  assay = \"ATAC\",\n  meta.data = metadata\n)\n\n\nCheck global information\n\n\nCode\npbmc\n\n\nAn object of class Seurat \n87561 features across 8728 samples within 1 assay \nActive assay: ATAC (87561 features, 0 variable features)\n 2 layers present: counts, data\n\n\nCheck ATAC information\n\n\nCode\npbmc[['ATAC']]\n\n\nChromatinAssay data with 87561 features for 8728 cells\nVariable features: 0 \nGenome: hg19 \nAnnotation present: FALSE \nMotifs present: FALSE \nFragment files: 1 \n\n\nWe then remove the features that correspond to chromosome scaffolds e.g.¬†(KI270713.1) or other sequences instead of the (22+2) standard chromosomes.\n\n\nCode\npeaks.keep &lt;- seqnames(granges(pbmc)) %in% standardChromosomes(granges(pbmc))\npbmc &lt;- pbmc[as.vector(peaks.keep), ]\n\n\nCheck file:\n87561 features across 8728 samples within 1 assay.\n\n\nCode\ndim(pbmc)\n\n\n[1] 87561  8728\n\n\nCode\nstr(pbmc)\n\n\nFormal class 'Seurat' [package \"SeuratObject\"] with 13 slots\n  ..@ assays      :List of 1\n  .. ..$ ATAC:Formal class 'ChromatinAssay' [package \"Signac\"] with 16 slots\n  .. .. .. ..@ ranges            :Formal class 'GRanges' [package \"GenomicRanges\"] with 7 slots\n  .. .. .. .. .. ..@ seqnames       :Formal class 'Rle' [package \"S4Vectors\"] with 4 slots\n  .. .. .. .. .. .. .. ..@ values         : Factor w/ 24 levels \"chr1\",\"chr2\",..: 1 2 3 4 5 6 7 8 9 10 ...\n  .. .. .. .. .. .. .. ..@ lengths        : int [1:24] 8555 6858 5499 3515 4389 5269 4263 3677 3540 4137 ...\n  .. .. .. .. .. .. .. ..@ elementMetadata: NULL\n  .. .. .. .. .. .. .. ..@ metadata       : list()\n  .. .. .. .. .. ..@ ranges         :Formal class 'IRanges' [package \"IRanges\"] with 6 slots\n  .. .. .. .. .. .. .. ..@ start          : int [1:87561] 565107 569174 713460 752422 762106 779589 793516 801120 804872 839520 ...\n  .. .. .. .. .. .. .. ..@ width          : int [1:87561] 444 466 1364 617 1254 683 226 219 890 1604 ...\n  .. .. .. .. .. .. .. ..@ NAMES          : NULL\n  .. .. .. .. .. .. .. ..@ elementType    : chr \"ANY\"\n  .. .. .. .. .. .. .. ..@ elementMetadata: NULL\n  .. .. .. .. .. .. .. ..@ metadata       : list()\n  .. .. .. .. .. ..@ strand         :Formal class 'Rle' [package \"S4Vectors\"] with 4 slots\n  .. .. .. .. .. .. .. ..@ values         : Factor w/ 3 levels \"+\",\"-\",\"*\": 3\n  .. .. .. .. .. .. .. ..@ lengths        : int 87561\n  .. .. .. .. .. .. .. ..@ elementMetadata: NULL\n  .. .. .. .. .. .. .. ..@ metadata       : list()\n  .. .. .. .. .. ..@ seqinfo        :Formal class 'Seqinfo' [package \"GenomeInfoDb\"] with 4 slots\n  .. .. .. .. .. .. .. ..@ seqnames   : chr [1:24] \"chr1\" \"chr2\" \"chr3\" \"chr4\" ...\n  .. .. .. .. .. .. .. ..@ seqlengths : int [1:24] NA NA NA NA NA NA NA NA NA NA ...\n  .. .. .. .. .. .. .. ..@ is_circular: logi [1:24] NA NA NA NA NA NA ...\n  .. .. .. .. .. .. .. ..@ genome     : chr [1:24] NA NA NA NA ...\n  .. .. .. .. .. ..@ elementMetadata:Formal class 'DFrame' [package \"S4Vectors\"] with 6 slots\n  .. .. .. .. .. .. .. ..@ rownames       : NULL\n  .. .. .. .. .. .. .. ..@ nrows          : int 87561\n  .. .. .. .. .. .. .. ..@ elementType    : chr \"ANY\"\n  .. .. .. .. .. .. .. ..@ elementMetadata: NULL\n  .. .. .. .. .. .. .. ..@ metadata       : list()\n  .. .. .. .. .. .. .. ..@ listData       : Named list()\n  .. .. .. .. .. ..@ elementType    : chr \"ANY\"\n  .. .. .. .. .. ..@ metadata       : list()\n  .. .. .. ..@ motifs            : NULL\n  .. .. .. ..@ fragments         :List of 1\n  .. .. .. .. ..$ :Formal class 'Fragment' [package \"Signac\"] with 3 slots\n  .. .. .. .. .. .. ..@ path : chr \"C:\\\\Users\\\\ecoss\\\\Documents\\\\Respaldos\\\\Github_notes\\\\WCS_scATACseq_book\\\\data\\\\atac_v1_pbmc_10k_fragments.tsv.gz\"\n  .. .. .. .. .. .. ..@ hash : chr [1:2] \"8e03bd72e952a7da7c1cce52f3696e6e\" \"146e556e1311573593bd6cfa6efefcc1\"\n  .. .. .. .. .. .. ..@ cells: Named chr [1:8728] \"AAACGAAAGAGCGAAA-1\" \"AAACGAAAGAGTTTGA-1\" \"AAACGAAAGCGAGCTA-1\" \"AAACGAAAGGCTTCGC-1\" ...\n  .. .. .. .. .. .. .. ..- attr(*, \"names\")= chr [1:8728] \"AAACGAAAGAGCGAAA-1\" \"AAACGAAAGAGTTTGA-1\" \"AAACGAAAGCGAGCTA-1\" \"AAACGAAAGGCTTCGC-1\" ...\n  .. .. .. ..@ seqinfo           :Formal class 'Seqinfo' [package \"GenomeInfoDb\"] with 4 slots\n  .. .. .. .. .. ..@ seqnames   : chr [1:298] \"chr1\" \"chr2\" \"chr3\" \"chr4\" ...\n  .. .. .. .. .. ..@ seqlengths : int [1:298] 249250621 243199373 198022430 191154276 180915260 171115067 159138663 146364022 141213431 135534747 ...\n  .. .. .. .. .. ..@ is_circular: logi [1:298] FALSE FALSE FALSE FALSE FALSE FALSE ...\n  .. .. .. .. .. ..@ genome     : chr [1:298] \"hg19\" \"hg19\" \"hg19\" \"hg19\" ...\n  .. .. .. ..@ annotation        : NULL\n  .. .. .. ..@ bias              : NULL\n  .. .. .. ..@ positionEnrichment: list()\n  .. .. .. ..@ links             :Formal class 'GRanges' [package \"GenomicRanges\"] with 7 slots\n  .. .. .. .. .. ..@ seqnames       :Formal class 'Rle' [package \"S4Vectors\"] with 4 slots\n  .. .. .. .. .. .. .. ..@ values         : Factor w/ 0 levels: \n  .. .. .. .. .. .. .. ..@ lengths        : int(0) \n  .. .. .. .. .. .. .. ..@ elementMetadata: NULL\n  .. .. .. .. .. .. .. ..@ metadata       : list()\n  .. .. .. .. .. ..@ ranges         :Formal class 'IRanges' [package \"IRanges\"] with 6 slots\n  .. .. .. .. .. .. .. ..@ start          : int(0) \n  .. .. .. .. .. .. .. ..@ width          : int(0) \n  .. .. .. .. .. .. .. ..@ NAMES          : NULL\n  .. .. .. .. .. .. .. ..@ elementType    : chr \"ANY\"\n  .. .. .. .. .. .. .. ..@ elementMetadata: NULL\n  .. .. .. .. .. .. .. ..@ metadata       : list()\n  .. .. .. .. .. ..@ strand         :Formal class 'Rle' [package \"S4Vectors\"] with 4 slots\n  .. .. .. .. .. .. .. ..@ values         : Factor w/ 3 levels \"+\",\"-\",\"*\": \n  .. .. .. .. .. .. .. ..@ lengths        : int(0) \n  .. .. .. .. .. .. .. ..@ elementMetadata: NULL\n  .. .. .. .. .. .. .. ..@ metadata       : list()\n  .. .. .. .. .. ..@ seqinfo        :Formal class 'Seqinfo' [package \"GenomeInfoDb\"] with 4 slots\n  .. .. .. .. .. .. .. ..@ seqnames   : chr(0) \n  .. .. .. .. .. .. .. ..@ seqlengths : int(0) \n  .. .. .. .. .. .. .. ..@ is_circular: logi(0) \n  .. .. .. .. .. .. .. ..@ genome     : chr(0) \n  .. .. .. .. .. ..@ elementMetadata:Formal class 'DFrame' [package \"S4Vectors\"] with 6 slots\n  .. .. .. .. .. .. .. ..@ rownames       : NULL\n  .. .. .. .. .. .. .. ..@ nrows          : int 0\n  .. .. .. .. .. .. .. ..@ elementType    : chr \"ANY\"\n  .. .. .. .. .. .. .. ..@ elementMetadata: NULL\n  .. .. .. .. .. .. .. ..@ metadata       : list()\n  .. .. .. .. .. .. .. ..@ listData       : Named list()\n  .. .. .. .. .. ..@ elementType    : chr \"ANY\"\n  .. .. .. .. .. ..@ metadata       : list()\n  .. .. .. ..@ counts            :Formal class 'dgCMatrix' [package \"Matrix\"] with 6 slots\n  .. .. .. .. .. ..@ i       : int [1:52681465] 31 74 83 116 134 147 153 166 175 178 ...\n  .. .. .. .. .. ..@ p       : int [1:8729] 0 5546 12127 21340 51653 56574 61650 64340 73157 79801 ...\n  .. .. .. .. .. ..@ Dim     : int [1:2] 87561 8728\n  .. .. .. .. .. ..@ Dimnames:List of 2\n  .. .. .. .. .. .. ..$ : chr [1:87561] \"chr1-565107-565550\" \"chr1-569174-569639\" \"chr1-713460-714823\" \"chr1-752422-753038\" ...\n  .. .. .. .. .. .. ..$ : chr [1:8728] \"AAACGAAAGAGCGAAA-1\" \"AAACGAAAGAGTTTGA-1\" \"AAACGAAAGCGAGCTA-1\" \"AAACGAAAGGCTTCGC-1\" ...\n  .. .. .. .. .. ..@ x       : num [1:52681465] 2 2 2 1 2 2 2 6 2 2 ...\n  .. .. .. .. .. ..@ factors : list()\n  .. .. .. ..@ data              :Formal class 'dgCMatrix' [package \"Matrix\"] with 6 slots\n  .. .. .. .. .. ..@ i       : int [1:52681465] 31 74 83 116 134 147 153 166 175 178 ...\n  .. .. .. .. .. ..@ p       : int [1:8729] 0 5546 12127 21340 51653 56574 61650 64340 73157 79801 ...\n  .. .. .. .. .. ..@ Dim     : int [1:2] 87561 8728\n  .. .. .. .. .. ..@ Dimnames:List of 2\n  .. .. .. .. .. .. ..$ : chr [1:87561] \"chr1-565107-565550\" \"chr1-569174-569639\" \"chr1-713460-714823\" \"chr1-752422-753038\" ...\n  .. .. .. .. .. .. ..$ : chr [1:8728] \"AAACGAAAGAGCGAAA-1\" \"AAACGAAAGAGTTTGA-1\" \"AAACGAAAGCGAGCTA-1\" \"AAACGAAAGGCTTCGC-1\" ...\n  .. .. .. .. .. ..@ x       : num [1:52681465] 2 2 2 1 2 2 2 6 2 2 ...\n  .. .. .. .. .. ..@ factors : list()\n  .. .. .. ..@ scale.data        : num[0 , 0 ] \n  .. .. .. ..@ assay.orig        : NULL\n  .. .. .. ..@ var.features      : logi(0) \n  .. .. .. ..@ meta.features     :'data.frame': 87561 obs. of  2 variables:\n  .. .. .. .. ..$ count     : num [1:87561] 172 437 6807 864 4841 ...\n  .. .. .. .. ..$ percentile: num [1:87561] 0.274 0.535 0.92 0.691 0.891 ...\n  .. .. .. ..@ misc              :List of 1\n  .. .. .. .. ..$ calcN: logi TRUE\n  .. .. .. ..@ key               : chr \"atac_\"\n  ..@ meta.data   :'data.frame':    8728 obs. of  19 variables:\n  .. ..$ orig.ident                      : Factor w/ 1 level \"SeuratProject\": 1 1 1 1 1 1 1 1 1 1 ...\n  .. ..$ nCount_ATAC                     : num [1:8728] 13187 16069 28008 221734 11439 ...\n  .. ..$ nFeature_ATAC                   : int [1:8728] 5546 6581 9213 30313 4921 5076 2690 8817 6644 3632 ...\n  .. ..$ total                           : int [1:8728] 22965 21806 46233 288897 16103 266481 10753 31745 23136 14626 ...\n  .. ..$ duplicate                       : int [1:8728] 10872 9336 21197 99998 6751 45654 4760 14341 10210 5612 ...\n  .. ..$ chimeric                        : int [1:8728] 183 122 479 2830 104 3425 61 167 145 99 ...\n  .. ..$ unmapped                        : int [1:8728] 198 175 292 1512 120 1514 43 191 157 109 ...\n  .. ..$ lowmapq                         : int [1:8728] 1198 1050 2673 16347 867 41940 644 1465 1308 913 ...\n  .. ..$ mitochondrial                   : int [1:8728] 51 1 14 913 0 57 96 29 15 96 ...\n  .. ..$ passed_filters                  : int [1:8728] 10463 11122 21578 167297 8261 173891 5149 15552 11301 7797 ...\n  .. ..$ cell_id                         : chr [1:8728] \"_cell_0\" \"_cell_1\" \"_cell_2\" \"_cell_3\" ...\n  .. ..$ is__cell_barcode                : int [1:8728] 1 1 1 1 1 1 1 1 1 1 ...\n  .. ..$ TSS_fragments                   : int [1:8728] 4157 4858 10696 86433 3784 14141 2637 6587 5136 3493 ...\n  .. ..$ DNase_sensitive_region_fragments: int [1:8728] 8537 9548 17420 137387 6973 78696 3973 13546 9636 6050 ...\n  .. ..$ enhancer_region_fragments       : int [1:8728] 3079 3954 4332 32884 2509 11425 753 5745 3542 1394 ...\n  .. ..$ promoter_region_fragments       : int [1:8728] 3249 3600 8763 70515 2987 1686 2289 4911 4019 2740 ...\n  .. ..$ on_target_fragments             : int [1:8728] 8894 10034 18562 144918 7288 85168 4183 14115 10072 6346 ...\n  .. ..$ blacklist_region_fragments      : int [1:8728] 6 10 22 300 4 2121 8 23 8 13 ...\n  .. ..$ peak_region_fragments           : int [1:8728] 6796 8319 14333 113658 5879 7360 3220 11399 8215 4509 ...\n  ..@ active.assay: chr \"ATAC\"\n  ..@ active.ident: Factor w/ 1 level \"SeuratProject\": 1 1 1 1 1 1 1 1 1 1 ...\n  .. ..- attr(*, \"names\")= chr [1:8728] \"AAACGAAAGAGCGAAA-1\" \"AAACGAAAGAGTTTGA-1\" \"AAACGAAAGCGAGCTA-1\" \"AAACGAAAGGCTTCGC-1\" ...\n  ..@ graphs      : list()\n  ..@ neighbors   : list()\n  ..@ reductions  : list()\n  ..@ images      : list()\n  ..@ project.name: chr \"SeuratProject\"\n  ..@ misc        : list()\n  ..@ version     :Classes 'package_version', 'numeric_version'  hidden list of 1\n  .. ..$ : int [1:3] 5 0 2\n  ..@ commands    : list()\n  ..@ tools       : list()\n\n\nFor example, we can call¬†granges¬†on a Seurat object with a ChromatinAssay set as the active assay (or on a¬†ChromatinAssay) to see the genomic ranges associated with each feature in the object. See the¬†object interaction vignette¬†for more information about the ChromatinAssay class.\n\n\nCode\ngranges(pbmc)\n\n\nGRanges object with 87561 ranges and 0 metadata columns:\n          seqnames            ranges strand\n             &lt;Rle&gt;         &lt;IRanges&gt;  &lt;Rle&gt;\n      [1]     chr1     565107-565550      *\n      [2]     chr1     569174-569639      *\n      [3]     chr1     713460-714823      *\n      [4]     chr1     752422-753038      *\n      [5]     chr1     762106-763359      *\n      ...      ...               ...    ...\n  [87557]     chrY 58993392-58993760      *\n  [87558]     chrY 58994571-58994823      *\n  [87559]     chrY 58996352-58997331      *\n  [87560]     chrY 59001782-59002175      *\n  [87561]     chrY 59017143-59017246      *\n  -------\n  seqinfo: 24 sequences from an unspecified genome; no seqlengths\n\n\nBarcodes:\n\n\nCode\nhead(colnames(pbmc))\n\n\n[1] \"AAACGAAAGAGCGAAA-1\" \"AAACGAAAGAGTTTGA-1\" \"AAACGAAAGCGAGCTA-1\"\n[4] \"AAACGAAAGGCTTCGC-1\" \"AAACGAAAGTGCTGAG-1\" \"AAACGAACAAGGGTAC-1\"\n\n\nPositions:\n\n\nCode\nhead(rownames(pbmc))\n\n\n[1] \"chr1-565107-565550\" \"chr1-569174-569639\" \"chr1-713460-714823\"\n[4] \"chr1-752422-753038\" \"chr1-762106-763359\" \"chr1-779589-780271\""
  },
  {
    "objectID": "Section1_P13_retos.html#step-2-annotation",
    "href": "Section1_P13_retos.html#step-2-annotation",
    "title": "3¬† Exercises",
    "section": "4.2 ‚úíÔ∏è Step 2: Annotation",
    "text": "4.2 ‚úíÔ∏è Step 2: Annotation\nWe can also add gene annotations to the¬†pbmc¬†object for the human genome. This will allow downstream functions to pull the gene annotation information directly from the object.\nBefore annotation\n\n\nCode\npbmc@assays$ATAC@annotation\n\n\nNULL\n\n\n\n4.2.1 Get gene annotations for the peaks and add to the object\nFrom the¬†dataset summary, we can see that the reference package 10x Genomics used to perform the mapping was ‚Äúhg19‚Äù, which¬†corresponds to¬†the Ensembl v75 (hg19) patch release.\n\n\nCode\n# extract gene annotations from EnsDb\nannotations &lt;- GetGRangesFromEnsDb(ensdb = EnsDb.Hsapiens.v75)\n\n# change to UCSC style since the data was mapped to hg19\nseqlevelsStyle(annotations) &lt;- 'UCSC'\n\n# add the gene information to the object\nAnnotation(pbmc) &lt;- annotations\n# check\nhead(seqlevels(pbmc))\n\n\n[1] \"chr1\" \"chr2\" \"chr3\" \"chr4\" \"chr5\" \"chr6\"\n\n\nAfter adding the gene annotation:\n\n\nCode\npbmc@assays$ATAC@annotation\n\n\nGRanges object with 3072120 ranges and 5 metadata columns:\n                  seqnames        ranges strand |           tx_id   gene_name\n                     &lt;Rle&gt;     &lt;IRanges&gt;  &lt;Rle&gt; |     &lt;character&gt; &lt;character&gt;\n  ENSE00001489430     chrX 192989-193061      + | ENST00000399012      PLCXD1\n  ENSE00001536003     chrX 192991-193061      + | ENST00000484611      PLCXD1\n  ENSE00002160563     chrX 193020-193061      + | ENST00000430923      PLCXD1\n  ENSE00001750899     chrX 197722-197788      + | ENST00000445062      PLCXD1\n  ENSE00001489388     chrX 197859-198351      + | ENST00000381657      PLCXD1\n              ...      ...           ...    ... .             ...         ...\n  ENST00000361739    chrMT     7586-8269      + | ENST00000361739      MT-CO2\n  ENST00000361789    chrMT   14747-15887      + | ENST00000361789      MT-CYB\n  ENST00000361851    chrMT     8366-8572      + | ENST00000361851     MT-ATP8\n  ENST00000361899    chrMT     8527-9207      + | ENST00000361899     MT-ATP6\n  ENST00000362079    chrMT     9207-9990      + | ENST00000362079      MT-CO3\n                          gene_id   gene_biotype     type\n                      &lt;character&gt;    &lt;character&gt; &lt;factor&gt;\n  ENSE00001489430 ENSG00000182378 protein_coding     exon\n  ENSE00001536003 ENSG00000182378 protein_coding     exon\n  ENSE00002160563 ENSG00000182378 protein_coding     exon\n  ENSE00001750899 ENSG00000182378 protein_coding     exon\n  ENSE00001489388 ENSG00000182378 protein_coding     exon\n              ...             ...            ...      ...\n  ENST00000361739 ENSG00000198712 protein_coding      cds\n  ENST00000361789 ENSG00000198727 protein_coding      cds\n  ENST00000361851 ENSG00000228253 protein_coding      cds\n  ENST00000361899 ENSG00000198899 protein_coding      cds\n  ENST00000362079 ENSG00000198938 protein_coding      cds\n  -------\n  seqinfo: 25 sequences (1 circular) from hg19 genome"
  },
  {
    "objectID": "Section1_P13_retos.html#step-3-computing-qc-metrics",
    "href": "Section1_P13_retos.html#step-3-computing-qc-metrics",
    "title": "3¬† Exercises",
    "section": "4.3 üìï Step 3: Computing QC metrics",
    "text": "4.3 üìï Step 3: Computing QC metrics\nWe can now compute some QC metrics for the scATAC-seq experiment as the original tutorial. We currently suggest the following metrics below to assess data quality. As with scRNA-seq, the expected range of values for these parameters will vary depending on your biological system, cell viability, and other factors.\nCalculate the strength of the nucleosome signal per cell using NucleosomeSignal(). Computes the ratio of fragments between 147 bp and 294 bp (mononucleosome) to fragments &lt; 147 bp (nucleosome-free).\nWe can inspect the TSS enrichment scores by grouping the cells based on the score and plotting the accessibility signal over all TSS sites. Setting the `fast=TRUE` option in TSSEnrichment() will only compute the TSS enrichment score without storing the entire cell by position matrix of Tn5 insertion frequency for each cell, and can save memory.\n\n\nCode\n# compute nucleosome signal score per cell\npbmc &lt;- NucleosomeSignal(object = pbmc)\n\n# compute TSS enrichment score per cell\npbmc &lt;- TSSEnrichment(object = pbmc)\n\n# add fraction of reads in peaks\npbmc$pct_reads_in_peaks &lt;- pbmc$peak_region_fragments / pbmc$passed_filters * 100\n\n# add blacklist ratio\npbmc$blacklist_ratio &lt;- pbmc$blacklist_region_fragments/pbmc$peak_region_fragments\n\n\n\n4.3.1 Impact of Sample Type on Fragment Yield and Sequencing Quality\n\n\n\n\n\n\nNote\n\n\n\n\nScatterplot colored by point density: This plot shows the log10(unique nuclear fragments) vs TSS enrichment score and indicates the thresholds used with dotted lines.\nHistogram: These plot shows the fragment size distribution.\n\n\n\nThe relationship between variables stored in the object metadata can be visualized using the¬†DensityScatter()¬†function. This can also be used to quickly find suitable cutoff values for different QC metrics by setting¬†quantiles=TRUE:\n\n\nCode\nDensityScatter(pbmc, x = 'nCount_ATAC', y = 'TSS.enrichment', log_x = TRUE, quantiles = TRUE)\n\n\n\n\n\nWe can also look at the fragment length periodicity for all the cells, and group by cells with high or low nucleosomal signal strength. You can see that cells that are outliers for the mononucleosomal / nucleosome-free ratio (based on the plots above) have different nucleosomal banding patterns. The remaining cells exhibit a pattern that is typical for a successful ATAC-seq experiment.\n\n\n4.3.2 Fragment size distribution\n\n\nCode\npbmc$nucleosome_group &lt;- ifelse(pbmc$nucleosome_signal &gt; 4, 'NS &gt; 4', 'NS &lt; 4')\nFragmentHistogram(object = pbmc, group.by = 'nucleosome_group')\n\n\n\n\n\nWe can plot the distribution of each QC metric separately using a violin plot:\n\n\nCode\nVlnPlot(\n  object = pbmc,\n  features = c('nCount_ATAC', 'TSS.enrichment', 'blacklist_ratio', 'nucleosome_signal', 'pct_reads_in_peaks'),\n  pt.size = 0.1,\n  ncol = 5\n)\n\n\n\n\n\nFinally we remove cells that are outliers for these QC metrics. The exact QC thresholds used will need to be adjusted according to your dataset.\n\n\nCode\npbmc &lt;- subset(\n  x = pbmc,\n  subset = nCount_ATAC &gt; 3000 & \n    nCount_ATAC &lt; 20000 &  \n    pct_reads_in_peaks &gt; 15 & # 15 % of the reads in the peaks\n    blacklist_ratio &lt; 0.01 & # 1 % of the reads mapeaning in blacklist ratio\n    nucleosome_signal &lt; 4 &\n    TSS.enrichment &gt; 4\n)\npbmc\n\n\nAn object of class Seurat \n87561 features across 5628 samples within 1 assay \nActive assay: ATAC (87561 features, 0 variable features)\n 2 layers present: counts, data\n\n\n\n\n            used   (Mb) gc trigger   (Mb)  max used   (Mb)\nNcells  14747239  787.6   43780821 2338.2  34074492 1819.8\nVcells 300696555 2294.2  548983892 4188.5 548983887 4188.5"
  },
  {
    "objectID": "Section1_P13_retos.html#step-4-normalization-and-linear-dimensional-reduction-lsi",
    "href": "Section1_P13_retos.html#step-4-normalization-and-linear-dimensional-reduction-lsi",
    "title": "3¬† Exercises",
    "section": "4.4 üìò Step 4: Normalization and linear dimensional reduction (LSI)",
    "text": "4.4 üìò Step 4: Normalization and linear dimensional reduction (LSI)\n\n\nCode\npbmc &lt;- RunTFIDF(pbmc)\n\n\nPerforming TF-IDF normalization\n\n\nWarning in RunTFIDF.default(object = GetAssayData(object = object, layer =\n\"counts\"), : Some features contain 0 total counts\n\n\nCode\npbmc &lt;- FindTopFeatures(pbmc, min.cutoff = 'q0')\npbmc &lt;- RunSVD(pbmc)\n\n\nRunning SVD\n\n\nScaling cell embeddings\n\n\n\n\n            used   (Mb) gc trigger   (Mb)  max used   (Mb)\nNcells  14756544  788.1   43780821 2338.2  34074492 1819.8\nVcells 296883996 2265.1  548983892 4188.5 548983887 4188.5\n\n\nThe first LSI component often captures sequencing depth (technical variation) rather than biological variation. If this is the case, the component should be removed from downstream analysis. We can assess the correlation between each LSI component and sequencing depth using the¬†DepthCor()¬†function:\n\n\nCode\nDepthCor(pbmc)\n\n\n\n\n\nHere we see there is a very strong correlation between the first LSI component and the total number of counts for the cell. We will perform downstream steps without this component as we don‚Äôt want to group cells together based on their total sequencing depth, but rather by their patterns of accessibility at cell-type-specific peaks."
  },
  {
    "objectID": "Section1_P13_retos.html#step-5-non-linear-dimensional-reduction-and-clustering",
    "href": "Section1_P13_retos.html#step-5-non-linear-dimensional-reduction-and-clustering",
    "title": "3¬† Exercises",
    "section": "4.5 üìô Step 5: Non-linear dimensional reduction and clustering",
    "text": "4.5 üìô Step 5: Non-linear dimensional reduction and clustering\n\n\nCode\npbmc &lt;- RunUMAP(object = pbmc, reduction = 'lsi', dims = 2:30)\n\n\n02:10:46 UMAP embedding parameters a = 0.9922 b = 1.112\n\n\n02:10:46 Read 5628 rows and found 29 numeric columns\n\n\n02:10:46 Using Annoy for neighbor search, n_neighbors = 30\n\n\n02:10:46 Building Annoy index with metric = cosine, n_trees = 50\n\n\n0%   10   20   30   40   50   60   70   80   90   100%\n\n\n[----|----|----|----|----|----|----|----|----|----|\n\n\n**************************************************|\n02:10:46 Writing NN index file to temp file C:\\Users\\ecoss\\AppData\\Local\\Temp\\Rtmpi4Xas7\\file195c37a54711\n02:10:46 Searching Annoy index using 8 threads, search_k = 3000\n02:10:47 Annoy recall = 100%\n02:10:48 Commencing smooth kNN distance calibration using 8 threads with target n_neighbors = 30\n02:10:50 Initializing from normalized Laplacian + noise (using RSpectra)\n02:10:50 Commencing optimization for 500 epochs, with 212950 positive edges\n02:11:06 Optimization finished\n\n\nCode\npbmc &lt;- FindNeighbors(object = pbmc, reduction = 'lsi', dims = 2:30)\n\n\nComputing nearest neighbor graph\nComputing SNN\n\n\nCode\npbmc &lt;- FindClusters(object = pbmc, verbose = FALSE, algorithm = 3)\nDimPlot(object = pbmc, label = TRUE) + NoLegend()"
  },
  {
    "objectID": "Section1_P13_retos.html#references",
    "href": "Section1_P13_retos.html#references",
    "title": "3¬† Exercises",
    "section": "3.2 References",
    "text": "3.2 References\n\nSignac tutorial - Analyzing PBMC scATAC-seq (Signac tutorial)\nSignac tutorial - Analyzing PBMC scATAC-seq"
  },
  {
    "objectID": "Section2_P14_intro.html",
    "href": "Section2_P14_intro.html",
    "title": "4¬† Practical 14: scATAC-seq Downstream",
    "section": "",
    "text": "5 Calling peaks\nYou can call peaks on a single-cell ATAC-seq dataset using MACS2. To use this functionality in Signac, make sure MACS2 is installed‚Äîeither through pip or conda, or by building it from source.\nFor example, with scATAC-seq data from human PBMCs (as shown in our tutorial or from Signac vignette), you can load the necessary packages and a pre-computed Seurat object. See the vignette for the code used to generate this object and links to the raw data.\nCode\nsessionInfo()\n\n\nR version 4.4.1 (2024-06-14 ucrt)\nPlatform: x86_64-w64-mingw32/x64\nRunning under: Windows 11 x64 (build 22631)\n\nMatrix products: default\n\n\nlocale:\n[1] LC_COLLATE=English_United States.utf8 \n[2] LC_CTYPE=English_United States.utf8   \n[3] LC_MONETARY=English_United States.utf8\n[4] LC_NUMERIC=C                          \n[5] LC_TIME=English_United States.utf8    \n\ntime zone: America/Mexico_City\ntzcode source: internal\n\nattached base packages:\n[1] stats4    stats     graphics  grDevices utils     datasets  methods  \n[8] base     \n\nother attached packages:\n [1] enrichplot_1.24.4         org.Hs.eg.db_3.19.1      \n [3] clusterProfiler_4.12.6    presto_1.0.0             \n [5] data.table_1.16.2         Rcpp_1.0.13              \n [7] future_1.34.0             EnsDb.Hsapiens.v86_2.99.0\n [9] ensembldb_2.28.1          AnnotationFilter_1.28.0  \n[11] GenomicFeatures_1.56.0    AnnotationDbi_1.66.0     \n[13] Biobase_2.64.0            patchwork_1.3.0.9000     \n[15] ggplot2_3.5.1             GenomicRanges_1.56.2     \n[17] GenomeInfoDb_1.40.1       IRanges_2.38.1           \n[19] S4Vectors_0.42.1          BiocGenerics_0.50.0      \n[21] Seurat_5.1.0              SeuratObject_5.0.2       \n[23] sp_2.1-4                  Signac_1.14.0            \n\nloaded via a namespace (and not attached):\n  [1] fs_1.6.4                    ProtGenerics_1.36.0        \n  [3] matrixStats_1.4.0           spatstat.sparse_3.1-0      \n  [5] bitops_1.0-8                httr_1.4.7                 \n  [7] RColorBrewer_1.1-3          tools_4.4.1                \n  [9] sctransform_0.4.1           utf8_1.2.4                 \n [11] R6_2.5.1                    lazyeval_0.2.2             \n [13] uwot_0.2.2                  withr_3.0.1                \n [15] gridExtra_2.3               progressr_0.14.0           \n [17] cli_3.6.2                   spatstat.explore_3.3-2     \n [19] fastDummies_1.7.4           scatterpie_0.2.4           \n [21] labeling_0.4.3              spatstat.data_3.1-2        \n [23] ggridges_0.5.6              pbapply_1.7-2              \n [25] Rsamtools_2.20.0            yulab.utils_0.1.7          \n [27] gson_0.1.0                  DOSE_3.30.5                \n [29] R.utils_2.12.3              parallelly_1.38.0          \n [31] limma_3.60.6                rstudioapi_0.17.0          \n [33] RSQLite_2.3.7               gridGraphics_0.5-1         \n [35] generics_0.1.3              BiocIO_1.14.0              \n [37] ica_1.0-3                   spatstat.random_3.3-2      \n [39] dplyr_1.1.4                 GO.db_3.19.1               \n [41] Matrix_1.7-0                ggbeeswarm_0.7.2           \n [43] fansi_1.0.6                 abind_1.4-8                \n [45] R.methodsS3_1.8.2           lifecycle_1.0.4            \n [47] yaml_2.3.10                 SummarizedExperiment_1.34.0\n [49] qvalue_2.36.0               SparseArray_1.4.8          \n [51] Rtsne_0.17                  grid_4.4.1                 \n [53] blob_1.2.4                  promises_1.3.0             \n [55] crayon_1.5.3                miniUI_0.1.1.1             \n [57] lattice_0.22-6              cowplot_1.1.3              \n [59] KEGGREST_1.44.1             pillar_1.9.0               \n [61] knitr_1.48                  fgsea_1.30.0               \n [63] rjson_0.2.23                future.apply_1.11.2        \n [65] codetools_0.2-20            fastmatch_1.1-4            \n [67] leiden_0.4.3.1              glue_1.7.0                 \n [69] ggfun_0.1.6                 spatstat.univar_3.0-1      \n [71] treeio_1.28.0               vctrs_0.6.5                \n [73] png_0.1-8                   spam_2.10-0                \n [75] gtable_0.3.5                cachem_1.1.0               \n [77] xfun_0.48                   S4Arrays_1.4.1             \n [79] mime_0.12                   tidygraph_1.3.1            \n [81] survival_3.6-4              RcppRoll_0.3.1             \n [83] statmod_1.5.0               fitdistrplus_1.2-1         \n [85] ROCR_1.0-11                 nlme_3.1-164               \n [87] ggtree_3.12.0               bit64_4.5.2                \n [89] RcppAnnoy_0.0.22            irlba_2.3.5.1              \n [91] vipor_0.4.7                 KernSmooth_2.23-24         \n [93] colorspace_2.1-1            DBI_1.2.3                  \n [95] ggrastr_1.0.2               tidyselect_1.2.1           \n [97] bit_4.5.0                   compiler_4.4.1             \n [99] curl_5.2.3                  httr2_1.0.5                \n[101] DelayedArray_0.30.1         plotly_4.10.4              \n[103] shadowtext_0.1.4            rtracklayer_1.64.0         \n[105] scales_1.3.0                lmtest_0.9-40              \n[107] rappdirs_0.3.3              stringr_1.5.1              \n[109] digest_0.6.36               goftest_1.2-3              \n[111] spatstat.utils_3.1-0        rmarkdown_2.28             \n[113] XVector_0.44.0              htmltools_0.5.8.1          \n[115] pkgconfig_2.0.3             MatrixGenerics_1.16.0      \n[117] fastmap_1.2.0               rlang_1.1.3                \n[119] htmlwidgets_1.6.4           UCSC.utils_1.0.0           \n[121] shiny_1.9.1                 farver_2.1.2               \n[123] zoo_1.8-12                  jsonlite_1.8.8             \n[125] BiocParallel_1.38.0         GOSemSim_2.30.2            \n[127] R.oo_1.26.0                 RCurl_1.98-1.16            \n[129] magrittr_2.0.3              ggplotify_0.1.2            \n[131] GenomeInfoDbData_1.2.12     dotCall64_1.1-1            \n[133] munsell_0.5.1               ape_5.8                    \n[135] viridis_0.6.5               reticulate_1.39.0          \n[137] stringi_1.8.4               ggraph_2.2.1               \n[139] zlibbioc_1.50.0             MASS_7.3-60.2              \n[141] plyr_1.8.9                  parallel_4.4.1             \n[143] listenv_0.9.1               ggrepel_0.9.6              \n[145] deldir_2.0-4                Biostrings_2.72.1          \n[147] graphlayouts_1.2.0          splines_4.4.1              \n[149] tensor_1.5                  igraph_2.0.3               \n[151] spatstat.geom_3.3-3         RcppHNSW_0.6.0             \n[153] reshape2_1.4.4              XML_3.99-0.17              \n[155] evaluate_1.0.1              tweenr_2.0.3               \n[157] httpuv_1.6.15               RANN_2.6.2                 \n[159] tidyr_1.3.1                 purrr_1.0.2                \n[161] polyclip_1.10-7             scattermore_1.2            \n[163] ggforce_0.4.2               xtable_1.8-4               \n[165] restfulr_0.0.15             tidytree_0.4.6             \n[167] RSpectra_0.16-2             later_1.3.2                \n[169] viridisLite_0.4.2           tibble_3.2.1               \n[171] aplot_0.2.3                 memoise_2.0.1              \n[173] beeswarm_0.4.0              GenomicAlignments_1.40.0   \n[175] cluster_2.1.6               globals_0.16.3"
  },
  {
    "objectID": "Section2_P14_intro.html#option-a-gene-activity-matrix-approach-rna-imputation",
    "href": "Section2_P14_intro.html#option-a-gene-activity-matrix-approach-rna-imputation",
    "title": "4¬† Practical 14: scATAC-seq Downstream",
    "section": "4.1 Option A: Gene activity matrix approach / RNA imputation",
    "text": "4.1 Option A: Gene activity matrix approach / RNA imputation\n\n\n\n\n\nGene activity scores capture how much open chromatin there is in the promoter regions of each gene (by default 2000 bp (2 kb) upstream). The assumption here is that open chromatin is a proxy for gene expression. Gene activity scores are represented as a matrix, with one row per gene and one column per cell. This makes the gene activitiy scores directly compatible with single cell RNA-seq data.\n\n\n\n\n\n\nNote\n\n\n\nCalculating the gene activity scores takes around 10 minutes for 2000 cells and all genes.\n\n\nWe can try to quantify the activity of each gene in the genome by assessing the chromatin accessibility associated with the gene, and create a new gene activity assay derived from the scATAC-seq data. Here we will use a simple approach of summing the fragments intersecting the gene body and promoter region (we also recommend exploring the¬†Cicero¬†tool, which can accomplish a similar goal, and we provide a vignette showing how to run Cicero within a Signac workflow¬†here).\n\n4.1.1 Step 1: Load data\nWe then count the number of fragments for each cell that map to each of these regions, using the using the¬†FeatureMatrix()¬†function. These steps are automatically performed by the¬†GeneActivity()¬†function:\n\n\n4.1.2 Step 2: Create a expression matrix\n\n\nCode\n# Load data\nload(file = \"data/pbmc.RData\") # scATAC\n\nstart &lt;- Sys.time()\ngene.activities &lt;- GeneActivity(pbmc)\n\n\nExtracting gene coordinates\n\n\nExtracting reads overlapping genomic regions\n\n\nCode\nend &lt;- Sys.time()\nend - start\n\n\nTime difference of 14.57489 mins\n\n\nBefore:\n\n\nCode\npbmc@assays\n\n\n$peaks\nChromatinAssay data with 165376 features for 9649 cells\nVariable features: 165376 \nGenome: \nAnnotation present: TRUE \nMotifs present: FALSE \nFragment files: 1 \n\n\nAdd the gene activity matrix to the Seurat object as a new assay and normalize it.\n\n\nCode\npbmc[['RNA']] &lt;- CreateAssayObject(counts = gene.activities)\n# normalization\npbmc &lt;- NormalizeData(\n  object = pbmc,\n  assay = 'RNA',\n  normalization.method = 'LogNormalize',\n  scale.factor = median(pbmc$nCount_RNA)\n)\n\n\nAfter:\n\n\nCode\npbmc@assays\n\n\n$peaks\nChromatinAssay data with 165376 features for 9649 cells\nVariable features: 165376 \nGenome: \nAnnotation present: TRUE \nMotifs present: FALSE \nFragment files: 1 \n\n$RNA\nAssay data with 19607 features for 9649 cells\nFirst 10 features:\n PLCXD1, GTPBP6, PPP2R3B, SHOX, CRLF2, CSF2RA, IL3RA, SLC25A6, ASMTL,\nP2RY8 \n\n\n\n\n4.1.3 Step 3: Check biomarkers\nWe are now able to visualize the activity of canonical biomarkers to guide our interpretation of scATAC-seq clusters. Although this new putative ‚ÄúscRNA-seq‚Äù experiment derived from scATAC-seq will be noisier than a canonical scRNA-seq experiment, it will still be useful. The noise arises from the assumption made when generating the gene activity matrix, which assumes a perfect correlation between promoter/ORF accessibility and gene expression‚Äîsomething that is not always the case.\n\n\nCode\nDefaultAssay(pbmc) &lt;- 'RNA'\n\nFeaturePlot(\n  object = pbmc,\n  features = c('MS4A1', 'CD3D', 'LEF1', 'NKG7', 'TREM1', 'LYZ'),\n  pt.size = 0.1,\n  max.cutoff = 'q95',\n  ncol = 3\n)\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\n\nMS4A1 (CD20): Marker for B lymphocytes.\nCD3D: Part of the T cell receptor complex, indicating T cell presence.\nLEF1: Transcription factor associated with T and B cell differentiation.\nNKG7: Expressed in NK cells and T lymphocytes, related to cytotoxicity.\nTREM1: Present in monocytes and microglia, associated with the inflammatory response.\nLYZ (lysozyme): Expressed in macrophages, involved in defense against bacteria.\n\nThese markers indicate the activation and function of various immune cells."
  },
  {
    "objectID": "Section2_P14_intro.html#signac-workflow",
    "href": "Section2_P14_intro.html#signac-workflow",
    "title": "4¬† Practical 14: scATAC-seq Downstream",
    "section": "4.2 Signac Workflow",
    "text": "4.2 Signac Workflow\n\n\n\nFigure¬†4.1: Single-cell chromatin analysis workflow with Signac."
  },
  {
    "objectID": "Section2_P14_intro.html#label-transfer",
    "href": "Section2_P14_intro.html#label-transfer",
    "title": "4¬† Practical 14: scATAC-seq Downstream",
    "section": "4.3 Label transfer",
    "text": "4.3 Label transfer\nAfter calculating the gene activity scores, we can now integrate the ATAC-seq data with the RNA-seq data.\nThe process begins by identifying anchors, which are pairs of cells‚Äîone from ATAC-seq and one from RNA-seq. To achieve this, we project both datasets into a shared space and identify pairs of cells that are mutual nearest neighbors (MNNs), one from each dataset. These pairs are then filtered to retain the most reliable ones, which serve as the anchors.\nThese anchors allow us to project the ATAC-seq data onto the RNA-seq data, enabling the identification of cell type annotations for nearby cells. In this way, annotations from the RNA-seq data can be transferred to the ATAC-seq data, a method commonly known as label transfer.\n\n4.3.1 Step 4: Integrating with scRNA-seq data (multimodal)\nTo help interpret the scATAC-seq data, we can classify cells based on an scRNA-seq experiment from the same biological system (human PBMC). We utilize methods for cross-modality integration and label transfer, described here, with a more in-depth tutorial here. We aim to identify shared correlation patterns in the gene activity matrix and scRNA-seq dataset to identify matched biological states across the two modalities. This procedure returns a classification score for each cell for each scRNA-seq-defined cluster label.\n\n\n\nFigure¬†4.2: Schematic Overview of Reference ‚ÄúAssembly‚Äù Integration in Seurat v3. From: Stuart, et al.¬†2019. Cell.\n\n\nHere we load a pre-processed scRNA-seq dataset for human PBMCs, also provided by 10x Genomics. You can download the raw data for this experiment from the 10x website, and view the code used to construct this object on GitHub. Alternatively, you can download the pre-processed Seurat object here.\n\n\nCode\n# Load the pre-processed scRNA-seq data for PBMCs\npbmc_rna &lt;- readRDS(\"data/pbmc_10k_v3.rds\")\npbmc_rna &lt;- UpdateSeuratObject(pbmc_rna)\n# free memory\ngc()\n\n\n            used   (Mb) gc trigger    (Mb)   max used    (Mb)\nNcells  12421494  663.4   33927756  1812.0   53012118  2831.2\nVcells 781633956 5963.4 1375246804 10492.4 1363602136 10403.5\n\n\n\n\n4.3.2 Step 5: Find transfer anchors\nFind a set of anchors between a reference and query object. These anchors can later be used to transfer data from the reference to query object using the¬†TransferData¬†object.\n\n\nCode\ntransfer.anchors &lt;- FindTransferAnchors(\n  reference = pbmc_rna, # scRNA\n  query = pbmc, # scATAC\n  reduction = 'cca' # Perform dimensional reduction\n)\n\n\nWarning in size + sum(size_args, na.rm = FALSE): NAs produced by integer\noverflow\nWarning in size + sum(size_args, na.rm = FALSE): NAs produced by integer\noverflow\n\n\nRunning CCA\n\n\nMerging objects\n\n\nFinding neighborhoods\n\n\nFinding anchors\n\n\n    Found 19133 anchors\n\n\n\n\n\n\n\n\nNote\n\n\n\n\nDimensional reduction to perform when finding anchors. Options are:\n\npcaproject: Project the PCA from the reference onto the query. We recommend using Principal Component Analysis (PCA) when reference and query datasets are from scRNA-seq, because PCA effectively captures the variance in gene expression data.\nlsiproject: Project the LSI from the reference onto the query. We recommend using LSI when reference and query datasets are from scATAC-seq. This requires that LSI has been computed for the reference dataset, and the same features (eg, peaks or genome bins) are present in both the reference and query. See RunTFIDF and RunSVD.\nrpca: Project the PCA from the reference onto the query, and the PCA from the query onto the reference (reciprocal PCA projection). This bidirectional approach allows for a more comprehensive alignment of the datasets, potentially enhancing the identification of shared features.\ncca: Canonical Correlation Analysis (CCA) is used to find linear relationships between the reference and query datasets. By identifying the canonical components that maximize the correlation between the two datasets, CCA helps in aligning them based on shared information.\n\n\n\n\n\n4.3.3 Step 7: Annotate scATAC-seq cells via label transfer\nAfter identifying anchors, we can transfer annotations from the scRNA-seq dataset into the scATAC-seq cells. The annotations are stored in the¬†seurat_annotations¬†field, and are provided as input to the¬†refdata¬†parameter. The output will contain a matrix with predictions and confidence scores for each ATAC-seq cell.\n\n\nCode\npredicted.labels &lt;- TransferData(\n  anchorset = transfer.anchors,\n  refdata = pbmc_rna$celltype,\n  weight.reduction = pbmc[['lsi']], # reduction of the original `seurat` object's dim\n  dims = 2:30\n)\n\n\nFinding integration vectors\n\n\nFinding integration vector weights\n\n\nPredicting cell labels\n\n\nCode\npbmc &lt;- AddMetaData(object = pbmc, metadata = predicted.labels)\ngc()# free memory\n\n\n            used   (Mb) gc trigger    (Mb)   max used    (Mb)\nNcells  12482514  666.7   33927756  1812.0   53012118  2831.2\nVcells 784169077 5982.8 1375246804 10492.4 1372406672 10470.7\n\n\nCheck plot\n\n\nCode\nplot1 &lt;- DimPlot(\n  object = pbmc_rna,\n  group.by = 'celltype',\n  label = TRUE,\n  repel = TRUE) + NoLegend() + ggtitle('scRNA-seq')\n\nplot2 &lt;- DimPlot(\n  object = pbmc,\n  group.by = 'predicted.id',\n  label = TRUE,\n  repel = TRUE) + NoLegend() + ggtitle('scATAC-seq (prediction)')\n\nplot1 | plot2 \n\n\n\n\n\n\n\n4.3.4 Step 8: Remove platelets\nThe scRNA-based classifications match the UMAP visualization from the scATAC-seq data. However, a small group of cells is unexpectedly predicted to be platelets, which lack nuclei and shouldn‚Äôt be detected by scATAC-seq. These cells might actually be megakaryocytes, platelet precursors usually found in the bone marrow but rarely in peripheral blood. Given the extreme rarity of megakaryocytes in normal bone marrow (&lt;0.1%), this seems unlikely.\n\n\nCode\nVlnPlot(pbmc, 'prediction.score.max', group.by = 'predicted.id')\n\n\n\n\n\nPlotting the prediction score for the cells assigned to each label reveals that the ‚Äúplatelet‚Äù cells received relatively low scores (&lt; 0.8), indicating a low confidence in the assigned cell identity. In most cases, the next most likely cell identity predicted for these cells was ‚ÄúCD4 naive‚Äù.\n\n\nCode\n# Identify the metadata columns that start with \"prediction.score.\"\nmetadata_attributes &lt;- colnames(pbmc[[]])\nprediction_score_attributes &lt;- grep(\"^prediction.score.\", metadata_attributes, value = TRUE)\nprediction_score_attributes &lt;- setdiff(prediction_score_attributes, \"prediction.score.max\")\n\n# Extract the prediction score attributes for these cells\npredicted_platelets &lt;- which(pbmc$predicted.id == \"Platelet\")\nplatelet_scores &lt;- pbmc[[]][predicted_platelets, prediction_score_attributes]\n\n# Order the columns by their average values in descending order\nordered_columns &lt;- names(sort(colMeans(platelet_scores, na.rm = TRUE), decreasing = TRUE))\nordered_platelet_scores_df &lt;- platelet_scores[, ordered_columns]\n\nhead(ordered_platelet_scores_df)[3]\n\n\n                   prediction.score.CD4.Memory\nACAAAGAAGACACGGT-1                 0.025746481\nCACTAAGGTAATGTAG-1                 0.008556831\nCTCAACCAGCGAGCTA-1                 0.024011379\nGAATCTGCATAGTCCA-1                 0.016515476\nGCTTAAGCAAAGGTCG-1                 0.020222801\nGTCACCTGTCAGGCTC-1                 0.025835081\n\n\nAs there are only a very small number of cells classified as ‚Äúplatelets‚Äù (&lt; 20), it is difficult to figure out their precise cellular identity. Larger datasets would be required to confidently identify specific peaks for this population of cells, and further analysis performed to correctly annotate them. For downstream analysis we will thus remove the extremely rare cell states that were predicted, retaining only cell annotations with &gt;20 cells total.\n\n\nCode\npredicted_id_counts &lt;- table(pbmc$predicted.id)\n\n# Identify the predicted.id values that have more than 20 cells\nmajor_predicted_ids &lt;- names(predicted_id_counts[predicted_id_counts &gt; 20])\npbmc &lt;- pbmc[, pbmc$predicted.id %in% major_predicted_ids]\n\n\nFor downstream analyses, we can simply reassign the identities of each cell from their UMAP cluster index to the per-cell predicted labels. It is also possible to consider merging the cluster indexes and predicted labels.\n\n\nCode\n# change cell identities to the per-cell predicted labels\nIdents(pbmc) &lt;- pbmc$predicted.id\n\n\n\n\n4.3.5 Step 9: Rename labels\nReplace each cluster label with its most likely predicted label\n\n\nCode\nfor(i in levels(pbmc)) {\n  cells_to_reid &lt;- WhichCells(pbmc, idents = i)\n  newid &lt;- names(which.max(table(pbmc$predicted.id[cells_to_reid])))\n  Idents(pbmc, cells = cells_to_reid) &lt;- newid\n}\n\n\n\n\n4.3.6 Step 10: Compare the results\n\n\nCode\n# scRNA-seq\nplot1 &lt;- DimPlot(pbmc_rna, group.by = \"celltype\", label = TRUE) + NoLegend() + ggtitle(\"scRNA-seq\")\n# Gene matrix\nplot2 &lt;- DimPlot(pbmc, group.by = \"predicted.id\", label = TRUE) + NoLegend() + ggtitle(\"scATAC-seq (prediction)\")\n# Integration\nplot3 &lt;- DimPlot(pbmc, label = T, group.by = \"ident\") + NoLegend() + ggtitle(\"scATAC-seq (integration)\")\nplot1 + plot2 + plot3\n\n\n\n\n\n\n\nCode\ngc() # free memory\n\n\n            used   (Mb) gc trigger    (Mb)   max used    (Mb)\nNcells  12538994  669.7   33927756  1812.0   53012118  2831.2\nVcells 910234497 6944.6 1656861375 12640.9 1425584654 10876.4\n\n\nCode\nsave(pbmc, file = \"data/pbmc_edited.RData\")"
  },
  {
    "objectID": "Section2_P14_intro.html#find-differentially-accessible-peaks-between-cell-types",
    "href": "Section2_P14_intro.html#find-differentially-accessible-peaks-between-cell-types",
    "title": "4¬† Practical 14: scATAC-seq Downstream",
    "section": "4.4 Find differentially accessible peaks between cell types",
    "text": "4.4 Find differentially accessible peaks between cell types\nIn transcriptomic studies, we analyze differentially transcribed genes, so it is logical to study in ATAC-seq the genomic regions that are differentially accessible to the Tn5 transposase. To investigate differential chromatin accessibility, logistic regressions are used, as recommended by Ntranos et al. 2018, and the total number of reads is included as a latent variable to mitigate the negative impact on results when dealing with libraries/samples with different sequencing depths.\nA¬†simple approach is to perform a Wilcoxon rank sum test, and the¬†presto¬†package has implemented an extremely fast Wilcoxon test that can be run on a Seurat object.\n\n\nCode\nif (!requireNamespace(\"remotes\", quietly = TRUE))\n  install.packages('remotes')\nremotes::install_github('immunogenomics/presto')\n\n\nFor sparse data like scATAC-seq, it is necessary to adjust the min.pct parameter of the FindMarkers() function to lower values, as the default value (0.1) is designed for scRNA-seq data. Here we will focus on comparing Naive CD4 cells and CD14 monocytes, but any groups of cells can be compared using these methods. We can also visualize these marker peaks on a violin plot, feature plot, dot plot, heat map, or any¬†visualization tool in Seurat.\n\n\nCode\nlibrary(presto)\n# change back to working with peaks instead of gene activities\nDefaultAssay(pbmc) &lt;- 'peaks'\n\n# wilcox is the default option for test.use\nda_peaks &lt;- FindMarkers(\n  object = pbmc,\n  ident.1 = \"CD4 Naive\",\n  ident.2 = \"CD14+ Monocytes\",\n  test.use = 'wilcox',\n  min.pct = 0.1\n)\n\nhead(da_peaks)\n\n\n                          p_val avg_log2FC pct.1 pct.2 p_val_adj\nchr6-13302533-13303459        0  -5.308082 0.025 0.771         0\nchr19-54207815-54208728       0  -4.370882 0.050 0.794         0\nchr17-78198651-78199583       0  -5.653591 0.023 0.760         0\nchr12-119988511-119989430     0   4.163235 0.782 0.090         0\nchr7-142808530-142809435      0   3.665895 0.759 0.088         0\nchr17-82126458-82127377       0   5.017039 0.699 0.042         0\n\n\nCode\n# save\nsave(da_peaks, file = \"data/da_peaks.RData\")\n\n\nWe visualize the results of the differential accessibility test using a violin plot and over the UMAP projection.\n\n\nCode\nplot1 &lt;- VlnPlot(\n  object = pbmc,\n  features = rownames(da_peaks)[1],\n  pt.size = 0.1,\n  idents = c(\"CD4 Naive\",\"CD14+ Monocytes\")\n)\nplot2 &lt;- FeaturePlot(\n  object = pbmc,\n  features = rownames(da_peaks)[1],\n  pt.size = 0.1\n)\n\nplot1 | plot2\n\n\n\n\n\nPeak coordinates can be difficult to interpret alone. We can find the closest gene to each of these peaks using the¬†ClosestFeature()¬†function.\n\n\nCode\nopen_cd4naive &lt;- rownames(da_peaks[da_peaks$avg_log2FC &gt; 3, ])\nopen_cd14mono &lt;- rownames(da_peaks[da_peaks$avg_log2FC &lt; -3, ])\n\nclosest_genes_cd4naive &lt;- ClosestFeature(pbmc, regions = open_cd4naive)\nclosest_genes_cd14mono &lt;- ClosestFeature(pbmc, regions = open_cd14mono)\n# results\nhead(closest_genes_cd4naive)\n\n\n                          tx_id    gene_name         gene_id   gene_biotype\nENSE00002206071 ENST00000397558       BICDL1 ENSG00000135127 protein_coding\nENST00000632998 ENST00000632998        PRSS2 ENSG00000275896 protein_coding\nENST00000583593 ENST00000583593       CCDC57 ENSG00000176155 protein_coding\nENST00000393054 ENST00000393054     ATP6V0A4 ENSG00000105929 protein_coding\nENST00000545320 ENST00000545320          CD6 ENSG00000013725 protein_coding\nENST00000509332 ENST00000509332 RP11-18H21.1 ENSG00000245954        lincRNA\n                type            closest_region              query_region\nENSE00002206071 exon chr12-119989869-119990297 chr12-119988511-119989430\nENST00000632998  utr  chr7-142774509-142774564  chr7-142808530-142809435\nENST00000583593  gap   chr17-82108955-82127691   chr17-82126458-82127377\nENST00000393054  cds  chr7-138752625-138752837  chr7-138752283-138753197\nENST00000545320  gap   chr11-60971915-60987907   chr11-60985909-60986801\nENST00000509332  gap  chr4-152100818-152101483  chr4-152100248-152101142\n                distance\nENSE00002206071      438\nENST00000632998    33965\nENST00000583593        0\nENST00000393054        0\nENST00000545320        0\nENST00000509332        0\n\n\nCode\nhead(closest_genes_cd14mono)\n\n\n                          tx_id     gene_name         gene_id   gene_biotype\nENST00000606214 ENST00000606214        TBC1D7 ENSG00000145979 protein_coding\nENST00000448962 ENST00000448962          RPS9 ENSG00000170889 protein_coding\nENST00000592988 ENST00000592988         AFMID ENSG00000183077 protein_coding\nENSE00001638912 ENST00000455005 RP5-1120P11.3 ENSG00000231881        lincRNA\nENST00000635379 ENST00000635379     LINC01588 ENSG00000214900        lincRNA\nENSE00001389095 ENST00000340607         PTGES ENSG00000148344 protein_coding\n                type           closest_region             query_region distance\nENST00000606214  gap   chr6-13267836-13305061   chr6-13302533-13303459        0\nENST00000448962  gap  chr19-54201610-54231740  chr19-54207815-54208728        0\nENST00000592988  gap  chr17-78191061-78202498  chr17-78198651-78199583        0\nENSE00001638912 exon   chr6-44073913-44074798   chr6-44058439-44059230    14682\nENST00000635379  gap  chr14-50039258-50039391  chr14-50038381-50039286        0\nENSE00001389095 exon chr9-129752887-129753047 chr9-129776928-129777838    23880"
  },
  {
    "objectID": "Section2_P14_intro.html#go-enrichment-analysis-with-clusterprofiler",
    "href": "Section2_P14_intro.html#go-enrichment-analysis-with-clusterprofiler",
    "title": "4¬† Practical 14: scATAC-seq Downstream",
    "section": "4.5 GO enrichment analysis with clusterProfiler",
    "text": "4.5 GO enrichment analysis with clusterProfiler\nWe could follow up with this result by doing gene ontology enrichment analysis on the gene sets returned by¬†ClosestFeature(),and there are many R packages that can do this (see theGOstats¬†or¬†clusterProfiler¬†packages for example).\n\n\nCode\nlibrary(clusterProfiler)\nlibrary(org.Hs.eg.db)\nlibrary(enrichplot)\n\n\n\n\nCode\ncd4naive_ego &lt;- enrichGO(gene = closest_genes_cd4naive$gene_id, # like DEG\n                keyType = \"ENSEMBL\", \n                OrgDb = org.Hs.eg.db, # organism\n                ont = \"BP\", # Biological process\n                pAdjustMethod = \"BH\", # Benjamini-Hochberg (BH)\n                pvalueCutoff = 0.05,\n                qvalueCutoff = 0.05,\n                readable = TRUE) # Convert the gene identifiers (ENSEMBL) to readable gene names.\n\nbarplot(cd4naive_ego,showCategory = 20)\n\n\n\n\n\n\n\nCode\ncd14mono_ego &lt;- enrichGO(gene = closest_genes_cd14mono$gene_id,\n                keyType = \"ENSEMBL\",\n                OrgDb = org.Hs.eg.db,\n                ont = \"BP\",\n                pAdjustMethod = \"BH\",\n                pvalueCutoff = 0.05,\n                qvalueCutoff = 0.05,\n                readable = TRUE)\n\nbarplot(cd14mono_ego,showCategory = 20)"
  },
  {
    "objectID": "Section2_P14_intro.html#plotting-genomic-regions",
    "href": "Section2_P14_intro.html#plotting-genomic-regions",
    "title": "4¬† Practical 14: scATAC-seq Downstream",
    "section": "4.6 Plotting genomic regions",
    "text": "4.6 Plotting genomic regions\nWe can visualize the frequency of Tn5 integration across genomic regions for cells grouped by cluster, cell type, or any other metadata stored in the object using the CoveragePlot() function. These plots represent pseudo-bulk accessibility tracks, where the signal from all cells within a group is averaged to display DNA accessibility in a specific region. (Credit to Andrew Hill for the inspiration behind this function, as highlighted in his excellent blog post.) In addition to accessibility tracks, we can include other key information such as gene annotations, peak coordinates, and genomic links (if available in the object). For further details, refer to the visualization vignette.\nFor plotting purposes, it‚Äôs nice to have related cell types grouped together. We can automatically sort the plotting order according to similarities across the annotated cell types by running the¬†SortIdents()¬†function:\n\n\nCode\npbmc &lt;- SortIdents(pbmc)\n\n\nCreating pseudobulk profiles for 13 variables across 165376 features\n\n\nComputing euclidean distance between pseudobulk profiles\n\n\nClustering distance matrix\n\n\nWe can then visualize the DA peaks open in CD4 naive cells and CD14 monocytes, near some key marker genes for these cell types, CD4 and LYZ respectively. Here we‚Äôll highlight the DA peaks regions in grey.\n\n\nCode\n# find DA peaks overlapping gene of interest\nregions_highlight &lt;- subsetByOverlaps(StringToGRanges(open_cd4naive), LookupGeneCoords(pbmc, \"CD4\"))\n\nCoveragePlot(\n  object = pbmc,\n  region = \"CD4\",\n  region.highlight = regions_highlight,\n  extend.upstream = 1000,\n  extend.downstream = 1000\n)\n\n\nWarning: Removed 22 rows containing missing values or values outside the scale range\n(`geom_segment()`).\n\n\nWarning: Removed 3 rows containing missing values or values outside the scale range\n(`geom_segment()`).\n\n\nWarning: Removed 1 row containing missing values or values outside the scale range\n(`geom_segment()`)."
  },
  {
    "objectID": "Section2_P14_intro.html#references",
    "href": "Section2_P14_intro.html#references",
    "title": "4¬† Practical 14: scATAC-seq Downstream",
    "section": "5.1 References",
    "text": "5.1 References\n\nStuart, et al.¬†2019. Comprehensive Integration of Single-Cell Data. Cell.\nSingle-cell ATAC sequencing\nHeumos, et al . 2023. Best practices for single-cell analysis across modalities. Nature reviews genetics.\nSignac tutorial - Create a gene activity matrix\nSignac tutorial - scATAC-seq data integration\nSignac tutorial - Integrating scRNA-seq and scATAC-seq data\nSignac tutorial - Calling peaks\nAn√°lisis de datos scATAC-seq en Signac: cerebro murino"
  },
  {
    "objectID": "Section2_P14_retos.html",
    "href": "Section2_P14_retos.html",
    "title": "5¬† Exercises",
    "section": "",
    "text": "Code\nlibrary(presto)\nload(\"data/pbmc_edited.RData\")\n# change back to working with peaks instead of gene activities\nDefaultAssay(pbmc) &lt;- 'peaks'\n\n# wilcox is the default option for test.use\nda_peaks &lt;- FindMarkers(\n  object = pbmc,\n  ident.1 = \"CD4 Naive\",\n  ident.2 = \"CD14+ Monocytes\",\n  test.use = 'wilcox',\n  min.pct = 0.1\n)\n\nhead(da_peaks)\n\nplot1 &lt;- VlnPlot(\n  object = pbmc,\n  features = rownames(da_peaks)[1],\n  pt.size = 0.1,\n  idents = c(\"CD4 Naive\",\"CD14+ Monocytes\")\n)\nplot2 &lt;- FeaturePlot(\n  object = pbmc,\n  features = rownames(da_peaks)[1],\n  pt.size = 0.1\n)\n\nplot1 | plot2"
  },
  {
    "objectID": "Section2_P15_intro.html",
    "href": "Section2_P15_intro.html",
    "title": "6¬† Practical 15: Multimodal analysis and Integration",
    "section": "",
    "text": "7 Batch Effect Correction\nVariation in different¬†Chromium Single Cell ATAC¬†(Assay for Transposase Accessible Chromatin) samples can be affected by technical factors, such as laboratory conditions or reagent choices. These batch effects may confound true biological variation between samples. Therefore, correcting the batch effects can be useful for data analysis.\nIf you are combining libraries generated by Chromium Single Cell ATAC v1.1 and v2 reagents, you might observe systematic differences in chromatin structure profiles between libraries. Here, we will demonstrate how to use community-developed tools to merge and correct batch effects between Single Cell ATAC v1.1 and v2 data. The same procedure could also be used to correct other types of batch effects.\nflowchart LR    \n  A{Integrating with scRNA-seq data} --&gt; B(Gene activity matrix approach - \\nRNA imputation)     \n  A --&gt; C(Dictionary Learning for cross-modality \\nintegration - Bridge integration)\n  B --&gt; D[Check Biomarkers]\n  C --&gt; D\nRecently, single cell multi-omics methods that run several assays on the same cells have become available. One such method is¬†Chromium Single Cell Multiome from 10X genomics, which simultaneously measures gene expression (RNA-seq) and chromatin accessibility (ATAC-seq) in the same nuclei. This makes it possible to identify cell types and states based on both gene expression and accessibility. It also makes it easy to use external gene expression data to annotate your cells, and at the same time study the chromatin accessibility in the cells."
  },
  {
    "objectID": "Section2_P15_intro.html#option-1-merging-objects",
    "href": "Section2_P15_intro.html#option-1-merging-objects",
    "title": "6¬† Practical 15: Multimodal analysis and Integration",
    "section": "7.1 Option 1: Merging objects",
    "text": "7.1 Option 1: Merging objects\nWhen merging multiple single-cell chromatin datasets, it‚Äôs important to be aware that if peak calling was performed on each dataset independently, the peaks are unlikely to be exactly the same. We therefore need to create a common set of peaks across all the datasets to be merged.\nThe two datasets used in this example can be found here:¬†dataset 1: 10k Human PBMCs, ATAC v1.1 cells¬†and¬†dataset 2: 10k Human PBMCs, ATAC v2 cells.\n\n\n\n\n\n\nDownload the datasets\n\n\n\n\n\nFrom: Batch Effect Correction in Chromium Single Cell ATAC Data\n\n\nCode\n# Set working directory before downloading files\nsetwd(\"data\")\n\n# Download dataset 1 filtered_peak_bc_matrix.h5 file\n\ndownload.file(\"https://cf.10xgenomics.com/samples/cell-atac/2.1.0/10k_pbmc_ATACv1p1_nextgem_Chromium_X/10k_pbmc_ATACv1p1_nextgem_Chromium_X_filtered_peak_bc_matrix.h5\",\"10k_pbmc_ATACv1p1_nextgem_Chromium_X_filtered_peak_bc_matrix.h5\")\n\n# Download dataset 2 filtered_peak_bc_matrix.h5 file\n\ndownload.file(\"https://cf.10xgenomics.com/samples/cell-atac/2.1.0/10k_pbmc_ATACv2_nextgem_Chromium_X/10k_pbmc_ATACv2_nextgem_Chromium_X_filtered_peak_bc_matrix.h5\",\"10k_pbmc_ATACv2_nextgem_Chromium_X_filtered_peak_bc_matrix.h5\")"
  },
  {
    "objectID": "Section2_P15_intro.html#option-2-harmony-batch-effect",
    "href": "Section2_P15_intro.html#option-2-harmony-batch-effect",
    "title": "6¬† Practical 15: Multimodal analysis and Integration",
    "section": "7.2 Option 2: Harmony batch effect",
    "text": "7.2 Option 2: Harmony batch effect\nWe can use the¬†Harmony batch effect correction algorithm¬†(Korsunsky et al.¬†2019) implemented in the¬†Signac R package. The¬†Harmony algorithm¬†is available on GitHub, and Signac has¬†tutorials for integration.\n\n\nCode\nhm.integrated &lt;- RunHarmony(object = unintegrated, group.by.vars = 'dataset', reduction = 'lsi', assay.use = 'peaks', project.dim = FALSE)\nhm.integrated &lt;- RunUMAP(hm.integrated, dims = 2:30, reduction = 'harmony')\nDimPlot(hm.integrated, group.by = 'dataset', pt.size = 0.1)"
  },
  {
    "objectID": "Section2_P15_intro.html#option-3-scatac-seq-data-integration",
    "href": "Section2_P15_intro.html#option-3-scatac-seq-data-integration",
    "title": "6¬† Practical 15: Multimodal analysis and Integration",
    "section": "7.3 Option 3: scATAC-seq data integration",
    "text": "7.3 Option 3: scATAC-seq data integration\nAn important first step in any integrative analysis of single-cell chromatin data is to ensure that the same features are measured in each dataset. Here, we quantify the multiome peaks in the ATAC dataset to ensure that there are common features across the two datasets. See the¬†merge vignette¬†for more information about merging chromatin assays."
  },
  {
    "objectID": "Section2_P15_intro.html#common-peak-set",
    "href": "Section2_P15_intro.html#common-peak-set",
    "title": "6¬† Practical 15: Multimodal analysis and Integration",
    "section": "7.4 Common peak set",
    "text": "7.4 Common peak set\nIf the peaks were identified independently in each experiment then they will likely not overlap perfectly. We can merge peaks from all the datasets to create a common peak set, and quantify this peak set in each experiment prior to merging the objects.\nFirst we‚Äôll load the peak coordinates for each experiment and convert them to genomic ranges, the use the GenomicRanges::reduce function to create a common set of peaks to quantify in each dataset.\n\n\n\n\nflowchart LR    \n  A(Create a common peak set) --&gt; B(Create fragment objects)     \n  A --&gt; C(Quantify peaks in each dataset)\n  C --&gt; D(Create the objects)\n  D --&gt; E(Merge objects)\n  E --&gt; F(Merging without a \\ncommon feature set)"
  },
  {
    "objectID": "Section2_P15_intro.html#option-b-dictionary-learning-for-cross-modality-integration-bridge-integration",
    "href": "Section2_P15_intro.html#option-b-dictionary-learning-for-cross-modality-integration-bridge-integration",
    "title": "6¬† Practical 15: Multimodal analysis and Integration",
    "section": "8.1 Option B: Dictionary Learning for cross-modality integration / Bridge integration",
    "text": "8.1 Option B: Dictionary Learning for cross-modality integration / Bridge integration\n\n\n\nBroad schematic of the bridge integration workflow. From: Seurat v5, Hao et al, 2023. Nature biotechnology\n\n\n\n8.1.1 Step 1: Load the bridge, query, and reference datasets (each modality individually)\nInput files:\n\n10x multiome dataset: Consisting of ~12,000 PBMC from a helthy donor. The dataset measures scRNA-seq and scATAC-seq in the same cell, and is available for download from 10x Genomics here.\nscATAC-seq Query: Represents ~10,000 PBMC from a healthy donor, and is available for download here.\nReference from Azimuth: We load the reference (download here) from this recent paper. This reference is stored as an h5Seurat file, a format that enables on-disk storage of multimodal Seurat objects (more details on h5Seurat and SeuratDisk can be found here).\n\n\n\n\n\n\n\nView data download code\n\n\n\n\n\nTotal 2.7 Gb\n# 10x multiome dataset \n# Raw data \nwget https://cf.10xgenomics.com/samples/cell-arc/2.0.0/pbmc_granulocyte_sorted_10k/pbmc_granulocyte_sorted_10k_filtered_feature_bc_matrix.h5 \n# fragments file \nwget https://cf.10xgenomics.com/samples/cell-arc/2.0.0/pbmc_granulocyte_sorted_10k/pbmc_granulocyte_sorted_10k_atac_fragments.tsv.gz \n# fragments index \nwget https://cf.10xgenomics.com/samples/cell-arc/2.0.0/pbmc_granulocyte_sorted_10k/pbmc_granulocyte_sorted_10k_atac_fragments.tsv.gz.tbi  \n\n# scATAC-seq Query (Total 2.7 Gb) \n# Raw data  \nwget https://cf.10xgenomics.com/samples/cell-atac/2.1.0/10k_pbmc_ATACv2_nextgem_Chromium_Controller/10k_pbmc_ATACv2_nextgem_Chromium_Controller_filtered_peak_bc_matrix.h5 \n# metadata \nwget https://cf.10xgenomics.com/samples/cell-atac/2.1.0/10k_pbmc_ATACv2_nextgem_Chromium_Controller/10k_pbmc_ATACv2_nextgem_Chromium_Controller_singlecell.csv \n# fragments file \nwget https://cf.10xgenomics.com/samples/cell-atac/2.1.0/10k_pbmc_ATACv2_nextgem_Chromium_Controller/10k_pbmc_ATACv2_nextgem_Chromium_Controller_fragments.tsv.gz \n# fragments index \nwget https://cf.10xgenomics.com/samples/cell-atac/2.1.0/10k_pbmc_ATACv2_nextgem_Chromium_Controller/10k_pbmc_ATACv2_nextgem_Chromium_Controller_fragments.tsv.gz.tbi  \n\n# Azimuth Reference (Total 9 Gb)\nwget https://atlas.fredhutch.org/data/nygc/multimodal/pbmc_multimodal.h5seurat\n\n\n\nLoad and setup the 10x multiome object.\n\n\nCode\nlibrary(Seurat)\nlibrary(Signac)\nlibrary(EnsDb.Hsapiens.v86)\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(glmGamPoi)\n\n# the 10x hdf5 file contains both data types.\ninputdata.10x &lt;- Read10X_h5(\"/brahms/hartmana/vignette_data/pbmc_cellranger_arc_2/pbmc_granulocyte_sorted_10k_filtered_feature_bc_matrix.h5\")\n# extract RNA and ATAC data\nrna_counts &lt;- inputdata.10x$`Gene Expression`\natac_counts &lt;- inputdata.10x$Peaks\n# Create Seurat object\nobj.multi &lt;- CreateSeuratObject(counts = rna_counts)\n# Get % of mitochondrial genes\nobj.multi[[\"percent.mt\"]] &lt;- PercentageFeatureSet(obj.multi, pattern = \"^MT-\")\n\n# add the ATAC-seq assay\ngrange.counts &lt;- StringToGRanges(rownames(atac_counts), sep = c(\":\", \"-\"))\ngrange.use &lt;- seqnames(grange.counts) %in% standardChromosomes(grange.counts)\natac_counts &lt;- atac_counts[as.vector(grange.use), ]\n# Get gene annotations\nannotations &lt;- GetGRangesFromEnsDb(ensdb = EnsDb.Hsapiens.v86)\n# Change style to UCSC\nseqlevelsStyle(annotations) &lt;- 'UCSC'\ngenome(annotations) &lt;- \"hg38\"\n# File with ATAC per fragment information file\nfrag.file &lt;- \"/brahms/hartmana/vignette_data/pbmc_cellranger_arc_2/pbmc_granulocyte_sorted_10k_atac_fragments.tsv.gz\"\n# Add in ATAC-seq data as ChromatinAssay object\nchrom_assay &lt;- CreateChromatinAssay(\n  counts = atac_counts,\n  sep = c(\":\", \"-\"),\n  genome = 'hg38',\n  fragments = frag.file,\n  min.cells = 10,\n  annotation = annotations\n)\n\n# Add the ATAC assay to the multiome object\nobj.multi[[\"ATAC\"]] &lt;- chrom_assay\n# Filter ATAC data based on QC metrics\nobj.multi &lt;- subset(\n  x = obj.multi,\n  subset = nCount_ATAC &lt; 7e4 &\n    nCount_ATAC &gt; 5e3 &\n    nCount_RNA &lt; 25000 &\n    nCount_RNA &gt; 1000 &\n    percent.mt &lt; 20\n)\n\n\nWe note that it is important to quantify the same set of genomic features in the query dataset as are quantified in the multi-omic bridge. We therefore requantify the set of scATAC-seq peaks using the¬†FeatureMatrix¬†command. This is also described in the¬†Signac vignettes¬†and shown below.\nLoad and setup the 10x scATAC-seq query.\n\n\nCode\n# Load ATAC dataset\natac_pbmc_data &lt;- Read10X_h5(filename = \"data/10k_PBMC_ATAC_nextgem_Chromium_X_filtered_peak_bc_matrix.h5\") \nfragpath &lt;- \"data/10k_PBMC_ATAC_nextgem_Chromium_X_fragments.tsv.gz\"\n# Get gene annotations\nannotation &lt;- GetGRangesFromEnsDb(ensdb = EnsDb.Hsapiens.v86)\n# Change to UCSC style \nseqlevelsStyle(annotation) &lt;- 'UCSC'\n# Create ChromatinAssay for ATAC data\natac_pbmc_assay &lt;- CreateChromatinAssay(\n  counts = atac_pbmc_data,\n  sep = c(\":\", \"-\"),\n  fragments = fragpath,\n  annotation = annotation\n)\n# Requantify query ATAC to have same features as multiome ATAC dataset\nrequant_multiome_ATAC &lt;- FeatureMatrix(\n  fragments = Fragments(atac_pbmc_assay),\n  features = granges(obj.multi[['ATAC']]),\n  cells = Cells(atac_pbmc_assay)\n)\n# Create assay with requantified ATAC data\nATAC_assay &lt;- CreateChromatinAssay(\n  counts = requant_multiome_ATAC,\n  fragments = fragpath,\n  annotation = annotation\n)\n# Create Seurat sbject\nobj.atac  &lt;- CreateSeuratObject(counts = ATAC_assay,assay = 'ATAC')\nobj.atac[['peak.orig']] &lt;- atac_pbmc_assay\nobj.atac &lt;- subset(obj.atac, subset = nCount_ATAC &lt; 7e4 & nCount_ATAC &gt; 2000)\n\n\nDownload Azimuth reference and load it.\n\n\nCode\nobj.rna &lt;- readRDS(\"data/pbmc_multimodal_2023.rds\")\n\n\n\n\n8.1.2 Step 2: Preprocessing/normalization for all datasets\nPrior to performing bridge integration, we normalize and pre-process each of the datasets (note that the reference has already been normalized). We normalize gene expression data using¬†sctransform, and ATAC data using TF-IDF.\n\n\nCode\n# normalize multiome RNA\nDefaultAssay(obj.multi) &lt;- \"RNA\"\nobj.multi &lt;- SCTransform(obj.multi, verbose = FALSE)\n# normalize multiome ATAC\nDefaultAssay(obj.multi) &lt;- \"ATAC\"\nobj.multi &lt;- RunTFIDF(obj.multi)\nobj.multi &lt;- FindTopFeatures(obj.multi, min.cutoff = \"q0\")\n# normalize query\nobj.atac &lt;- RunTFIDF(obj.atac)\n\n\n\n\n8.1.3 Step 3: Map scATAC-seq dataset using bridge integration\nNow that we have the reference, query, and bridge datasets set up, we can begin integration. The bridge dataset enables translation between the scRNA-seq reference and the scATAC-seq query, effectively augmenting the reference so that it can map a new data type. We call this an extended reference, and first set it up. Note that you can save the results of this function and map multiple scATAC-seq datasets without having to rerun.\nFirst, we drop the first dimension of the ATAC reduction.\n\n\nCode\ndims.atac &lt;- 2:50\ndims.rna &lt;- 1:50\nDefaultAssay(obj.multi) &lt;-  \"RNA\"\nDefaultAssay(obj.rna) &lt;- \"SCT\"\nobj.rna.ext &lt;- PrepareBridgeReference(\n  reference = obj.rna, bridge = obj.multi,\n  reference.reduction = \"spca\", reference.dims = dims.rna,\n  normalization.method = \"SCT\")\n\n\nNow, we can directly find anchors between the extended reference and query objects. We use the¬†FindBridgeTransferAnchors¬†function, which translates the query dataset using the same dictionary as was used to translate the reference, and then identifies anchors in this space. The function is meant to mimic our¬†FindTransferAnchors¬†function, but to identify correspondences across modalities.\n\n\nCode\nbridge.anchor &lt;- FindBridgeTransferAnchors(\n  extended.reference = obj.rna.ext, query = obj.atac,\n  reduction = \"lsiproject\", dims = dims.atac)\n\n\nOnce we have identified anchors, we can map the query dataset onto the reference. The¬†MapQuery¬†function is the same as we have¬†previously introduced for reference mapping¬†. It transfers cell annotations from the reference dataset, and also visualizes the query dataset on a previously computed UMAP embedding. Since our reference dataset contains cell type annotations at three levels of resolution (l1 - l3), we can transfer each level to the query dataset.\n\n\nCode\nobj.atac &lt;- MapQuery(\n  anchorset = bridge.anchor, reference = obj.rna.ext,\n  query = obj.atac,\n  refdata = list(\n    l1 = \"celltype.l1\",\n    l2 = \"celltype.l2\",\n    l3 = \"celltype.l3\"),\n  reduction.model = \"wnn.umap\")\n\n\nNow we can visualize the results, plotting the scATAC-seq cells based on their predicted annotations, on the reference UMAP embedding. You can see that each scATAC-seq cell has been assigned a cell name based on the scRNA-seq defined cell ontology.\n\n\nCode\n# plot\nDimPlot(\n  obj.atac, group.by = \"predicted.l2\",\n  reduction = \"ref.umap\", label = TRUE\n) + ggtitle(\"ATAC\") + NoLegend()\n\n\n\n\n8.1.4 Step 4: Assessing the mapping\nTo assess the mapping and cell type predictions, we will first see if the predicted cell type labels are concordant with an unsupervised analysis of the scATAC-seq dataset. We follow the standard unsupervised processing workflow for scATAC-seq data:\n\n\nCode\nobj.atac &lt;- FindTopFeatures(obj.atac, min.cutoff = \"q0\")\nobj.atac &lt;- RunSVD(obj.atac)\nobj.atac &lt;- RunUMAP(obj.atac, reduction = \"lsi\", dims = 2:50)\n\n\nNow, we visualize the predicted cluster labels on the unsupervised UMAP emebdding. We can see that predicted cluster labels (from the scRNA-seq reference) are concordant with the structure of the scATAC-seq data. However, there are some cell types (i.e.¬†Treg), that do not appear to separate in unsupervised analysis. These may be prediction errors, or cases where the reference mapping provides additional resolution.\n\n\nCode\nDimPlot(obj.atac, group.by = \"predicted.l2\", reduction = \"umap\", label = FALSE)\n\n\n\n\n\n\n\nLastly, we validate the predicted cell types for the scATAC-seq data by examining their chromatin accessibility profiles at canonical loci. We use the¬†CoveragePlot¬†function to visualize accessibility patterns at the CD8A, FOXP3, and RORC, after grouping cells by their predicted labels. We see expected patterns in each case. For example, the PAX5 locus exhibits peaks that are accessible exclusively in B cells, and the CD8A locus shows the same in CD8 T cell subsets. Similarly, the accessibility of FOXP3, a canonical marker of regulatory T cells (Tregs), in predicted Tregs provides strong support for the accuracy of our prediction.\n\n\nCode\nCoveragePlot(\n  obj.atac, region  = \"PAX5\", group.by = \"predicted.l1\",\n  idents = c(\"B\", \"CD4 T\", \"Mono\", \"NK\"), window = 200,\n  extend.upstream = -150000)"
  },
  {
    "objectID": "Section2_P15_intro.html#joint-rna-and-atac-analysis-10x-multiomic",
    "href": "Section2_P15_intro.html#joint-rna-and-atac-analysis-10x-multiomic",
    "title": "6¬† Practical 15: Multimodal analysis and Integration",
    "section": "9.1 Joint RNA and ATAC analysis: 10x multiomic",
    "text": "9.1 Joint RNA and ATAC analysis: 10x multiomic\nIn this tutorial, we‚Äôll demonstrate how to jointly analyze a single-cell dataset measuring both DNA accessibility and gene expression in the same cells using Signac and Seurat. In this vignette we‚Äôll be using a publicly available 10x Genomic Multiome dataset for human PBMCs."
  },
  {
    "objectID": "Section2_P15_intro.html#dataset-overview",
    "href": "Section2_P15_intro.html#dataset-overview",
    "title": "6¬† Practical 15: Multimodal analysis and Integration",
    "section": "9.2 Dataset overview",
    "text": "9.2 Dataset overview\nLibraries generated:\n\nChromium Single Cell Multiome ATAC library\nChromium Single Cell Multiome Gene Expression library\n\n\n\n\n\n\n\nView data download code\n\n\n\n\n\n# multiomic data  \nwget https://cf.10xgenomics.com/samples/cell-arc/1.0.0/pbmc_granulocyte_sorted_10k/pbmc_granulocyte_sorted_10k_filtered_feature_bc_matrix.h5\n# fragments file \nwget https://cf.10xgenomics.com/samples/cell-arc/1.0.0/pbmc_granulocyte_sorted_10k/pbmc_granulocyte_sorted_10k_atac_fragments.tsv.gz\n# fragments index \nwget https://cf.10xgenomics.com/samples/cell-arc/1.0.0/pbmc_granulocyte_sorted_10k/pbmc_granulocyte_sorted_10k_atac_fragments.tsv.gz.tbi\n\n\n\n\n9.2.1 üìó Step 1: Load the data and create the Seurat object\n\n\nCode\nlibrary(Signac)\nlibrary(Seurat)\nlibrary(EnsDb.Hsapiens.v86) # Ensembl based annotation package (hg37)\n# BiocManager::install(\"BSgenome.Hsapiens.UCSC.hg38\")\nlibrary(BSgenome.Hsapiens.UCSC.hg38) # Full genomic sequences for Homo sapiens (UCSC genome hg38)\n\n\n\n\nCode\nlibrary(future)\n\n\n\nAttaching package: 'future'\n\n\nThe following object is masked from 'package:AnnotationFilter':\n\n    value\n\n\nCode\n# parallelization options\nplan(\"multicore\", workers = 8)\n# Increase the maximum memory usage\noptions(future.globals.maxSize = 14 * 1024^3)  # para 14 GB de RAM\n\n\nLoad data and add annotation:\n\n\nCode\n# load the RNA and ATAC data\ncounts &lt;- Read10X_h5(\"data/pbmc_granulocyte_sorted_10k_filtered_feature_bc_matrix.h5\")\nfragpath &lt;- \"data/pbmc_granulocyte_sorted_10k_atac_fragments.tsv.gz\"\n# get gene annotations for hg38\nannotation &lt;- GetGRangesFromEnsDb(ensdb = EnsDb.Hsapiens.v86)\nseqlevels(annotation) &lt;- paste0('chr', seqlevels(annotation))\n\n# create a Seurat object containing the RNA adata\npbmc &lt;- CreateSeuratObject(\n  counts = counts$`Gene Expression`,\n  assay = \"RNA\"\n)\n\n# create ATAC assay and add it to the object\npbmc[[\"ATAC\"]] &lt;- CreateChromatinAssay(\n  counts = counts$Peaks,\n  sep = c(\":\", \"-\"),\n  fragments = fragpath,\n  annotation = annotation\n)\n\n\nView file:\n\n\nCode\npbmc\n\n\nAn object of class Seurat \n180488 features across 11898 samples within 2 assays \nActive assay: RNA (36601 features, 0 variable features)\n 1 layer present: counts\n 1 other assay present: ATAC\n\n\n\n\n9.2.2 üìï Step 2: Computing QC metrics\nWe can compute per-cell quality control metrics using the DNA accessibility data and remove cells that are outliers for these metrics, as well as cells with low or unusually high counts for either the RNA or ATAC assay.\n\n\nCode\nDefaultAssay(pbmc) &lt;- \"ATAC\"\n\npbmc &lt;- NucleosomeSignal(pbmc)\npbmc &lt;- TSSEnrichment(pbmc)\n\n\nExtracting TSS positions\n\n\nExtracting fragments at TSSs\n\n\n\nComputing TSS enrichment score\n\n\nThe relationship between variables stored in the object metadata can be visualized using the¬†DensityScatter()¬†function. This can also be used to quickly find suitable cutoff values for different QC metrics by setting¬†quantiles=TRUE:\n\n\nCode\nDensityScatter(pbmc, x = 'nCount_ATAC', y = 'TSS.enrichment', log_x = TRUE, quantiles = TRUE)\n\n\n\n\n\nWe can plot the distribution of each QC metric separately using a violin plot:\n\n\nCode\nVlnPlot(\n  object = pbmc,\n  features = c(\"nCount_RNA\", \"nCount_ATAC\", \"TSS.enrichment\", \"nucleosome_signal\"),\n  ncol = 4,\n  pt.size = 0\n)\n\n\n\n\n\nFinally we remove cells that are outliers for these QC metrics. The exact QC thresholds used will need to be adjusted according to your dataset.\n\n\nCode\n# filter out low quality cells\npbmc &lt;- subset(\n  x = pbmc,\n  subset = nCount_ATAC &lt; 100000 &\n    nCount_RNA &lt; 25000 &\n    nCount_ATAC &gt; 1800 &\n    nCount_RNA &gt; 1000 &\n    nucleosome_signal &lt; 2 &\n    TSS.enrichment &gt; 1\n)\npbmc\n\n\nAn object of class Seurat \n180488 features across 11211 samples within 2 assays \nActive assay: ATAC (143887 features, 0 variable features)\n 2 layers present: counts, data\n 1 other assay present: RNA\n\n\n\n\n9.2.3 üìò Step 3: Analysis on the RNA assay\nWe can normalize the gene expression data using SCTransform, and reduce the dimensionality using PCA.\n\n\nCode\nDefaultAssay(pbmc) &lt;- \"RNA\"\npbmc &lt;- SCTransform(pbmc)\n\n\nRunning SCTransform on assay: RNA\n\n\nRunning SCTransform on layer: counts\n\n\nvst.flavor='v2' set. Using model with fixed slope and excluding poisson genes.\n\n\nVariance stabilizing transformation of count matrix of size 24459 by 11211\n\n\nModel formula is y ~ log_umi\n\n\nGet Negative Binomial regression parameters per gene\n\n\nUsing 2000 genes, 5000 cells\n\n\nFound 167 outliers - those will be ignored in fitting/regularization step\n\n\nSecond step: Get residuals using fitted parameters for 24459 genes\n\n\nComputing corrected count matrix for 24459 genes\n\n\nCalculating gene attributes\n\n\nWall clock passed: Time difference of 1.82833 mins\n\n\nDetermine variable features\n\n\nCentering data matrix\n\n\nGetting residuals for block 1(of 3) for counts dataset\n\n\nGetting residuals for block 2(of 3) for counts dataset\n\n\nGetting residuals for block 3(of 3) for counts dataset\n\n\nCentering data matrix\n\n\nFinished calculating residuals for counts\n\n\nSet default assay to SCT\n\n\nCode\npbmc &lt;- RunPCA(pbmc)\n\n\nPC_ 1 \nPositive:  VCAN, SAT1, PLXDC2, SLC8A1, NEAT1, DPYD, ZEB2, NAMPT, LRMDA, LYZ \n       FCN1, AOAH, LYN, ANXA1, CD36, JAK2, ARHGAP26, TYMP, RBM47, PID1 \n       PLCB1, LRRK2, ACSL1, LYST, IRAK3, DMXL2, MCTP1, TCF7L2, AC020916.1, GAB2 \nNegative:  EEF1A1, RPL13, RPS27, RPL13A, RPL41, RPS27A, RPS2, RPL3, RPS12, RPL11 \n       RPS18, BCL2, LEF1, BCL11B, RPL23A, RPL10, BACH2, IL32, RPL34, INPP4B \n       RPS3, CAMK4, IL7R, RPS26, RPS14, RPL30, RPL19, LTB, RPLP2, SKAP1 \nPC_ 2 \nPositive:  GNLY, CCL5, NKG7, CD247, IL32, PRKCH, PRF1, BCL11B, INPP4B, LEF1 \n       VCAN, IL7R, DPYD, THEMIS, GZMA, NEAT1, CAMK4, RORA, AOAH, PLCB1 \n       TXK, GZMH, TC2N, TRBC1, ANXA1, FYB1, STAT4, PITPNC1, TRAC, AAK1 \nNegative:  BANK1, IGHM, AFF3, IGKC, RALGPS2, MS4A1, CD74, PAX5, EBF1, FCRL1 \n       CD79A, OSBPL10, LINC00926, COL19A1, BLK, NIBAN3, IGHD, CD22, HLA-DRA, CD79B \n       ADAM28, PLEKHG1, AP002075.1, COBLL1, LIX1-AS1, CCSER1, TCF4, BCL11A, STEAP1B, GNG7 \nPC_ 3 \nPositive:  LEF1, CAMK4, EEF1A1, MAML2, PDE3B, FHIT, BACH2, IL7R, INPP4B, TSHZ2 \n       SERINC5, NELL2, CCR7, BCL2, ANK3, PRKCA, FOXP1, TCF7, BCL11B, AC139720.1 \n       RPL11, LTB, RPL13, OXNAD1, RPS27A, MLLT3, TRABD2A, RPS12, RASGRF2, VCAN \nNegative:  GNLY, NKG7, CCL5, PRF1, GZMA, GZMH, KLRD1, SPON2, FGFBP2, CST7 \n       GZMB, CCL4, TGFBR3, KLRF1, CTSW, BNC2, PDGFD, ADGRG1, PPP2R2B, PYHIN1 \n       A2M, IL2RB, CLIC3, MCTP2, NCAM1, ACTB, TRDC, SAMD3, NCALD, MYBL1 \nPC_ 4 \nPositive:  BANK1, IGHM, VCAN, IGKC, PAX5, MS4A1, GNLY, FCRL1, RALGPS2, EBF1 \n       LINC00926, CD79A, OSBPL10, COL19A1, NKG7, ARHGAP24, CCL5, IGHD, BACH2, PLCB1 \n       PDE4D, DPYD, LIX1-AS1, CD22, LARGE1, PLEKHG1, PLXDC2, STEAP1B, ANXA1, AP002075.1 \nNegative:  TCF4, LINC01374, CUX2, AC023590.1, RHEX, PLD4, EPHB1, LINC01478, PTPRS, LINC00996 \n       ZFAT, LILRA4, CLEC4C, COL26A1, FAM160A1, CCDC50, PLXNA4, ITM2C, SCN9A, COL24A1 \n       UGCG, RUNX2, NRP1, GZMB, IRF8, SLC35F3, JCHAIN, BCL11A, TNFRSF21, AC007381.1 \nPC_ 5 \nPositive:  CDKN1C, FCGR3A, TCF7L2, IFITM3, MTSS1, AIF1, CST3, LST1, MS4A7, WARS \n       PSAP, ACTB, SERPINA1, HLA-DPA1, IFI30, CD74, COTL1, FCER1G, CFD, HLA-DRA \n       FTL, HLA-DRB1, SMIM25, CSF1R, TMSB4X, FMNL2, SAT1, MAFB, S100A4, HLA-DPB1 \nNegative:  VCAN, TCF4, PLCB1, LINC01374, RHEX, CUX2, AC023590.1, DPYD, EPHB1, LINC01478 \n       PTPRS, ANXA1, ZFAT, LINC00996, CD36, GZMB, PLXDC2, ARHGAP26, FCHSD2, COL26A1 \n       CLEC4C, LILRA4, ACSL1, PLXNA4, AC020916.1, DYSF, ARHGAP24, CSF3R, LRMDA, MEGF9 \n\n\n\n\n\n\n\n\nCaution\n\n\n\nIf you have this error:\n‚ÄúError in getGlobalsAndPackages(expr, envir = envir, globals = globals) :\nThe total size of the 19 globals exported for future expression (‚ÄòFUN()‚Äô) is 4.69 GiB.. This exceeds the maximum allowed size of 500.00 MiB (option ‚Äòfuture.globals.maxSize‚Äô). The three largest globals are ‚ÄòFUN‚Äô (4.67 GiB of class ‚Äòfunction‚Äô), ‚Äòumi_bin‚Äô (19.28 MiB of class ‚Äònumeric‚Äô) and ‚Äòdata_step1‚Äô (1.27 MiB of class ‚Äòlist‚Äô)‚Äú\n\nYou need to use parallelization in Seurat with future. If you want know more about this read this issue and documentation.\n\n\n\n\n9.2.4 üìô Step 4: Analysis on the ATAC assay\nHere we process the DNA accessibility assay the same way we would process a scATAC-seq dataset, by performing latent semantic indexing (LSI).\n\n\nCode\n# Normalization and linear dimensional reduction (LSI)\nDefaultAssay(pbmc) &lt;- \"ATAC\"\npbmc &lt;- FindTopFeatures(pbmc, min.cutoff = 5)\npbmc &lt;- RunTFIDF(pbmc)\n\n\nPerforming TF-IDF normalization\n\n\nCode\npbmc &lt;- RunSVD(pbmc)\n\n\nRunning SVD\n\n\nScaling cell embeddings\n\n\n\n\n9.2.5 ‚úíÔ∏è Step 5: Annotating cell types\nTo annotate cell types in the dataset we can transfer cell labels from an existing PBMC reference dataset using tools in the Seurat package. See the Seurat reference mapping vignette for more information.\nWe‚Äôll use an annotated PBMC reference dataset from Hao et al.¬†(2020), available for download here: https://atlas.fredhutch.org/data/nygc/multimodal/pbmc_multimodal.h5seurat\nNote that the SeuratDisk package is required to load the reference dataset. Installation instructions for SeuratDisk can be found here.\n\n\n\n\n\n\nInstall Seurat-disk\n\n\n\n\n\nSeuratDisk is not currently available on CRAN. You can install it from¬†GitHub¬†with:\n\n\nCode\nif (!requireNamespace(\"remotes\", quietly = TRUE)) {\n  install.packages(\"remotes\")\n}\nremotes::install_github(\"mojaveazure/seurat-disk\")\n\n\nIf you have problems you can use this way, from this issue:\n\nDownload the package source locally (bash terminal):\n\ncd ~/\ngit clone https://github.com/mojaveazure/seurat-disk\n\nInstall package from source:\n\n\n\nCode\ninstall.packages(\"~/seurat-disk\", repos = NULL, type = \"source\")\n\n\n\n\n\n\n\nCode\nlibrary(SeuratDisk)\n\n\nRegistered S3 method overwritten by 'SeuratDisk':\n  method            from  \n  as.sparse.H5Group Seurat\n\n\nCode\n# load PBMC reference\nreference &lt;- LoadH5Seurat(\"data/pbmc_multimodal.h5seurat\", assays = list(\"SCT\" = \"counts\"), reductions = 'spca')\n\n\nValidating h5Seurat file\n\n\nInitializing SCT with counts\n\n\nAdding variable feature information for SCT\n\n\nAdding miscellaneous information for SCT\n\n\nAdding reduction spca\n\n\nAdding cell embeddings for spca\n\n\nAdding feature loadings for spca\n\n\nAdding miscellaneous information for spca\n\n\nAdding graph wknn\n\n\nAdding graph wsnn\n\n\nAdding command information\n\n\nAdding cell-level metadata\n\n\nCode\nreference &lt;- UpdateSeuratObject(reference)\n\n\nValidating object structure\n\n\nUpdating object slots\n\n\nEnsuring keys are in the proper structure\n\n\nUpdating matrix keys for DimReduc 'spca'\n\n\nEnsuring keys are in the proper structure\n\n\nEnsuring feature names don't have underscores or pipes\n\n\nUpdating slots in SCT\n\n\nUpdating slots in wknn\n\n\nCannot find wknn in the object, setting default assay of wknn to SCT\n\n\nUpdating slots in wsnn\n\n\nCannot find wsnn in the object, setting default assay of wsnn to SCT\n\n\nUpdating slots in spca\n\n\nValidating object structure for SCTAssay 'SCT'\n\n\nValidating object structure for Graph 'wknn'\n\n\nValidating object structure for Graph 'wsnn'\n\n\nValidating object structure for DimReduc 'spca'\n\n\nObject representation is consistent with the most current Seurat version\n\n\nCode\nDefaultAssay(pbmc) &lt;- \"SCT\"\n\n# transfer cell type labels from reference to query\ntransfer_anchors &lt;- FindTransferAnchors(\n  reference = reference,\n  query = pbmc,\n  normalization.method = \"SCT\",\n  reference.reduction = \"spca\",\n  recompute.residuals = FALSE,\n  dims = 1:50\n)\n\n\nProjecting cell embeddings\n\n\nFinding neighborhoods\n\n\nFinding anchors\n\n\n    Found 14597 anchors\n\n\nCode\npredictions &lt;- TransferData(\n  anchorset = transfer_anchors, \n  refdata = reference$celltype.l2,\n  weight.reduction = pbmc[['pca']],\n  dims = 1:50\n)\n\n\nFinding integration vectors\n\n\nFinding integration vector weights\n\n\nPredicting cell labels\n\n\nCode\npbmc &lt;- AddMetaData(\n  object = pbmc,\n  metadata = predictions\n)\n\n# set the cell identities to the cell type predictions\nIdents(pbmc) &lt;- \"predicted.id\"\n\n# remove low-quality predictions\npbmc &lt;- pbmc[, pbmc$prediction.score.max &gt; 0.5]\n\n\n\n\n9.2.6 üìê Step 6: Joint UMAP visualization\nUsing the weighted nearest neighbor methods in¬†Seurat v4, we can compute a joint neighbor graph that represent both the gene expression and DNA accessibility measurements.\n\n\nCode\n# build a joint neighbor graph using both assays\npbmc &lt;- FindMultiModalNeighbors(\n  object = pbmc,\n  reduction.list = list(\"pca\", \"lsi\"), \n  dims.list = list(1:50, 2:40),\n  modality.weight.name = \"RNA.weight\",\n  verbose = TRUE\n)\n\n\nCalculating cell-specific modality weights\n\n\nFinding 20 nearest neighbors for each modality.\n\n\nCalculating kernel bandwidths\n\n\nWarning in FindMultiModalNeighbors(object = pbmc, reduction.list = list(\"pca\",\n: The number of provided modality.weight.name is not equal to the number of\nmodalities. SCT.weight ATAC.weight are used to store the modality weights\n\n\nFinding multimodal neighbors\n\n\nConstructing multimodal KNN graph\n\n\nConstructing multimodal SNN graph\n\n\nCode\n# build a joint UMAP visualization\npbmc &lt;- RunUMAP(\n  object = pbmc,\n  nn.name = \"weighted.nn\",\n  assay = \"RNA\",\n  verbose = TRUE\n)\n\n\nWarning: The default method for RunUMAP has changed from calling Python UMAP via reticulate to the R-native UWOT using the cosine metric\nTo use Python UMAP via reticulate, set umap.method to 'umap-learn' and metric to 'correlation'\nThis message will be shown once per session\n\n\n18:31:32 UMAP embedding parameters a = 0.9922 b = 1.112\n\n\n18:31:38 Commencing smooth kNN distance calibration using 8 threads with target n_neighbors = 20\n18:31:41 Found 2 connected components, falling back to random initialization\n18:31:41 Initializing from uniform random\n18:31:41 Commencing optimization for 200 epochs, with 316712 positive edges\n18:31:55 Optimization finished\n\n\nCode\nDimPlot(pbmc, label = TRUE, repel = TRUE, reduction = \"umap\") + NoLegend()\n\n\n\n\n\n\n\n9.2.7 üìä Step 7: Linking peaks to genes\nFor each gene, we can find the set of peaks that may regulate the gene by by computing the correlation between gene expression and accessibility at nearby peaks, and correcting for bias due to GC content, overall accessibility, and peak size. See the Signac paper for a full description of the method we use to link peaks to genes.\nRunning this step on the whole genome can be time consuming, so here we demonstrate peak-gene links for a subset of genes as an example. The same function can be used to find links for all genes by omitting the genes.use parameter:\n\n\nCode\nDefaultAssay(pbmc) &lt;- \"ATAC\"\n\n# first compute the GC content for each peak\npbmc &lt;- RegionStats(pbmc, genome = BSgenome.Hsapiens.UCSC.hg38)\n\n\nWarning in RegionStats.default(object = regions, genome = genome, verbose =\nverbose, : Not all seqlevels present in supplied genome\n\n\nCode\n# link peaks to genes\npbmc &lt;- LinkPeaks(\n  object = pbmc,\n  peak.assay = \"ATAC\",\n  expression.assay = \"SCT\",\n  genes.use = c(\"LYZ\", \"MS4A1\")\n)\n\n\nTesting 2 genes and 143871 peaks\n\n\nWarning in .merge_two_Seqinfo_objects(x, y): Each of the 2 combined objects has sequence levels not in the other:\n  - in 'x': GL000194.1, GL000195.1, GL000205.2, GL000219.1, KI270711.1, KI270713.1, KI270721.1, KI270726.1, KI270727.1, KI270728.1, KI270731.1, KI270734.1\n  - in 'y': chrMT\n  Make sure to always combine/compare objects based on the same reference\n  genome (use suppressWarnings() to suppress this warning).\n\n\nWarning: UNRELIABLE VALUE: One of the 'future.apply' iterations\n('future_lapply-1') unexpectedly generated random numbers without declaring so.\nThere is a risk that those random numbers are not statistically sound and the\noverall results might be invalid. To fix this, specify 'future.seed=TRUE'. This\nensures that proper, parallel-safe random numbers are produced via the\nL'Ecuyer-CMRG method. To disable this check, use 'future.seed = NULL', or set\noption 'future.rng.onMisuse' to \"ignore\".\n\n\nWarning: UNRELIABLE VALUE: One of the 'future.apply' iterations\n('future_lapply-2') unexpectedly generated random numbers without declaring so.\nThere is a risk that those random numbers are not statistically sound and the\noverall results might be invalid. To fix this, specify 'future.seed=TRUE'. This\nensures that proper, parallel-safe random numbers are produced via the\nL'Ecuyer-CMRG method. To disable this check, use 'future.seed = NULL', or set\noption 'future.rng.onMisuse' to \"ignore\".\n\n\nWe can visualize these links using the¬†CoveragePlot()¬†function, or alternatively we could use the¬†CoverageBrowser()¬†function in an interactive analysis:\n\n\nCode\nidents.plot &lt;- c(\"B naive\", \"B intermediate\", \"B memory\",\n                 \"CD14 Mono\", \"CD16 Mono\", \"CD8 TEM\", \"CD8 Naive\")\n\npbmc &lt;- SortIdents(pbmc)\n\n\nCreating pseudobulk profiles for 27 variables across 143887 features\n\n\nComputing euclidean distance between pseudobulk profiles\n\n\nClustering distance matrix\n\n\nCode\np1 &lt;- CoveragePlot(\n  object = pbmc,\n  region = \"MS4A1\",\n  features = \"MS4A1\",\n  expression.assay = \"SCT\",\n  idents = idents.plot,\n  extend.upstream = 500,\n  extend.downstream = 10000\n)\n\np2 &lt;- CoveragePlot(\n  object = pbmc,\n  region = \"LYZ\",\n  features = \"LYZ\",\n  expression.assay = \"SCT\",\n  idents = idents.plot,\n  extend.upstream = 8000,\n  extend.downstream = 5000\n)\n\npatchwork::wrap_plots(p1, p2, ncol = 1)\n\n\n\n\n\n\n\nCode\nsessionInfo()\n\n\nR version 4.4.1 (2024-06-14 ucrt)\nPlatform: x86_64-w64-mingw32/x64\nRunning under: Windows 11 x64 (build 22631)\n\nMatrix products: default\n\n\nlocale:\n[1] LC_COLLATE=English_United States.utf8 \n[2] LC_CTYPE=English_United States.utf8   \n[3] LC_MONETARY=English_United States.utf8\n[4] LC_NUMERIC=C                          \n[5] LC_TIME=English_United States.utf8    \n\ntime zone: America/Mexico_City\ntzcode source: internal\n\nattached base packages:\n[1] stats4    stats     graphics  grDevices utils     datasets  methods  \n[8] base     \n\nother attached packages:\n [1] SeuratDisk_0.0.0.9021             future_1.34.0                    \n [3] BSgenome.Hsapiens.UCSC.hg38_1.4.5 BSgenome_1.72.0                  \n [5] rtracklayer_1.64.0                BiocIO_1.14.0                    \n [7] Biostrings_2.72.1                 XVector_0.44.0                   \n [9] EnsDb.Hsapiens.v86_2.99.0         ensembldb_2.28.1                 \n[11] AnnotationFilter_1.28.0           GenomicFeatures_1.56.0           \n[13] AnnotationDbi_1.66.0              Biobase_2.64.0                   \n[15] GenomicRanges_1.56.1              GenomeInfoDb_1.40.1              \n[17] IRanges_2.38.1                    S4Vectors_0.42.1                 \n[19] BiocGenerics_0.50.0               Seurat_5.1.0                     \n[21] SeuratObject_5.0.2                sp_2.1-4                         \n[23] Signac_1.14.0                    \n\nloaded via a namespace (and not attached):\n  [1] RcppAnnoy_0.0.22            splines_4.4.1              \n  [3] later_1.3.2                 bitops_1.0-8               \n  [5] tibble_3.2.1                polyclip_1.10-7            \n  [7] rpart_4.1.23                XML_3.99-0.17              \n  [9] fastDummies_1.7.4           lifecycle_1.0.4            \n [11] hdf5r_1.3.11                globals_0.16.3             \n [13] lattice_0.22-6              MASS_7.3-60.2              \n [15] backports_1.5.0             magrittr_2.0.3             \n [17] Hmisc_5.1-3                 plotly_4.10.4              \n [19] rmarkdown_2.28              yaml_2.3.10                \n [21] httpuv_1.6.15               glmGamPoi_1.16.0           \n [23] sctransform_0.4.1           spam_2.10-0                \n [25] spatstat.sparse_3.1-0       reticulate_1.39.0          \n [27] cowplot_1.1.3               pbapply_1.7-2              \n [29] DBI_1.2.3                   RColorBrewer_1.1-3         \n [31] abind_1.4-8                 zlibbioc_1.50.0            \n [33] Rtsne_0.17                  purrr_1.0.2                \n [35] biovizBase_1.52.0           RCurl_1.98-1.16            \n [37] nnet_7.3-19                 tweenr_2.0.3               \n [39] VariantAnnotation_1.50.0    GenomeInfoDbData_1.2.12    \n [41] ggrepel_0.9.6               irlba_2.3.5.1              \n [43] listenv_0.9.1               spatstat.utils_3.1-0       \n [45] goftest_1.2-3               RSpectra_0.16-2            \n [47] spatstat.random_3.3-2       fitdistrplus_1.2-1         \n [49] parallelly_1.38.0           DelayedMatrixStats_1.26.0  \n [51] leiden_0.4.3.1              codetools_0.2-20           \n [53] DelayedArray_0.30.1         RcppRoll_0.3.1             \n [55] ggforce_0.4.2               tidyselect_1.2.1           \n [57] UCSC.utils_1.0.0            farver_2.1.2               \n [59] base64enc_0.1-3             matrixStats_1.4.0          \n [61] spatstat.explore_3.3-2      GenomicAlignments_1.40.0   \n [63] jsonlite_1.8.8              Formula_1.2-5              \n [65] progressr_0.14.0            ggridges_0.5.6             \n [67] survival_3.6-4              tools_4.4.1                \n [69] ica_1.0-3                   Rcpp_1.0.13                \n [71] glue_1.7.0                  gridExtra_2.3              \n [73] SparseArray_1.4.8           xfun_0.48                  \n [75] MatrixGenerics_1.16.0       dplyr_1.1.4                \n [77] withr_3.0.1                 fastmap_1.2.0              \n [79] fansi_1.0.6                 digest_0.6.36              \n [81] R6_2.5.1                    mime_0.12                  \n [83] colorspace_2.1-1            scattermore_1.2            \n [85] tensor_1.5                  dichromat_2.0-0.1          \n [87] spatstat.data_3.1-2         RSQLite_2.3.7              \n [89] utf8_1.2.4                  tidyr_1.3.1                \n [91] generics_0.1.3              data.table_1.16.2          \n [93] httr_1.4.7                  htmlwidgets_1.6.4          \n [95] S4Arrays_1.4.1              uwot_0.2.2                 \n [97] pkgconfig_2.0.3             gtable_0.3.5               \n [99] blob_1.2.4                  lmtest_0.9-40              \n[101] htmltools_0.5.8.1           dotCall64_1.1-1            \n[103] ProtGenerics_1.36.0         scales_1.3.0               \n[105] png_0.1-8                   spatstat.univar_3.0-1      \n[107] knitr_1.48                  rstudioapi_0.17.0          \n[109] reshape2_1.4.4              rjson_0.2.22               \n[111] checkmate_2.3.2             nlme_3.1-164               \n[113] curl_5.2.2                  zoo_1.8-12                 \n[115] cachem_1.1.0                stringr_1.5.1              \n[117] KernSmooth_2.23-24          vipor_0.4.7                \n[119] parallel_4.4.1              miniUI_0.1.1.1             \n[121] foreign_0.8-86              ggrastr_1.0.2              \n[123] restfulr_0.0.15             pillar_1.9.0               \n[125] grid_4.4.1                  vctrs_0.6.5                \n[127] RANN_2.6.2                  promises_1.3.0             \n[129] xtable_1.8-4                cluster_2.1.6              \n[131] beeswarm_0.4.0              htmlTable_2.4.3            \n[133] evaluate_1.0.1              cli_3.6.2                  \n[135] compiler_4.4.1              Rsamtools_2.20.0           \n[137] rlang_1.1.3                 crayon_1.5.3               \n[139] future.apply_1.11.2         labeling_0.4.3             \n[141] ggbeeswarm_0.7.2            plyr_1.8.9                 \n[143] stringi_1.8.4               viridisLite_0.4.2          \n[145] deldir_2.0-4                BiocParallel_1.38.0        \n[147] munsell_0.5.1               lazyeval_0.2.2             \n[149] spatstat.geom_3.3-3         Matrix_1.7-0               \n[151] RcppHNSW_0.6.0              patchwork_1.3.0            \n[153] sparseMatrixStats_1.16.0    bit64_4.0.5                \n[155] ggplot2_3.5.1               KEGGREST_1.44.1            \n[157] shiny_1.9.1                 SummarizedExperiment_1.34.0\n[159] ROCR_1.0-11                 igraph_2.0.3               \n[161] memoise_2.0.1               fastmatch_1.1-4            \n[163] bit_4.0.5"
  },
  {
    "objectID": "Section2_P15_intro.html#references",
    "href": "Section2_P15_intro.html#references",
    "title": "6¬† Practical 15: Multimodal analysis and Integration",
    "section": "9.3 References",
    "text": "9.3 References\n\nSignac tutorial - Merging objects\nharmony batch effect\n10x tutorial - Batch Effect Correction in Chromium Single Cell ATAC Data\nSignac tutorial - scATAC-seq data integration\nSignac tutorial - Integrating scRNA-seq and scATAC-seq data\nSeurat tutorial - Dictionary Learning for cross-modality integration\nAzimuth annotation\nEpigenomics workshop 2024 - Integrating scATAC-seq and scRNA-seq data\nSignac tutorial - Joint RNA and ATAC analysis: 10x multiomic"
  },
  {
    "objectID": "Section2_P15_retos.html",
    "href": "Section2_P15_retos.html",
    "title": "7¬† Exercises",
    "section": "",
    "text": "Exercise in Google Colab\n\n\n\n\nCreate a copy of the Google colab notebook part 1 on your one drive.\nRun the exercise.\n\n\n\n\n\nCode\n# load output\nobj.atac &lt;- readRDS(file = \"data/obj_atac_final.rds\")\n\n# plot\nDimPlot(\n  obj.atac, group.by = \"predicted.l2\",\n  reduction = \"ref.umap\", label = TRUE\n) + ggtitle(\"ATAC\") + NoLegend()"
  },
  {
    "objectID": "Section3_P16_intro.html",
    "href": "Section3_P16_intro.html",
    "title": "8¬† Practical 16: Motif analysis with Signac",
    "section": "",
    "text": "9 Motif analysis\nThe previous analysis (Practical 14 - Find differentially accessible peaks between cell types, da_peaks) can help us to identify putative cis-regulatory elements that are critical for regulating cell type identity or cell state transitions. This is usually achieved via the binding of certain trans-regulators, e.g.¬†TFs, to those open chromatin regions.\nThe binding of most TFs have strong sequence specificity, which can be summarized into sequence motifs, i.e.¬†the TF binding motifs. If certain TFs play important roles in those regulations, it is very likely that the cell-type-specific peaks are regions enriched for the binding, with their genomic sequences enriched for the corresponding TF binding motifs. In this case, by checking the motifs enriched in those cell-type-specific peaks, we may be then able to identify TFs responsible for establishment and maintanence of cell type identity.\nTo do that, we also need a database of TF binding motifs. Indeed, there are several commonly used databases, including the commercial ones like¬†TRANSFAC¬†and open source ones like¬†JASPAR. By scanning for sequences matching those motifs, we can predict possible binding sites of the TFs with binding motif information in the databases, and then check their enrichment in the peak list of interest in relative to the other peaks.\nAlso you can construct cell trajectories with Monocle 3 using single-cell ATAC-seq data. Please see the Monocle 3 website for information about installing Monocle 3.\nFor this step we‚Äôll use the dataset introduced and pre-processed in the¬†trajectory building vignette.\nCode\nsessionInfo()\n\n\nR version 4.4.1 (2024-06-14 ucrt)\nPlatform: x86_64-w64-mingw32/x64\nRunning under: Windows 11 x64 (build 22631)\n\nMatrix products: default\n\n\nlocale:\n[1] LC_COLLATE=English_United States.utf8 \n[2] LC_CTYPE=English_United States.utf8   \n[3] LC_MONETARY=English_United States.utf8\n[4] LC_NUMERIC=C                          \n[5] LC_TIME=English_United States.utf8    \n\ntime zone: America/Mexico_City\ntzcode source: internal\n\nattached base packages:\n[1] stats4    stats     graphics  grDevices utils     datasets  methods  \n[8] base     \n\nother attached packages:\n [1] chromVAR_1.26.0                   ggseqlogo_0.2                    \n [3] motifmatchr_1.26.0                patchwork_1.3.0.9000             \n [5] BSgenome.Hsapiens.UCSC.hg38_1.4.5 BSgenome_1.72.0                  \n [7] rtracklayer_1.64.0                BiocIO_1.14.0                    \n [9] Biostrings_2.72.1                 XVector_0.44.0                   \n[11] GenomicRanges_1.56.2              GenomeInfoDb_1.40.1              \n[13] IRanges_2.38.1                    S4Vectors_0.42.1                 \n[15] BiocGenerics_0.50.0               TFBSTools_1.42.0                 \n[17] JASPAR2020_0.99.10                Seurat_5.1.0                     \n[19] SeuratObject_5.0.2                sp_2.1-4                         \n[21] Signac_1.14.0                    \n\nloaded via a namespace (and not attached):\n  [1] RcppAnnoy_0.0.22            splines_4.4.1              \n  [3] later_1.3.2                 bitops_1.0-8               \n  [5] R.oo_1.26.0                 tibble_3.2.1               \n  [7] polyclip_1.10-7             XML_3.99-0.17              \n  [9] DirichletMultinomial_1.46.0 fastDummies_1.7.4          \n [11] lifecycle_1.0.4             pwalign_1.0.0              \n [13] globals_0.16.3              lattice_0.22-6             \n [15] MASS_7.3-60.2               magrittr_2.0.3             \n [17] plotly_4.10.4               rmarkdown_2.28             \n [19] yaml_2.3.10                 httpuv_1.6.15              \n [21] sctransform_0.4.1           spam_2.10-0                \n [23] spatstat.sparse_3.1-0       reticulate_1.39.0          \n [25] cowplot_1.1.3               pbapply_1.7-2              \n [27] DBI_1.2.3                   CNEr_1.40.0                \n [29] RColorBrewer_1.1-3          abind_1.4-8                \n [31] zlibbioc_1.50.0             Rtsne_0.17                 \n [33] R.utils_2.12.3              purrr_1.0.2                \n [35] RCurl_1.98-1.16             pracma_2.4.4               \n [37] GenomeInfoDbData_1.2.12     ggrepel_0.9.6              \n [39] irlba_2.3.5.1               listenv_0.9.1              \n [41] spatstat.utils_3.1-0        seqLogo_1.70.0             \n [43] goftest_1.2-3               RSpectra_0.16-2            \n [45] annotate_1.82.0             spatstat.random_3.3-2      \n [47] fitdistrplus_1.2-1          parallelly_1.38.0          \n [49] leiden_0.4.3.1              codetools_0.2-20           \n [51] DelayedArray_0.30.1         RcppRoll_0.3.1             \n [53] DT_0.33                     tidyselect_1.2.1           \n [55] UCSC.utils_1.0.0            farver_2.1.2               \n [57] matrixStats_1.4.0           spatstat.explore_3.3-2     \n [59] GenomicAlignments_1.40.0    jsonlite_1.8.8             \n [61] progressr_0.14.0            ggridges_0.5.6             \n [63] survival_3.6-4              tools_4.4.1                \n [65] TFMPvalue_0.0.9             ica_1.0-3                  \n [67] Rcpp_1.0.13                 glue_1.7.0                 \n [69] gridExtra_2.3               SparseArray_1.4.8          \n [71] xfun_0.48                   MatrixGenerics_1.16.0      \n [73] dplyr_1.1.4                 withr_3.0.1                \n [75] fastmap_1.2.0               fansi_1.0.6                \n [77] caTools_1.18.3              digest_0.6.36              \n [79] R6_2.5.1                    mime_0.12                  \n [81] colorspace_2.1-1            GO.db_3.19.1               \n [83] scattermore_1.2             poweRlaw_0.80.0            \n [85] gtools_3.9.5                tensor_1.5                 \n [87] spatstat.data_3.1-2         RSQLite_2.3.7              \n [89] R.methodsS3_1.8.2           utf8_1.2.4                 \n [91] tidyr_1.3.1                 generics_0.1.3             \n [93] data.table_1.16.2           httr_1.4.7                 \n [95] htmlwidgets_1.6.4           S4Arrays_1.4.1             \n [97] uwot_0.2.2                  pkgconfig_2.0.3            \n [99] gtable_0.3.5                blob_1.2.4                 \n[101] lmtest_0.9-40               htmltools_0.5.8.1          \n[103] dotCall64_1.1-1             scales_1.3.0               \n[105] Biobase_2.64.0              png_0.1-8                  \n[107] spatstat.univar_3.0-1       knitr_1.48                 \n[109] rstudioapi_0.17.0           tzdb_0.4.0                 \n[111] rjson_0.2.23                reshape2_1.4.4             \n[113] curl_5.2.3                  nlme_3.1-164               \n[115] zoo_1.8-12                  cachem_1.1.0               \n[117] stringr_1.5.1               KernSmooth_2.23-24         \n[119] parallel_4.4.1              miniUI_0.1.1.1             \n[121] AnnotationDbi_1.66.0        restfulr_0.0.15            \n[123] pillar_1.9.0                grid_4.4.1                 \n[125] vctrs_0.6.5                 RANN_2.6.2                 \n[127] promises_1.3.0              xtable_1.8-4               \n[129] cluster_2.1.6               evaluate_1.0.1             \n[131] readr_2.1.5                 cli_3.6.2                  \n[133] compiler_4.4.1              Rsamtools_2.20.0           \n[135] rlang_1.1.3                 crayon_1.5.3               \n[137] future.apply_1.11.2         labeling_0.4.3             \n[139] plyr_1.8.9                  stringi_1.8.4              \n[141] viridisLite_0.4.2           deldir_2.0-4               \n[143] BiocParallel_1.38.0         munsell_0.5.1              \n[145] lazyeval_0.2.2              spatstat.geom_3.3-3        \n[147] Matrix_1.7-0                RcppHNSW_0.6.0             \n[149] hms_1.1.3                   bit64_4.5.2                \n[151] future_1.34.0               ggplot2_3.5.1              \n[153] KEGGREST_1.44.1             shiny_1.9.1                \n[155] SummarizedExperiment_1.34.0 ROCR_1.0-11                \n[157] igraph_2.0.3                memoise_2.0.1              \n[159] fastmatch_1.1-4             bit_4.5.0"
  },
  {
    "objectID": "Section3_P16_intro.html#references",
    "href": "Section3_P16_intro.html#references",
    "title": "8¬† Practical 16: Motif analysis with Signac",
    "section": "11.1 References",
    "text": "11.1 References\n\nSignac - tutorial Motif analysis with Signac\nEpigenomic workshop 2024 - Motif analysis\nSignac - tutorial Building trajectories with Monocle 3\nSignac - tutorial Transcription factor footprinting"
  },
  {
    "objectID": "Section3_P16_retos.html#section",
    "href": "Section3_P16_retos.html#section",
    "title": "9¬† Exercises",
    "section": "9.1 ",
    "text": "9.1"
  },
  {
    "objectID": "Section3_P17_intro.html",
    "href": "Section3_P17_intro.html",
    "title": "10¬† Practical 17: Exploring results (graphs)",
    "section": "",
    "text": "11 CITE-seq and scATAC-seq\nTo learn more about how the antibody barcode matrix is computationally generated from the sequencing data, please visit¬†CITE-seq-Count.¬†To learn more about CITE-seq and feature barcoding, please visit the CITE-seq site."
  },
  {
    "objectID": "Section3_P17_intro.html#references",
    "href": "Section3_P17_intro.html#references",
    "title": "10¬† Practical 17: Exploring results (graphs)",
    "section": "11.1 References",
    "text": "11.1 References\n\nSignac - tutorial Building trajectories with Monocle 3\nSignac - tutorial Visualization of genomic regions\nLeblanc & Lettre, et al.¬†2023. Major cell-types in multiomic single-nucleus datasets impact statistical modeling of links between regulatory sequences and target genes. Scientific reports\nBuenrostro, et al.¬†2015. Single-cell chromatin accessibility reveals principles of regulatory variation. Nature.\nOrr Ashenber, et al.¬†Tutorial. Analysis of single cell RNA-seq data\nDer, et al.¬†2017.Single cell RNA sequencing to dissect the molecular heterogeneity in lupus nephritis JCI insight.\nCITE-seq and scATAC-seq tutorial."
  },
  {
    "objectID": "Section3_P17_retos.html#section",
    "href": "Section3_P17_retos.html#section",
    "title": "11¬† Exercises",
    "section": "11.1 ",
    "text": "11.1"
  },
  {
    "objectID": "Section3_P18_others.html",
    "href": "Section3_P18_others.html",
    "title": "12¬† Other tools used in scATAC-seq",
    "section": "",
    "text": "Overview of the scATAC-seq analysis steps."
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "13¬† Summary",
    "section": "",
    "text": "This is a callout block of the type ‚Äúnote‚Äù.\n\n\n\n\n\n\nCaution\n\n\n\n\n\nCallouts can be collapsible.\n\n\n\n\n\n\n\n\n\nMy heading\n\n\n\nThe first heading used within the callout is used as the callout heading.\n\n\n\n\n\n\n\n\nTip\n\n\n\nThe icon can also be hidden, like this.\n\n\n\n\n\n\n\n\nThis is a simpler callout, without specifying the ‚Äútype‚Äù."
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "https://www.nature.com/articles/s43586-020-00008-9\nhttps://www.nature.com/articles/s43586-020-00008-9\nhttps://www.nature.com/articles/s43586-020-00008-9\nhttps://www.nature.com/articles/s43586-020-00008-9\n\n\nhttps://www.nature.com/articles/s41596-022-00692-9\n\nsessionInfo()"
  },
  {
    "objectID": "Section1_P13_retos.html#dataset-overview-1k-peripheral-blood-mononuclear-cells-pbmcs-from-a-healthy-donor",
    "href": "Section1_P13_retos.html#dataset-overview-1k-peripheral-blood-mononuclear-cells-pbmcs-from-a-healthy-donor",
    "title": "3¬† Exercises",
    "section": "3.1 Dataset overview: 1k Peripheral Blood Mononuclear Cells (PBMCs) from a Healthy Donor",
    "text": "3.1 Dataset overview: 1k Peripheral Blood Mononuclear Cells (PBMCs) from a Healthy Donor\nFor this tutorial, we will be analyzing a single-cell ATAC-seq dataset of human peripheral blood mononuclear cells (PBMCs) provided by 10x Genomics (Next GEM v1.1). The following files are used in this course, all available through the 10x Genomics website:\n\nThe Raw data: Filtered peak barcode matrix.\nThe Metadata: Per-barcode fragment counts & metrics.\nThe fragments file: Barcoded and aligned fragment file.\nThe fragments file index: Fragments file index.\n\n\n\n\n\n\n\nQuestions\n\n\n\nCheck the data report and answer the questions.\n\nHow many cells were recovered?\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\n1,195 nuclei were recovered.\n\n\n\n\nWhich version of Cell Ranger ATAC is used?\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nSingle Cell ATAC dataset analyzed using Cell Ranger ATAC 1.1.0\n\n\n\n\nWhat version of the genome did they use?\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nhg19\n\n\n\n\n\n\n\n\nPre-processing workflow\n\n\n\n\nflowchart LR    \n  A(Import Data) --&gt; B(Annotation)     \n  B --&gt; C(Computing QC metrics)     \n  C --&gt; D(Normalization and linear \\ndimensional reduction)      \n  D --&gt; E(Non-linear dimensional \\nreduction and clustering) \n\n\n\n\n\n\n\n\n\n\n\nExercise in Google Colab\n\n\n\n\nCreate a copy of the Google colab notebook part 13 on your one drive.\nRun the exercise."
  },
  {
    "objectID": "Section2_P15_retos.html#dataset-overview-pbmc-from-a-healthy-donor---granulocytes-removed-through-cell-sorting-3k",
    "href": "Section2_P15_retos.html#dataset-overview-pbmc-from-a-healthy-donor---granulocytes-removed-through-cell-sorting-3k",
    "title": "7¬† Exercises",
    "section": "7.1 Dataset overview: PBMC from a Healthy Donor - Granulocytes Removed Through Cell Sorting (3k)",
    "text": "7.1 Dataset overview: PBMC from a Healthy Donor - Granulocytes Removed Through Cell Sorting (3k)\nFor this tutorial, we will be analyzing a single-cell ATAC-seq dataset of human peripheral blood mononuclear cells (PBMCs) (3K) provided by 10x Genomics (Cell Ranger ARC 2.0.0). The following files are used in this course, all available through the 10x Genomics website:\n\nThe Raw data: Filtered peak barcode matrix.\nThe fragments file: Barcoded and aligned fragment file.\nThe fragments file index: Fragments file index.\n\n\n\n\n\n\n\nExercise in Google Colab\n\n\n\n\nCreate a copy of the Google colab notebook part 15 on your one drive.\nRun the exercise."
  },
  {
    "objectID": "Section2_P15_retos.html#references",
    "href": "Section2_P15_retos.html#references",
    "title": "7¬† Exercises",
    "section": "7.2 References",
    "text": "7.2 References\n\nSignac tutorial - Joint RNA and ATAC analysis: 10x multiomic"
  },
  {
    "objectID": "Section2_P14_retos.html#references",
    "href": "Section2_P14_retos.html#references",
    "title": "5¬† Exercises",
    "section": "5.1 References",
    "text": "5.1 References\n\nSignac tutorial - Analyzing PBMC scATAC-seq (Signac tutorial)\nSignac tutorial - Analyzing PBMC scATAC-seq"
  },
  {
    "objectID": "Section3_P16_retos.html#dataset-overview-1k-peripheral-blood-mononuclear-cells-pbmcs-from-a-healthy-donor",
    "href": "Section3_P16_retos.html#dataset-overview-1k-peripheral-blood-mononuclear-cells-pbmcs-from-a-healthy-donor",
    "title": "9¬† Exercises",
    "section": "9.1 Dataset overview: 1k Peripheral Blood Mononuclear Cells (PBMCs) from a Healthy Donor",
    "text": "9.1 Dataset overview: 1k Peripheral Blood Mononuclear Cells (PBMCs) from a Healthy Donor\nFor this tutorial, we will be analyzing a single-cell ATAC-seq dataset of human peripheral blood mononuclear cells (PBMCs) provided by 10x Genomics (Next GEM v1.1). The following files are used in this course, all available through the 10x Genomics website:\n\nThe Raw data: Filtered peak barcode matrix.\nThe Metadata: Per-barcode fragment counts & metrics.\nThe fragments file: Barcoded and aligned fragment file.\nThe fragments file index: Fragments file index.\n\n\n\n\n\n\n\nExercise in Google Colab\n\n\n\n\nCreate a copy of the Google colab notebook part 16 on your one drive.\nRun the exercise."
  },
  {
    "objectID": "Section3_P16_retos.html#references",
    "href": "Section3_P16_retos.html#references",
    "title": "9¬† Exercises",
    "section": "9.2 References",
    "text": "9.2 References\n\nSignac tutorial - Analyzing PBMC scATAC-seq (Signac tutorial)\nSignac tutorial - Analyzing PBMC scATAC-seq"
  },
  {
    "objectID": "Section3_P17_intro.html#the-number-of-cells-in-each-cell-type-biases-the-null-distributions-and-statistics-of-the-z-scores-method",
    "href": "Section3_P17_intro.html#the-number-of-cells-in-each-cell-type-biases-the-null-distributions-and-statistics-of-the-z-scores-method",
    "title": "10¬† Practical 17: Exploring results (graphs)",
    "section": "10.1 The number of cells in each cell-type biases the null distributions and statistics of the Z-scores method",
    "text": "10.1 The number of cells in each cell-type biases the null distributions and statistics of the Z-scores method\nThis study compares Z-scores, derived from the Pearson R value of cis-links between ATACseq peaks and nearby genes, to their matched trans-link null distribution. After analyzing PBMC multiomic data, significant differences were found between the Pearson R coefficients and Z-scores for many peak-gene links. An example is an ATACseq peak near the NOD2 gene, correlated with monocytes (R = 0.12), but showing no significant link using Z-scores (P = 0.07). However, a significant link was found with SNX20 (P = 0.02). Bimodal null distributions for trans-peaks at the NOD2 locus make Z-scores inaccurate. Excluding specific cell-type peaks leads to a unimodal distribution, highlighting the impact of peak selection on Z-scores.\n\n\n\nFigure¬†10.1: The Z-scores method misses candidate regulatory sequences linked to NOD2 expression in peripheral blood mononuclear cells (PBMC). (A) The Z-scores model matches an ATACseq peak for GC content and coverage with ATACseq peaks in trans to create a scaled null distribution, producing Z-scores for each trans-links and the tested peak. (B) ATACseq tracks at the NOD2 locus identified in PBMC. The grey areas (labeled 1‚Äì2-3) highlight the top three ATACseq peaks correlations with NOD2 expression using the simple Pearson R method. Peak #1 (chr16-50,684,843‚Äì50,685,984) includes an eQTL for NOD2 that is also associated with leprosy and Crohn‚Äôs disease by GWAS. The loops highlighted in the ‚ÄúLinks‚Äù row are identified using the Z-score method (P-value‚Äâ&lt;‚Äâ0.05); we note that there is no significant link between peak chr16-50,684,843‚Äì50,685,984 (peak #1) and NOD2. Loops are drawn from the middle of the ATACseq peaks to the transcription start site of the correlated gene(s). In the right column, we showed (top to bottom) RNAseq UMAP of cell-type annotations, SNX20 expression density, NOD2 expression density, and chr16-50,684,843‚Äì50,685,984 ATACseq accessibility density. The violin plots represent NOD2 expression levels in each cell-type. Leblanc & Lettre, et al.¬†2023. Scientific reports."
  },
  {
    "objectID": "Section3_P17_intro.html#single-cell-lineage-determination",
    "href": "Section3_P17_intro.html#single-cell-lineage-determination",
    "title": "10¬† Practical 17: Exploring results (graphs)",
    "section": "10.2 Single cell lineage determination",
    "text": "10.2 Single cell lineage determination\n\n\n\nFigure¬†10.2: Lineage determination of single cells from skin, kidney, and peripheral blood mononuclear cells (PBMCs). (A) Clustering of cells (n = 899) by t-distributed stochastic neighbor embedding (t-SNE). Cells are colored based on tissue of origin from skin (blue), kidney cells (red), and PBMCs (yellow). (B) Six distinct clusters generated by t-SNE plotting. (C) Differentially expressed genes across 6 cell clusters. In this heat map, rows correspond to individual genes found to be selectively upregulated in individual clusters (P &lt; 0.01). (D) Violin plots demonstrating expression of lineage markers that indicate the identity of the clusters generated by t-SNE plotting. Der, et al.¬†2017. JCI insight."
  },
  {
    "objectID": "Section3_P17_intro.html#single-cell-chromatin-accessibility-reveals-principles-of-regulatory-variation",
    "href": "Section3_P17_intro.html#single-cell-chromatin-accessibility-reveals-principles-of-regulatory-variation",
    "title": "10¬† Practical 17: Exploring results (graphs)",
    "section": "10.3 Single-cell chromatin accessibility reveals principles of regulatory variation",
    "text": "10.3 Single-cell chromatin accessibility reveals principles of regulatory variation\n\n\n\nFigure¬†10.3: Structured cis-variability across single epigenomes. a, Per-cell deviations of expected fragments across a region within chromosome 1, For display, only large deviation cells are shown (n = 186 cells). b, Pearson correlation coefficient representing chromosome compartment signal of interaction frequency from a chromatin conformation capture assay (left, analysis carried out of data from ref. 27) or doubly correlated normalized deviations of scATAC-seq (right) from chromosome 1. Data in white represents masked regions due to highly repetitive regions. c, Permuted cis-correlation map for chromosome 1 (analysed identically to b). d, Box highlights a representative region depicting long-range covariability. Buenrostro, et al.¬†2015. Nature"
  },
  {
    "objectID": "Section3_P17_retos.html",
    "href": "Section3_P17_retos.html",
    "title": "11¬† Exercises",
    "section": "",
    "text": "12 Data visualization methods in Seurat\nYou can visualize your Seurat results in various ways depending on the analysis you want to highlight. To get started, you can download the Seurat object from the 2,700 PBMC tutorial available on¬†SeuratData.\nReference to this tutorial for detailed guidance."
  },
  {
    "objectID": "Section3_P17_retos.html#a-spatially-resolved-single-cell-genomic-atlas-of-the-adult-human",
    "href": "Section3_P17_retos.html#a-spatially-resolved-single-cell-genomic-atlas-of-the-adult-human",
    "title": "11¬† Exercises",
    "section": "11.2 A spatially resolved single cell genomic atlas of the adult human",
    "text": "11.2 A spatially resolved single cell genomic atlas of the adult human\nYou can explore the behavior of public datasets using Cellxgene. It provides interactive visualizations that help you examine and analyze single-cell data easily."
  },
  {
    "objectID": "Section3_P17_retos.html#data-visualization-methods-in-seurat",
    "href": "Section3_P17_retos.html#data-visualization-methods-in-seurat",
    "title": "11¬† Exercises",
    "section": "11.1 Data visualization methods in Seurat",
    "text": "11.1 Data visualization methods in Seurat\nYou can visualize your Seurat results in various ways depending on the analysis you want to highlight. To get started, you can download the Seurat object from the 2,700 PBMC tutorial available on¬†SeuratData.\nReference to this tutorial for detailed guidance."
  },
  {
    "objectID": "Section3_P18_others.html#gene-regulatory-network-reconstruction",
    "href": "Section3_P18_others.html#gene-regulatory-network-reconstruction",
    "title": "12¬† Other tools used in scATAC-seq",
    "section": "12.1 Gene regulatory network reconstruction",
    "text": "12.1 Gene regulatory network reconstruction\nIn the previous section, we demonstrated how to integrate RNA and ATAC assays to identify cell type heterogeneity and explore cis- and trans-regulatory elements important for cell identity. Another approach is to focus on gene relationships, specifically the regulatory interactions between TFs and cis-regulatory elements that control target gene transcription‚Äîthis is known as gene regulatory network (GRN) analysis.¬†\nOne of the early approaches involves checking expression correlations between genes to build a co-expression network, followed by the identification of co-expression modules. These modules contain genes thought to be co-regulated, and their regulators can be identified through methods like TF binding motif enrichment analysis. A well-known example is WGCNA (Weighted Gene Coexpression Network Analysis), commonly used in bulk transcriptome analysis.\nAnother approach treats the expression of a gene as a function of its regulators‚Äô (mostly TFs) expression. The goal is to fit a linear or non-linear regression model using the target gene expression as the response and the expression of all possible regulators as covariates. This is followed by statistical tests to determine significant contributions from covariates or uses regularization for feature selection. Examples include methods like GENIE3 and GRNBoost2, which have also proven applicable to single-cell transcriptomic data.\nWhile these methods provide valuable insights into regulatory mechanisms, they rely solely on the expression of TFs and target genes, overlooking the biological requirement that the target gene must contain a binding motif for a TF at its cis-regulatory elements (promoter or enhancers). To enhance biological relevance, pipelines now integrate both expression data and TF binding site predictions. SCENIC, developed by the Aerts lab, adds a filtering step after using GRNBoost2 to infer the raw network, removing interactions lacking corresponding TF binding motifs at the gene‚Äôs promoter. CellOracle takes a different approach by identifying putative TFs via motif searching at promoters and enhancers, using public or ATAC-seq data, and then applying a regularized regression model with only TFs that have predicted binding motifs. Further details are available in their respective publications.\nWith scMultiome data, we can quantitatively incorporate chromatin accessibility profiles into GRN inference, which is the rationale behind Pando. Pando first scans for TF binding motifs at each peak in the ATAC assay, applying further filtering based on sequence conservation and public regulatory element databases (e.g., ENCODE). For each gene, it builds a linear regression model that considers the expression of TFs with predicted binding sites as well as their interaction with the peak accessibility at those binding sites. More details can be found in the biorxiv preprint. In the next part of this tutorial, we will briefly demonstrate how to run Pando on scMultiome data to identify potential TF targets.\n\nPando\n\nPando had a major upgrade to change its defined data structure, which was to avoid possible effect by any major change to the data structure of Seurat objects in the future. The following tutorial session has therefore been updated to adapt to the changes.\n\n\n\n12.1.1 References\n\nTutorial of single-cell RNA-ATAC multiomic sequencing data analysis in R\nDataset integration using Seurat and other Rtools\nSingle Cell ATAC-seq Analysis with Cicero\nMajor cell-types in multiomic single-nucleus datasets impact statistical modeling of links between regulatory sequences and target genes"
  }
]